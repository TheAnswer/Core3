/*
				Copyright <SWGEmu>
		See file COPYING for copying conditions. */

package server.zone.objects.scene;

import engine.log.Logger;
import engine.util.u3d.Coordinate;
import engine.util.u3d.QuadTreeEntry;
import system.util.Vector;
import system.util.VectorMap;
import engine.util.u3d.Quaternion;
import engine.service.proto.BasePacket;
import engine.service.proto.BaseMessage;
import system.util.SortedVector;
import system.lang.ref.Reference;
import engine.core.Task;
import engine.util.u3d.Vector3;
include engine.util.Facade;
include templates.params.ObserverEventType;
include server.zone.ZoneReference;
include server.zone.objects.scene.SceneObjectType;
import server.zone.ZoneProcessServer;
import server.zone.ZoneClientSession;
import server.zone.Zone;
import server.zone.ZoneServer;
import server.zone.objects.building.BuildingObject;
import server.zone.packets.object.ObjectMenuResponse;
import server.zone.objects.creature.CreatureObject;
import server.zone.objects.staticobject.StaticObject;
import server.zone.packets.scene.AttributeListMessage;
import engine.util.Observer;
include server.zone.objects.scene.variables.StringId;
include server.zone.objects.scene.TransferErrorCode;
include server.zone.objects.scene.variables.PendingTasksMap;
include server.zone.objects.scene.SessionFacadeType;
include server.zone.objects.scene.ObserverType;
include templates.manager.PlanetMapCategory;
include templates.manager.TemplateManager;
include templates.SharedObjectTemplate;
include server.zone.objects.scene.components.ZoneComponent;
include server.zone.objects.scene.components.ObjectMenuComponent;
include server.zone.objects.scene.components.ContainerComponent;
include server.zone.objects.scene.components.AttributeListComponent;
include server.zone.objects.scene.components.DataObjectComponentReference;
include server.zone.objects.scene.variables.ContainerPermissions;
import server.zone.objects.region.CityRegion;
import engine.util.u3d.Matrix4;
import system.thread.ReadWriteLock;
import system.thread.Mutex;
include server.zone.objects.scene.variables.ContainerObjectsMap;
import server.zone.objects.tangible.TangibleObject;
import server.zone.objects.creature.ai.AiAgent;
include templates.appearance.MeshData;
include templates.collision.BaseBoundingVolume;
include server.zone.objects.scene.variables.StdFunction;
include server.metrics.Metrics;

@mock
class SceneObject extends QuadTreeEntry implements Logger, Metrics {
	protected transient ZoneProcessServer server;

	protected transient ZoneComponent zoneComponent;
	protected transient ObjectMenuComponent objectMenuComponent;
	protected transient AttributeListComponent attributeListComponent;
	protected transient ContainerComponent containerComponent;

	protected transient SharedObjectTemplate templateObject;

	protected boolean sendToClient;

	@dereferenced
	protected ZoneReference zone;

	@dereferenced
	protected DataObjectComponentReference dataObjectComponent; 

	protected transient Matrix4 transformForCollisionMatrix;

	protected unsigned int containerType;
	protected unsigned int containerVolumeLimit;

	@dereferenced
	protected ContainerPermissions containerPermissions;

	protected unsigned int serverObjectCRC;
	protected unsigned int clientObjectCRC;

	@dereferenced
	protected Quaternion direction;

	protected unsigned int movementCounter;

	@dereferenced
	protected StringId objectName;

	protected transient PendingTasksMap pendingTasks;

	protected boolean staticObject;

	@dereferenced
	protected VectorMap<unsigned int, Facade> objectActiveSessions;

	protected unsigned int gameObjectType;
	protected unsigned int containmentType;

	protected int planetMapCategory;
	protected int planetMapSubCategory;

	protected unicode customName;

	@weakReference
	protected transient CityRegion cityRegion;

	protected transient SceneObject savedRootParent;

	@dereferenced
	protected SortedVector<SceneObject> childObjects;

	@dereferenced
	protected VectorMap<string, SceneObject> slottedObjects;

	@dereferenced
	protected transient ReadWriteLock containerLock;

	@dereferenced
	protected transient Mutex parentLock;

	@dereferenced
	protected ContainerObjectsMap containerObjects;

	/**
	 * SceneObject constructor, used to initialize the object.
	 * @pre { templateData is a valid SharedObjectTemplate LuaObject that contains the necessary values to initialize SceneObject }
	 * @post { SceneObject is initialized } 
	 * @param templateData templateData points to the SharedObjectTemplate LuaObject that is used to initialize SceneObejct members 
	 */
	public SceneObject() {
		initializePrivateData();
	}

	public void finalize() {

	}

	public native void initializePrivateData();

	public void initializeContainerObjectsMap() {
		containerObjects.setContainer(asSceneObject());
	}

	/**
	 * Reads and sets the template data from a SharedObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { SceneObject members are initialized }
	 * @param templateData templateData points to the LuaObject that is used to initialize SceneObejct members
	 */
	@local
	public abstract native void loadTemplateData(SharedObjectTemplate templateData);

	/**
	* Acts as a copy constructor for ManagedObjects. This function will be invoked by the cloneObject function in the object manager.
	* @pre { objectToClone is a valid pointer }
	* @post { SceneObject members are properly initialized using data from objectToClone }
	* @param objectToClone objectToClone is the source object being used to clone into the current SceneObject
	*/
	public abstract void onCloneObject(SceneObject objectToClone) {
		containerObjects.setContainer(asSceneObject());

		//TODO: Move container clone and other sceno cases here
	}

	public abstract native void createComponents();
	public abstract native void createContainerComponent();
	public abstract native void createObjectMenuComponent();

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	public native void initializeTransientMembers();

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	public native void notifyLoadFromDatabase();

	/**
	 * Logs an info message
	 * @pre {}
	 * @post { message has been printed to console or file }
	 * @param msg message to print
	 * @param forced if true, always prints the message to console 
	 */
	@dirty
	public void info(final string msg, boolean forced = false) {
		Logger.info(msg, forced);
	}

	/**
	 * Logs an error message
	 * @pre {}
	 * @post {error message has been printed to console and file }
	 * @param msg error message to print
	 */
	@dirty
	public void error(final string msg) {
		Logger.error(msg);
	}

	/**
	 * Logs a debug message
	 * @pre {}
	 * @post {debug message has been printed to console and file }
	 * @param msg debug message to print
	 */
	@dirty
	public void debug(final string msg) {
		Logger.debug(msg);
	}

	/**
	 * Returns number of specified game objects in range
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return number of objects in range
	 */
	@dirty
	public native int inRangeObjects(unsigned int gameObjectType, float range);

	/**
	 * Evaluates if the object is in range
	 * @pre { this object is locked, obj is locked}
	 * @post { thisobject is locked, obj is locked }
	 * @param obj object that will be checked against
	 * @param range range to check
	 * @return returns true if this object is in range with obj
	 */
	@dirty
	public native boolean isInRange(SceneObject obj, float range);
	/**
	 * Evaluates if the object is in range without checking zone
	 * @pre { this object is locked, obj is locked}
	 * @post { thisobject is locked, obj is locked }
	 * @param obj object that will be checked against
	 * @param range range to check
	 * @return returns true if this object is in range with obj
	 */
	@dirty
	public native boolean isInRangeZoneless(SceneObject obj, float range);
	/**
	 * Evaluates if the object is in range using 3 dimensions
	 * @pre { this object is locked, obj is locked}
	 * @post { thisobject is locked, obj is locked }
	 * @param obj object that will be checked against
	 * @param range range to check
	 * @return returns true if this object is in range with obj
	 */
	@dirty
	public native boolean isInRange3d(SceneObject obj, float range);

	/**
	 * Tries to add/link object
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be added to the current object
	 * @param containmentType arrangement type that will be used to add the object
	 * @param notifyClient if true in range objects will be updated with the change
	 * @return returns true if the object has been successfully added
	 */
	public native abstract boolean transferObject(SceneObject object, int containmentType, boolean notifyClient = false, boolean allowOverflow = false, boolean notifyRoot = true);

	/**
	 * Tries to remove/unlink object
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be removed from the current object
	 * @param destination SceneObject that will be the new destination of the object.
	 * @param notifyClient not used currently
	 * @return returns true if the object has been successfully removed
	 */
	public native abstract boolean removeObject(SceneObject object, SceneObject destination, boolean notifyClient = false);

	/**
	 * Destroys the object from the world
	 */
	public abstract void destroyObjectFromWorld(boolean sendSelfDestroy) {
		zoneComponent.destroyObjectFromWorld(this, sendSelfDestroy);
	}

	/**
	 * Removes object from zone without removing from parent. Should only be used for container unloading.
	 */
	public native void removeObjectFromZone(Zone zone, SceneObject par);

	/**
	 * Evaluates if this object has the necessary free slots to be able to add the specified SceneObject
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be checked
	 * @param error error string that the player will receive on error
	 * @return returns 0 on success, or error code
	 */
	@dirty
	public native abstract int canAddObject(SceneObject object, int containmentType, string errorDescription);

	/**
	 * 
	 */
	@dirty
	public abstract int notifyObjectInsertedToChild(SceneObject object, SceneObject child, SceneObject oldParent) {
		return 0;
	}

	@dirty
	public abstract int notifyObjectRemovedFromChild(SceneObject object, SceneObject child) {
		return 0;
	}

	@reference
	public native abstract SceneObject getCraftedComponentsSatchel();

	/**
	 * Calls the appropriate UI Listener Function
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param player CreatureObject using the item
	 * @param value value from packet
	 */
	@dirty
	public abstract void synchronizedUIListen(CreatureObject player, int value) {
		Logger.info("Unhandled synchronizedUIListen", true);
	}

	/**
	 * Calls the appropriate UI Stop Listener Function
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param player CreatureObject using the item
	 * @param value value from packet
	 */
	@dirty
	public abstract void synchronizedUIStopListen(CreatureObject player, int value) {
		Logger.info("Unhandled synchronizedUIStopListen", true);
	}

	/**
	 * Updates this object to database (calls updatesToDatabaseAllObjects())
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param startTask if true, queues a new update task
	 */
	@dirty
	 public native void updateToDatabase();

	 /**
	  * Updates only this object to database without updating children
	  * WARNING use only when necessary
	  */
	@dirty
	 public native void updateToDatabaseWithoutChildren();

	/**
	 * Updates this object and childre objects to database
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param startTask if true, queues a new update task
	 */
	@dirty
	public native void updateToDatabaseAllObjects(boolean startTask);

	/**
	 * Destroys this object from database
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param destroyContainedObjects if true, will destroy from database all its contained objects
	 */
	public abstract native void destroyObjectFromDatabase(boolean destroyContainedObjects = false);

	/**
	 * Checks if the object can be destroyed
	 * @pre { player is locked }
	 * @post { player is locked }
	 * @param player Player that attempts to destroy this object
	 * @returns 0 on succes, != 0 on error
	 */
	@dirty
	public abstract int canBeDestroyed(CreatureObject player) {
		return 0;
	}

	/**
	 * Sends a SceneObjectCloseMessage of this object to client
	 * @pre { this object is locked }
	 * @post { this object is locked, client received the close message }
	 * @param client ZoneClientSession that will receive the message
	 */
	@dirty
	protected native void close(SceneObject client);

	/**
	 * Sends an UpdateContainmentMessage to client that adds/links this object to its parent object 
	 * @pre { this object is locked }
	 * @post { this object is locked, client received the link message }
	 * @param client ZoneClientSession that will receive the message
	 * @param containmentType arrangement type?
	 */
	@dirty
	protected native void link(SceneObject client, unsigned int containmentType = 4);

	/**
	 * Creates a new UpdateContainmentMessage that adds/links this object to the specified objectID
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param objectID object id of object to link
	 * @param containmentType arrangement type?
	 * @return returns a new valid UpdateContainmentMessage
	 */
	@dirty
	public native BaseMessage link(unsigned long objectID, unsigned int containmentType = 4);

	/**
	 * Sends the necessary messages to player in order to create this object
	 * @pre { this object is locked }
	 * @post { this object is locked, player received this object }
	 * @param player SceneObject that will receive the messages
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	@dirty
	public native abstract void sendTo(SceneObject player, boolean doClose, boolean forceLoadContainer = true);

	/**
	 * Sends the object without linking to its actual parent and without sending its children (f.e trade)
	 */
	@dirty
	public native abstract void sendWithoutParentTo(SceneObject player);

	@dirty
	public native abstract void sendWithoutContainerObjectsTo(SceneObject player);

	/**
	 * Sends a SceneObjectDestroyMessage of this object to client
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the destroy message }
	 * @param plaer SceneObject that will receive the message 
	 */
	@dirty
	public native abstract void sendDestroyTo(SceneObject player);

	/**
	 * Sends the baseline messages of this object to the specified player, needs to be overriden
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines 
	 */
	@dirty
	public abstract void sendBaselinesTo(SceneObject player) {
	}

	/**
	 * Sends the contained non slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the container objects }
	 * @param player SceneObject that will receive the objects 
	 */
	@dirty
	public native abstract void sendContainerObjectsTo(SceneObject player, boolean forceLoad);

	/**
	 * Sends the contained slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the slotted objects }
	 * @param player SceneObject that will receive the objects 
	 */
	@dirty
	public native abstract void sendSlottedObjectsTo(SceneObject player);

	/**
	 * Sends the necessary messages to owner client, needs to be overriden
	 * @pre { this object is locked }
	 * @post { this object is locked, owner received its own scene object }
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	@dirty
	public abstract void sendToOwner(boolean doClose = true) {
	}

	/**
	 * Sends an AttributeListMessage to specified object
	 * @pre { this object is locked }
	 * @post { this object is locked, object received the attribute list message }
	 * @param object SceneObject that will receive the message
	 */
	@dirty
	public native abstract void sendAttributeListTo(CreatureObject object);

	/**
	 * Fills the attribute list message options that are sent to player creature
	 * @pre { }
	 * @post { }
	 * @param msg attribute list message with the attributes
	 * @param object player creature to which the message is sent
	 */
	@local
	@dirty
	public abstract void fillAttributeList(AttributeListMessage msg, CreatureObject object) {

	}

	/**
	 * Updates the custom name of the object
	 * @pre { this locked }
	 * @post { this locked }
	 */
	public abstract void setCustomObjectName(final unicode name, boolean notifyClient) {
		customName = name;
	}

	/**
	 * Fills the radial options, needs to be overriden
	 * @pre { this object is locked }
	 * @post { this object is locked, menuResponse is complete}
	 * @param menuResponse ObjectMenuResponse that will be sent to the client
	 */
	@local
	@dirty
	public native abstract void fillObjectMenuResponse(ObjectMenuResponse menuResponse, CreatureObject player);

	/**
	 * Opens container contents to player
	 * @pre { }
	 * @post { }
	 * @param player CreatureObject to open the container to   
	 */
	@dirty
	public abstract native void openContainerTo(CreatureObject player);

	@local
	public abstract byte checkContainerPermission(CreatureObject player, unsigned short permission) {
		return containerComponent.checkContainerPermission(this, player, permission);
	}

	/**
	 * Closes the container of a player
	 */
	@dirty
	public abstract native void closeContainerTo(CreatureObject player, boolean notify = true);

	/**
	 * Inserts this object into zone
	 * @pre { this object is locked }
	 * @post { this object is locked and inserted into zone }
	 * @param zone Zone object where this object will be inserted
	 */
	public native abstract void notifyInsertToZone(Zone zone);

	/**
	 * Switches zone and position of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, is in the new zone and in the new position }
	 * @param newTerrainName Name of the new terrain where the player will be inserted.
	 * @param newPositionX new position X
	 * @param newPositionZ new position Z
	 * @param newPositionY new position Y
	 */
	public native abstract void switchZone(final string newTerrainName, float newPostionX, float newPositionZ, float newPositionY, unsigned long parentID = 0, boolean  toggleInvisibility = false);

	public native abstract void teleport(float newPositionX, float newPositionZ, float newPositionY, unsigned long parentID = 0);

	/**
	 * Updates the direction of this object, and braodcasts DataTransform with the update 
	 */
	public native void updateDirection(float fw, float fx, float fy, float fz);

	public native void updateDirection(float angleHeadingRadians);

	@local
	public void notifyInsert(QuadTreeEntry entry) {
		zoneComponent.notifyInsert(this, entry);
	}

	@local
	public void notifyDissapear(QuadTreeEntry entry) {
		zoneComponent.notifyDissapear(this, entry);
	}

	public native abstract void notifyRemoveFromZone();

	/**
	 * Updates position of this object to the rest of in range objects
	 * @pre { this object is locked}
	 * @post { this object is locked, in range objects are updated with the new position }
	 * @param lightUpdate if true a standalone message is sent to the in range objects
	 */
	public native abstract void updateZone(boolean lightUpdate, boolean sendPackets = true);

	/**
	 * Updates position and/or parent of this object and to the rest of in range objects
	 * @pre { this object is locked, newParent is a CellObject }
	 * @post {this object is locked, in range objects are updated of the new position and parent }
	 * @param newParent cellObject where this object is
	 * @param lightUpdate if true a standalone message is sent to the in range objects
	 */
	public native abstract void updateZoneWithParent(SceneObject newParent, boolean lightUpdate, boolean sendPackets = true); 

	/**
	 * Broadcasts the message to the in range objects
	 * @pre {this object is locked, message is not null }
	 * @post {this object is locked, in range objects received a copy of the message, message is deleted }
	 * @param sendSelf if true the owner if this object receives the message too
	 */
	@dirty
	public native void broadcastMessage(BasePacket message, boolean sendSelf, boolean lockZone = true);

	@dirty
	public native void broadcastMessagePrivate(BasePacket message, SceneObject selfObject, boolean lockZone);

	/**
	 * Broadcasts an object to the in range objects
	 * @pre {this object is locked, object is not null }
	 * @post {this object is locked, in range objects received the object }
	 * @param object SceneObject that will be sent to the in range objects
	 * @param sendSelf if true the owner of this object receives the object too
	 */
	@dirty
	public native void broadcastObject(SceneObject object, boolean sendSelf);

	@dirty
	public native void broadcastObjectPrivate(SceneObject object, SceneObject selfObject);

	/**
	 * Broadcasts an object to the in range objects
	 * @pre {this object is locked, object is not null }
	 * @post {this object is locked, in range objects received the object }
	 * @param object SceneObject that will be sent to the in range objects
	 * @param sendSelf if true the owner of this object receives the object too
	 */
	@dirty
	public native void broadcastDestroy(SceneObject object, boolean sendSelf);

	@dirty
	public native void broadcastDestroyPrivate(SceneObject object, SceneObject selfObject);

	/**
	 * Broadcasts a vector of messages to the in range objects
	 * @pre {this object is locked }
	 * @post { this object is locked, in range objects received the messages, messages are deleted and removed from the vector }
	 * @param messages a vector containing the messages to be sent, it will be emptied when messages get sent
	 * @param sendSelf if true the owner of this object receives the messages too
	 */
	@local
	@dirty
	public native void broadcastMessages(Vector<BasePacket> messages, boolean sendSelf);

	@local
	@dirty
	public native void broadcastMessagesPrivate(Vector<BasePacket> messages, SceneObject selfObject);

	/**
	 * Sends BasePacket msg to the owner of this object, needs to be overriden
	 * @pre { } 
	 * @post {owner of this object received message, message is deleted }
	 * @param msg BasePacket to be sent
	 */
	@dirty
	public abstract native void sendMessage(BasePacket msg);

	/**
	 * Compares object ids of this object with obj
	 * @pre { this object is locked, obj is not null }
	 * @post {this object is locked }
	 * @param obj SceneObject that will be compared to
	 * @return returns 1 if this < obj, -1 if this > obj and 0 if this == obj 
	 */
	@dirty
	@nativeStub
	public native int compareTo(SceneObject obj);

	/**
	 * Fills the specified vector with the containment objects of this object
	 * @pre { this obejct is locked }
	 * @post { this object is locked, objects is a vector map with the contained objects and their occupied slots }
	 * @param objects the vector map that will contain the objects and their occupied slots 
	 */
	@local
	@dirty
	public native void getSlottedObjects(@dereferenced VectorMap<string, SceneObject> objects);

	@local
	@dirty
	public native void getContainerObjects(@dereferenced VectorMap<unsigned long, SceneObject> objects);

	/**
	 * Returns the object id of the parent of this object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns 0 if this object doesnt have a parent, otherwise returns its object id
	 */
	@dirty
	public native unsigned long getParentID();

	/**
	 * Adds a pending task of this SceneObject
	 * @pre { this locked }
	 * @post { this locked}
	 * @param name Name of the task
	 * @param task Task to add
	 */
	@local
	public void addPendingTask(final string name, Task task, int miliseconds) {
		synchronized (containerLock) {
			if (getPendingTasks().put(name, task) > -1) {
				task.schedule(miliseconds);
			}
		}
	}

	/**
	 * Executes a task async of this SceneObject in a serialized manner
	 * Order of execution is guaranteed to be the same as insertion order
	 * @pre { this locked }
	 * @post { this locked}
	 * @param task Task to add
	 */
	@local
	public void executeOrderedTask(Task task) {
		synchronized (containerLock) {
			getPendingTasks().putOrdered(task, this);
		}
	}

	/**
	 * Executes a task async of this SceneObject in a serialized manner
	 * Order of execution is guaranteed to be the same as insertion order
	 * @pre { this locked }
	 * @post { this locked}
	 * @param function the lambda function for the task to run
	 * @param name Name of the task
	 */
	@local
	public native void executeOrderedTask(@dereferenced final StdFunction function, final string name);

	/**
	 * Removes a pending task from this SceneObject
	 * @pre { this locked }
	 * @post { this locked }
	 * @param name Name of the task to drop
	 */
	@local
	public void removePendingTask(final string name) {
		synchronized (containerLock) {
			if (pendingTasks == null)
				return;

			Task task = pendingTasks.get(name);

			if (task != null && task.isScheduled())
				task.cancel();

			pendingTasks.drop(name);
		}
	}

	@local
	public PendingTasksMap getPendingTasks() {
		synchronized (containerLock) {
			if (pendingTasks == null) {
				pendingTasks = new PendingTasksMap();
			}

			return pendingTasks;
		}
	}

	/**
	 * Looks up a specific pending tasks by the name
	 * @pre { this locked }
	 * @post { this locked }
	 * @param name Name of the task to lookup
	 */
	@local
	@dirty
	@reference
	public Task getPendingTask(final string name) {
		synchronized (containerLock) {
			if (pendingTasks == null)
				return null;

			return pendingTasks.get(name);
		}
	}

	@dirty
	public boolean containsPendingTask(final string name) {
		synchronized (containerLock) {
			if (pendingTasks == null)
				return false;

			return pendingTasks.contains(name);
		}
	}

	@dirty
	public native void showFlyText(final string file, final string aux, byte red, byte green, byte blue, boolean isPrivate = false);

	public native int getContainedObjectsRecursive();

	public abstract native int getCountableObjectsRecursive();

	public abstract native int getSizeOnVendorRecursive();

	/**
	 * Returns a Facade session
	 */
	@dirty
	@reference
	public Facade getActiveSession(unsigned int type) {
		return objectActiveSessions.get(type);
	}

	public void addActiveSession(unsigned int type, Facade session) {
		objectActiveSessions.put(type, session);
	}

	@read
	public boolean containsActiveSession(final unsigned int type) {
		return objectActiveSessions.contains(type);
	}

	public boolean dropActiveSession(unsigned int type) {
		return objectActiveSessions.drop(type);
	}

	@read
	public int getActiveSessionsCount() {
		return objectActiveSessions.size();
	}

	@local
	@dirty
	public VectorMap<unsigned int, Facade> getObjectActiveSessions() {
		return objectActiveSessions;
	}

	/**
	 * Handles the radial selection sent by the client, must be overriden by inherited objects
	 * @pre { this object is locked, player is locked }
	 * @post { this object is locked, player is locked }
	 * @param player CreatureObject that selected the option
	 * @param selectedID selected menu id
	 * @returns 0 if successfull
	 */
	public native abstract int handleObjectMenuSelect(CreatureObject player, byte selectedID);

	@dirty
	public native float getDistanceTo(SceneObject object);

	@local
	@dirty
	public native float getDistanceTo(Coordinate coordinate);

	public abstract native void updateVehiclePosition(boolean sendPackets);

	@dirty
	public native void playEffect(final string file, final string aux);

	@dirty
	public void playEffect(final string file) {
		playEffect(file, "");
	}

	/**
	 * Is called when this object has been inserted with an object
	 * @param object object that has been inserted
	 */
	@dirty
	public abstract int notifyObjectInserted(SceneObject object) {
		return 0;
	}

	/**
	 * Is called when an object was removed
	 * @param object object that has been inserted
	 */
	@dirty
	public abstract int notifyObjectRemoved(SceneObject object) {
		return 0;
	}

	@dirty
	@local
	@weakReference
	public abstract CityRegion getCityRegion() {
		return cityRegion;
	}

	@local
	public void setCityRegion(CityRegion region) {
		cityRegion = region;
	}

	@dirty
	public native Zone getZone();
	
	@dirty
	public native Zone getZoneUnsafe();

	@read 
	public Zone getLocalZone() {
		return zone.get();
	}

	@local
	@dereferenced
	@dirty
	public native Vector3 getCoordinate(float distance, float angleDegrees, boolean includeZ);

	@local
	@dereferenced
	@dirty
	public native Vector3 getWorldCoordinate(float distance, float angleDegrees, boolean includeZ);

	@mock
	@dirty
	public native float getWorldPositionX();

	@dirty
	@mock
	public native float getWorldPositionY();

	@dirty
	@mock
	public native float getWorldPositionZ();

	@dirty
	@local
	@dereferenced
	@mock
	public native Vector3 getWorldPosition();

	@read
	public float getDirectionX() {
		return direction.getX();
	}

	@read
	public float getDirectionZ() {
		return direction.getZ();
	}

	@read
	public float getDirectionY() {
		return direction.getY();
	}

	@read
	public float getDirectionW() {
		return direction.getW();
	}

	@dirty
	@local
	public native Quaternion getDirection();

	@read
	public unsigned int getClientObjectCRC() {
		return clientObjectCRC;
	}

	@read
	public unsigned int getServerObjectCRC() {
		return serverObjectCRC;
	}

	@read
	public boolean isWaypointObject() {
		return gameObjectType == SceneObjectType.WAYPOINT;
	}

	@local
	@dirty
	public StringId getObjectName() {
		return objectName;
	}

	@read
	public string getObjectNameStringIdFile() {
		return objectName.getFile();
	}

	@read
	public string getObjectNameStringIdName() {
		return objectName.getStringID();
	}

	@local
	@dirty
	public abstract string getDetailedDescription() {
		return templateObject.getDetailedDescription();
	}

	public abstract void setDetailedDescription(final string detail) {
		return;
	}

	public native int getArrangementDescriptorSize();
 
	@local
	public native final Vector<string> getArrangementDescriptor(int idx);

	@dirty
	public string getSlotDescriptor(int idx) {
		return templateObject.getSlotDescriptors().get(idx);
	}

	@dirty
	public boolean hasSlotDescriptor(final string descr) {
		for (int i = 0; i < getSlotDescriptorSize(); ++i) {
			if (getSlotDescriptor(i) == descr)
				return true;
		}

		return false;
	}

	@read
	public boolean hasArrangementDescriptor(final string descr) {
		return templateObject.hasArrangementDescriptor(descr);
	}

	@local
	public VectorMap<string, SceneObject> getSlottedObjects() {
		return slottedObjects;
	}

	@dirty
	@reference
	public native SceneObject getSlottedObject(final string slot);

	@dirty
	public int getSlotDescriptorSize() {
		if (templateObject.getSlotDescriptors() != null)
			return templateObject.getSlotDescriptors().size();

		return 0;
	}

	@dirty
	@reference
	public native SceneObject getSlottedObject(int idx);

	@dirty
	@reference
	public native SceneObject getContainerObjectRecursive(unsigned long oid);

	public native void dropSlottedObject(final string arrengementDescriptor);

	public native void removeSlottedObject(int index);

	@dirty
	public int getContainerObjectsSize() {
		return containerObjects.size();
	}

	@read
	public int getSlottedObjectsSize() {
		return slottedObjects.size();
	}

	@dirty
	public boolean isContainerFull() {
		return containerVolumeLimit <= containerObjects.size();
	}

	@dirty
	public boolean isContainerFullRecursive() {
		return containerVolumeLimit <= getCountableObjectsRecursive();
	}

	@read
	public unsigned int getContainerVolumeLimit() {
		return containerVolumeLimit;
	}

	@dirty
	@reference
	public SceneObject getContainerObject(int idx) {
		return containerObjects.get(idx);
	}

	@local
	public VectorMap<unsigned long, SceneObject> getContainerObjects() {
		return containerObjects.getContainerObjects();
	}

	@dirty
	public boolean hasObjectInContainer(unsigned long objectID) {
		return containerObjects.contains(objectID);
	}

	public native boolean hasObjectInSlottedContainer(SceneObject object) ;

	@dirty
	@reference
	public SceneObject getContainerObject(unsigned long objectID) {
		return containerObjects.get(objectID);
	}

	public void removeAllContainerObjects() {
		containerObjects.removeAll();
	}

	public void putInContainer(SceneObject obj, unsigned long key) {
		containerObjects.put(key, obj);
	}

	public void removeFromContainerObjects(int index) {
		containerObjects.removeElementAt(index);
	}

	public long getLastContainerAccess() {
		return containerObjects.getLastAccess().miliDifference();
	}

	public void unloadContainerObjects() {
		containerObjects.unloadObjects();
	}

	public boolean isContainerLoaded() {
		return containerObjects.isLoaded();
	}

	// Gets called when delayed-load containerObjects is loaded
	public native abstract void onContainerLoaded();

	public void setContainerVolumeLimit(int lim) {
		containerVolumeLimit = lim;
	}

	public void setContainerType(int type) {
		containerType = type;
	}

	@read
	public unsigned int getContainerType() {
		return containerType;
	}

	@dirty
	@reference
	public abstract ZoneClientSession getClient() {
		return null;
	}

	@read
	public unsigned int getGameObjectType() {
		return gameObjectType;
	}

	@read
	public unsigned int getClientGameObjectType() {
		return templateObject.getClientGameObjectType();
	}

	@read
	public unsigned int getContainmentType() {
		return containmentType;
	}

	@read
	public float getDirectionAngle() {
		return direction.getDegrees();
	}

	@read
	public float getSpecialDirectionAngle() {
		return direction.getSpecialDegrees();
	}

	/**
	 * Rotates an object by a specified number of degrees.
	 * @param degrees How many degrees to rotate the object with 0 being North.
	 * TODO: @param notifyClient
	 */
	public native void rotate(int degrees);

	/**
	 * Sets this objects direction so that the object is facing the specified object.
	 * @param obj The object to face.
	 * @param notifyClient if true, updates the client with the new direction
	 */
	public native void faceObject(SceneObject obj, boolean notifyClient = false);

	public native boolean isFacingObject(SceneObject obj);

	public native abstract void notifySelfPositionUpdate();

	@dirty
	public native void notifyPositionUpdate(QuadTreeEntry entry);

	/**
	 * @param player player that closed the container
	 */
	public native abstract void notifyCloseContainer(CreatureObject player);

	@read
	public unsigned int getMovementCounter() {
		return movementCounter;
	}

	@dirty
	@weakReference
	public native SceneObject getParent();

	public native void setParent(QuadTreeEntry entry);

	public native void setParent(QuadTreeEntry entry, boolean updateRecursively);

	@read
	public ZoneServer getZoneServer() {
		if (server != null)
			return server.getZoneServer();
		else
			return null;
	}

	/**
	 * Returns the parent of all children in the object tree
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns the parent of all children in the object tree
	 */
	@dirty
	public native SceneObject getRootParent();

	@dirty
	public native SceneObject getRootParentUnsafe();

	public native void updateSavedRootParentRecursive(SceneObject newRoot);

	/**
	 * Returns the parent of object type in the tree
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return Returns the parent of object type in the tree
	 */
	@dirty
	@reference
	public native SceneObject getParentRecursively(unsigned int gameObjectType);

	/**
	 * Evaluates if this object is a child of the specified SceneObject
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns true if this object is a child of object
	 */
	@dirty
	public native boolean isASubChildOf(SceneObject object);

	@local
	@dirty
	public native ReadWriteLock getContainerLock() {
		return containerLock;
	}

	@read
	public unicode getCustomObjectName() {
		return customName;
	}

	@read
	public string getLoggingName() {
		return Logger.getLoggingName();
	}

	@dirty
	@local
	@nativeStub
	@virtualStub
	public abstract native boolean isPlayerCreature();

	@local
	@read
	public boolean isVendor() {
		return dataObjectComponent != null && 
		dataObjectComponent.get() != null &&
		dataObjectComponent.get().isVendorData();
	}

	@local 
	@read
	public boolean isGCWBase(){

		return dataObjectComponent != null &&
		dataObjectComponent.get() != null &&
		dataObjectComponent.get().isGCWBaseData();
	}

	@local
	@read
	public boolean isTurret() {
		return dataObjectComponent != null && 
		dataObjectComponent.get() != null &&
		dataObjectComponent.get().isTurretData();
	}

	@local 
	@read
	public boolean isMinefield(){
		return dataObjectComponent != null && 
		dataObjectComponent.get() != null &&
		dataObjectComponent.get().isMinefieldData();
	}

	@local
	@read
	public boolean isDetector() {
		return dataObjectComponent != null && 
		dataObjectComponent.get() != null &&
		dataObjectComponent.get().isDetectorData();
	}

	@local
	@read
	public boolean isSecurityTerminal(){
		return dataObjectComponent != null && 
		dataObjectComponent.get() != null &&
		dataObjectComponent.get().isSecurityTerminalData();
	}

	@local
	@read
	public boolean isTurretControlTerminal(){
		return dataObjectComponent != null && 
		dataObjectComponent.get() != null &&
		dataObjectComponent.get().isTurretControlTerminalData();
	}

	@local
	@read
	public boolean isEventPerk() {
		return dataObjectComponent != null && 
		dataObjectComponent.get() != null &&
		dataObjectComponent.get().isEventPerkData();
	}

	@local
	@dirty
	public ZoneComponent getZoneComponent() {
		return zoneComponent;
	}

	@local
	@dirty
	public ObjectMenuComponent getObjectMenuComponent() {
		return objectMenuComponent;
	}

	@local
	@dirty
	public AttributeListComponent getAttributeListComponent() {
		return attributeListComponent;
	}

	@local
	@dirty
	public DataObjectComponentReference getDataObjectComponent() {
		return dataObjectComponent;
	}

	public native boolean isDecoration();

	@local
	public native void setObjectMenuComponent(final string name);

	@local
	public native void setContainerComponent(final string name);
	public native void setZoneComponent(final string name);

	public boolean isNoTrade() {
		return templateObject.isNoTrade();
	}

	@read
	public boolean isShuttleInstallation() {
		return gameObjectType == SceneObjectType.SHUTTLEINSTALLATION;
	}

	@read
	public boolean isPlayerObject() {
		return gameObjectType == SceneObjectType.PLAYEROBJECT;
	}

	@dirty
	public abstract boolean isActiveArea() {
		return false;
	}

	@dirty
	public abstract boolean isRegion() {
		return false;
	}

	@dirty
	@local
	@nativeStub
	@virtualStub
	public abstract native boolean isCreatureObject();
	
	@dirty
	@local
	@nativeStub
	@virtualStub
	public native abstract CreatureObject asCreatureObject();

	@dirty
	@local
	@nativeStub
	@virtualStub
	public native abstract boolean isAiAgent();

	@dirty
	@local
	@nativeStub
	@virtualStub
	public native abstract AiAgent asAiAgent();

	@dirty
	public abstract boolean isCreature() {
		return false;
	}

	@dirty
	public abstract boolean isShipObject() {
		return false;
	}

	@dirty
	@local
	@nativeStub
	@virtualStub
	public native abstract boolean isVehicleObject();

	@dirty
	public abstract boolean isDroidObject() {
		return false;
	}	

	@dirty
	@local
	@nativeStub
	@virtualStub
	public abstract native boolean isBuildingObject();

	@dirty
	@local
	public abstract BuildingObject asBuildingObject() {
		return null;
	}

	@dirty
	public abstract boolean isCloningBuildingObject() {
		return false;
	}

	@read
	public boolean isGarage() {
		return gameObjectType == SceneObjectType.GARAGEBUILDING || gameObjectType == SceneObjectType.GARAGEINSTALLATION;
	}

	@dirty
	public abstract boolean isWeaponObject() {
		return false;
	}

	@dirty
	public abstract boolean isWearableObject() {
		return false;
	}

	@dirty
	public abstract boolean isWearableContainerObject() {
		return false;
	}

	@dirty
	public abstract boolean isArmorObject() {
		return false;
	}

	@dirty
	public abstract boolean isRobeObject() {
		return false;
	}

	@dirty
	public abstract boolean isLightsaberCrystalObject() {
		return false;
	}

	@dirty
	public abstract boolean isFireworkObject() {
		return false;
	}

	@dirty
	public native boolean isPsgArmorObject() {
		return gameObjectType == SceneObjectType.SHIELDGENERATOR;
	}

	@dirty
	public abstract boolean isCellObject() {
		return false;
	}

	@dirty
	public abstract boolean isTangibleObject() {
		return false;
	}

	@dirty
	@local
	public abstract TangibleObject asTangibleObject() {
		return null;
	}

	@dirty
	@local
	@nativeStub
	public native SceneObject asSceneObject();

	@dirty
	public abstract boolean isResourceContainer() {
		return false;
	}

	@dirty
	public abstract boolean isResourceSpawn() {
		return false;
	}

	@dirty
	public abstract boolean isComponent() {
		return false;
	}

	@dirty
	public abstract boolean isIntangibleObject() {
		return false;
	}

	@read
	public boolean isInstrument() {
		return gameObjectType == SceneObjectType.INSTRUMENT;
	}

	@read
	public boolean isBazaarTerminal() {
		return gameObjectType == SceneObjectType.BAZAAR;
	}

	@read
	public boolean isLiveSample() {
		return gameObjectType == SceneObjectType.LIVESAMPLE;
	}

	@dirty
	public abstract boolean isInstallationObject() {
		return false;
	}

	@dirty
	public abstract boolean isHarvesterObject() {
		return false;
	}

	@dirty
	public abstract boolean isGeneratorObject() {
		return false;
	}

	@dirty
	public abstract boolean isCityTerminal() {
		return false;
	}

	@dirty
	public abstract boolean isCityVoteTerminal() {
		return false;
	}

	@dirty
	public abstract boolean isFactory() {
		return false;
	}

	@dirty
	public abstract boolean isFactoryCrate() {
		return false;
	}

	@dirty
	public abstract boolean isPharmaceuticalObject() {
		return false;
	}

	@read
	public boolean isFishingPoleObject() {
		return gameObjectType == SceneObjectType.FISHINGPOLE;
	}

	@dirty
	public abstract boolean isDeedObject() {
		return false;
	}

	@dirty
	public abstract boolean isVehicleDeedObject() {
		return false;
	}

	@dirty
	public abstract boolean isDroidDeedObject() {
		return false;
	}

	@dirty
	public abstract boolean isBuildingDeed() {
		return false;
	}

	@dirty
	public abstract boolean isSignObject() {
		return false;
	}

	@dirty
	public abstract boolean isInstallationDeed() {
		return false;
	}

	@dirty
	public abstract boolean isCraftingTool() {
		return false;
	}

	@dirty
	public abstract boolean isCraftingStation() {
		return false;
	}

	@dirty
	public abstract boolean isManufactureSchematic() {
		return false;
	}

	@dirty
	public abstract boolean isStructureObject() {
		return false;
	}

	@dirty
	public abstract boolean isAuctionObject() {
		return false;
	}

	@read
	public boolean isFishingBait() {
		return gameObjectType == SceneObjectType.FISHINGBAIT;
	}

	@read
	public boolean isTrapObject() {
		return gameObjectType == SceneObjectType.TRAP;
	}

	@read
	public boolean isRepairTool() {
		return gameObjectType == SceneObjectType.REPAIRTOOL;
	}

	@dirty
	public boolean isCamoKit() {
		return templateObject.isCamoKitTemplate();
	}

	@dirty
	public abstract boolean isAttachment() {
		return false;
	}

	@dirty
	public boolean isDiceObject() {
		return templateObject.isDiceTemplate();
	}

	@dirty
	public boolean isCreatureHabitat() {
		return templateObject.isCreatureHabitatTemplate();
	}

	@read
	public boolean isCampKit() {
		return gameObjectType == SceneObjectType.CAMPKIT;
	}

	@dirty
	public abstract boolean isCampStructure() {
		return false;
	}

	@dirty
	public abstract boolean isRecycleToolObject() {
		return gameObjectType == SceneObjectType.RECYCLETOOL;
	}

	@dirty
	public abstract boolean isAntiDecayKitObject() {
		return gameObjectType == SceneObjectType.ANTIDECAYKIT;
	}

	@local
	public ContainerPermissions getContainerPermissions() {
		return containerPermissions;
	}

	@preLocked
	public void setContainerDefaultAllowPermission(unsigned short perm) {
		containerPermissions.setDefaultAllowPermission(perm);
	}

	@preLocked
	public void clearContainerDefaultAllowPermission(unsigned short perm) {
		containerPermissions.clearDefaultAllowPermission(perm);
	}

	@preLocked
	public void setContainerDefaultDenyPermission(unsigned short perm) {
		containerPermissions.setDefaultDenyPermission(perm);
	}

	@preLocked
	public void clearContainerDefaultDenyPermission(unsigned short perm) {
		containerPermissions.clearDefaultDenyPermission(perm);
	}

	@preLocked
	public void setContainerInheritPermissionsFromParent(boolean val) {
		containerPermissions.setInheritPermissionsFromParent(val);
	}

	@preLocked
	public void setContainerOwnerID(unsigned long id) {
		containerPermissions.setOwner(id);
	}

	@preLocked
	public void setContainerAllowPermission(final string group, unsigned short perm) {
		containerPermissions.setAllowPermission(group, perm);
	}

	@preLocked
	public void setContainerDenyPermission(final string group, unsigned short perm) {
		containerPermissions.setDenyPermission(group, perm);
	}

	public void setGameObjectType(unsigned int type) {
		gameObjectType = type;
	}

	public void setClientObjectCRC(unsigned int objCRC) {
		clientObjectCRC = objCRC;
	}

	public void setServerObjectCRC(unsigned int objCRC) {
		serverObjectCRC = objCRC;
	}

	@local
	public void setZoneProcessServer(ZoneProcessServer srv) {
		server = srv;
	}

	@local
	public ZoneProcessServer getZoneProcessServer() {
		return server;
	}

	public abstract native void setZone(Zone zone);

	@local
	public abstract native void setObjectName(@dereferenced StringId stringID, boolean notifyClient);

	public void setDirection(float fw, float fx, float fy, float fz) {
		direction.set(fw, fx, fy, fz);
	}

	public void setDirection(float headingAngleRadians) {
		direction.setHeadingDirection(headingAngleRadians);
	}

	@local
	public native void setDirection(@dereferenced final Quaternion dir);

	public void setMovementCounter(unsigned int count) {
		movementCounter = count;
	}

	public void incrementMovementCounter() {
		movementCounter++;
	}

	public void setContainmentType(unsigned int type) {
		containmentType = type;
	}

	public void setLoggingName(final string name) {
		Logger.setLoggingName(name);
	}

	public void setClientObject(boolean val) {
		staticObject = val;
	}

	@dirty
	public abstract native unsigned int getPlanetCRC();

	@read
	public boolean isClientObject() {
		return staticObject;
	}

	@dirty
	public abstract boolean isStaticObjectClass() { // TODO: Change this to only be isStaticObject
	    return false;
	}

	@dirty
	@local
	public abstract StaticObject asStaticObject() {
		return null;
	}

	@dirty
	public abstract boolean isContainerObject() {
		return false;
	}

	@dirty
	public abstract boolean isTerminal() {
		return false;
	}

	@dirty
	public abstract boolean isGroupObject() {
		return false;
	}

	@dirty
	public abstract boolean isGuildObject() {
		return false;
	}

	@dirty
	public abstract boolean isControlDevice() {
		return false;
	}

	@dirty
	public abstract boolean isPetControlDevice() {
		return false;
	}

	@dirty
	public abstract boolean isVehicleControlDevice() {
		return false;
	}

	@dirty
	public abstract boolean isShipControlDevice() {
		return false;
	}

	@dirty
	public abstract boolean isMissionTerminal() {
		return false;
	}

	@dirty
	public abstract boolean isMissionObject() {
		return false;
	}

	@dirty
	public abstract boolean isActorObject() {
		return false;
	}

	@read
	public int getPlanetMapCategoryCRC() {
		return planetMapCategory;
	}

	@read
	public int getPlanetMapSubCategoryCRC() {
		return planetMapSubCategory;
	}

	@local
	public void setPlanetMapCategory(PlanetMapCategory pmc) {
		if (pmc == null)
			planetMapCategory = 0;
		else
			planetMapCategory = pmc.getCrc();
	}

	@local
	public void setPlanetMapSubCategory(PlanetMapCategory pmc)  {
		planetMapSubCategory = pmc.getCrc();
	}

	@local
	@read
	public PlanetMapCategory getPlanetMapCategory() {
		TemplateManager templateManager = TemplateManager.instance();
		return templateManager.getPlanetMapCategoryByCrc(planetMapCategory);
	}

	@local
	@read
	public PlanetMapCategory getPlanetMapSubCategory() {
		TemplateManager templateManager = TemplateManager.instance();
		return templateManager.getPlanetMapCategoryByCrc(planetMapSubCategory);
	}

	@local
	@dirty
	public SortedVector<SceneObject> getChildObjects() {
		return childObjects;
	}

	@read
	public boolean containsChildObject(SceneObject obj) {
		return childObjects.contains(obj);
	}

	@local
	@read
	public SharedObjectTemplate getObjectTemplate() {
		return templateObject;
	}

	/**
	 * The returning value points directly to the internal vector, do not delete it or store it
	 */
	@local
	@dereferenced
	public native SortedVector<Observer> getObservers(unsigned int eventType);

	@preLocked
	public native abstract void createChildObjects();

	@preLocked
	public native void destroyChildObjects();

	public void addChildObject(SceneObject obj) {
		childObjects.put(obj);
	}

	@local
	@dirty
	public Matrix4 getTransformForCollisionMatrix() {
		return transformForCollisionMatrix;
	}

	@local
	public native boolean setTransformForCollisionMatrixIfNull(Matrix4 mat);

	/**
	 * This method initializes "this" object as if it were a "childObject" of the controller object that is passed
	 * as an argument to the method.
	 * NOTE: The controllerObject is not necessarily the "parent" of the child object. The childObject just happens
	 * to be specified in the controllerObject's childObjects vector.
	 * @param controllerObject The object that has this object specified as a "childObject".
	 */
	public native abstract void initializeChildObject(SceneObject controllerObject);

	@dirty
	public native boolean isInWater();

	@dirty
	public native boolean containsNoTradeObjectRecursive();

	@dirty
	public native string getDisplayedName();

	@ready
	public boolean doSendToClient() {
		return sendToClient;
	}

	public void setSendToClient(boolean val) {
		sendToClient = val;
	}

	@dirty
	public abstract boolean isPet() {
		return false;
	}

	@dirty
	public abstract boolean isMount() {
		return false;
	}

	@dirty
	public abstract boolean isLairObject() {
		return false;
	}

	@dirty
	public abstract boolean isPoiBuilding() {
		return false;
	}

	@dirty
	public abstract boolean isTheaterObject() {
		return false;
	}

	@dirty
	public abstract boolean isEventPerkDeed() {
		return false;
	}

	@dirty
	public abstract boolean isEventPerkItem() {
		return false;
	}

	@dirty
	public native boolean isDataPad();

	public native abstract float getTemplateRadius();

	@local
	@dereferenced
	public abstract native Vector<Reference<MeshData> > getTransformedMeshData(final Matrix4 parentTransform);

	@dirty
	@local
	public abstract native final BaseBoundingVolume getBoundingVolume();

	@dirty
	public abstract native boolean isInNavMesh();
}

