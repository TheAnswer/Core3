/*
 *	server/zone/objects/tangible/weapon/WeaponObject.cpp generated by engine3 IDL compiler 0.60
 */

#include "WeaponObject.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

#include "server/zone/Zone.h"

#include "server/zone/templates/SharedObjectTemplate.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

#include "server/zone/objects/tangible/powerup/PowerupObject.h"

/*
 *	WeaponObjectStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_SENDCONTAINERTO__CREATUREOBJECT_,RPC_CREATECHILDOBJECTS__,RPC_ISCERTIFIEDFOR__CREATUREOBJECT_,RPC_SETCERTIFIED__BOOL_,RPC_GETATTACKTYPE__,RPC_SETATTACKTYPE__INT_,RPC_ISCERTIFIED__,RPC_GETPOINTBLANKACCURACY__BOOL_,RPC_SETPOINTBLANKACCURACY__INT_,RPC_GETPOINTBLANKRANGE__BOOL_,RPC_GETIDEALRANGE__BOOL_,RPC_SETIDEALRANGE__INT_,RPC_GETMAXRANGE__BOOL_,RPC_SETMAXRANGE__INT_,RPC_GETIDEALACCURACY__BOOL_,RPC_SETIDEALACCURACY__INT_,RPC_GETARMORPIERCING__,RPC_GETMAXRANGEACCURACY__BOOL_,RPC_SETMAXRANGEACCURACY__INT_,RPC_GETATTACKSPEED__BOOL_,RPC_SETATTACKSPEED__FLOAT_,RPC_GETMAXDAMAGE__BOOL_,RPC_SETMAXDAMAGE__FLOAT_,RPC_GETMINDAMAGE__BOOL_,RPC_SETMINDAMAGE__FLOAT_,RPC_GETWOUNDSRATIO__BOOL_,RPC_SETWOUNDSRATIO__FLOAT_,RPC_GETDAMAGERADIUS__BOOL_,RPC_SETDAMAGERADIUS__FLOAT_,RPC_GETHEALTHATTACKCOST__BOOL_,RPC_SETHEALTHATTACKCOST__INT_,RPC_GETACTIONATTACKCOST__BOOL_,RPC_SETACTIONATTACKCOST__INT_,RPC_GETMINDATTACKCOST__BOOL_,RPC_SETMINDATTACKCOST__INT_,RPC_GETFORCECOST__,RPC_SETFORCECOST__INT_,RPC_GETBLADECOLOR__,RPC_SETBLADECOLOR__INT_,RPC_GETDAMAGETYPE__,RPC_GETXPTYPE__,RPC_GETDOTTYPE__,RPC_GETDOTATTRIBUTE__,RPC_GETDOTSTRENGTH__,RPC_GETDOTDURATION__,RPC_GETDOTPOTENCY__,RPC_GETDOTUSES__,RPC_SETDOTTYPE__INT_,RPC_SETDOTATTRIBUTE__INT_,RPC_SETDOTSTRENGTH__INT_,RPC_SETDOTDURATION__INT_,RPC_SETDOTPOTENCY__INT_,RPC_SETDOTUSES__INT_,RPC_GETWEAPONTYPE__,RPC_ISUNARMEDWEAPON__,RPC_ISMELEEWEAPON__,RPC_ISRANGEDWEAPON__,RPC_ISRIFLEWEAPON__,RPC_ISTHROWNWEAPON__,RPC_ISHEAVYWEAPON__,RPC_ISSPECIALHEAVYWEAPON__,RPC_ISLIGHTNINGRIFLE__,RPC_ISFLAMETHROWER__,RPC_ISHEAVYACIDRIFLE__,RPC_ISCARBINEWEAPON__,RPC_ISPISTOLWEAPON__,RPC_ISONEHANDMELEEWEAPON__,RPC_ISPOLEARMWEAPONOBJECT__,RPC_ISTWOHANDMELEEWEAPON__,RPC_ISMINEWEAPON__,RPC_ISJEDIWEAPON__,RPC_ISJEDIONEHANDEDWEAPON__,RPC_ISJEDITWOHANDEDWEAPON__,RPC_ISJEDIPOLEARMWEAPON__,RPC_ISWEAPONOBJECT__,RPC_HASPOWERUP__,RPC_APPLYPOWERUP__CREATUREOBJECT_POWERUPOBJECT_,RPC_REMOVEPOWERUP__,RPC_DECREASEPOWERUPUSES__CREATUREOBJECT_,RPC_REPAIRATTEMPT__INT_,RPC_DECAY__CREATUREOBJECT_FLOAT_,RPC_SETDAMAGESLICE__FLOAT_,RPC_SETSPEEDSLICE__FLOAT_,RPC_APPLYSKILLMODSTO__CREATUREOBJECT_BOOL_,RPC_REMOVESKILLMODSFROM__CREATUREOBJECT_,RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_};

WeaponObject::WeaponObject() : TangibleObject(DummyConstructorParameter::instance()) {
	WeaponObjectImplementation* _implementation = new WeaponObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("WeaponObject");
}

WeaponObject::WeaponObject(DummyConstructorParameter* param) : TangibleObject(param) {
	_setClassName("WeaponObject");
}

WeaponObject::~WeaponObject() {
}



void WeaponObject::loadTemplateData(SharedObjectTemplate* templateData) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->loadTemplateData(templateData);
}

void WeaponObject::initializeTransientMembers() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeTransientMembers();
}

void WeaponObject::sendBaselinesTo(SceneObject* player) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendBaselinesTo(player);
}

void WeaponObject::sendContainerTo(CreatureObject* player) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCONTAINERTO__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendContainerTo(player);
}

void WeaponObject::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->fillAttributeList(msg, object);
}

void WeaponObject::updateCraftingValues(CraftingValues* values, bool firstUpdate) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->updateCraftingValues(values, firstUpdate);
}

void WeaponObject::createChildObjects() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATECHILDOBJECTS__);

		method.executeWithVoidReturn();
	} else
		_implementation->createChildObjects();
}

bool WeaponObject::isCertifiedFor(CreatureObject* object) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCERTIFIEDFOR__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCertifiedFor(object);
}

Vector<String>* WeaponObject::getDamageModifiers() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getDamageModifiers();
}

Vector<String>* WeaponObject::getSpeedModifiers() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getSpeedModifiers();
}

Vector<String>* WeaponObject::getCreatureAccuracyModifiers() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getCreatureAccuracyModifiers();
}

Vector<String>* WeaponObject::getCreatureAimModifiers() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getCreatureAimModifiers();
}

Vector<String>* WeaponObject::getDefenderDefenseModifiers() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getDefenderDefenseModifiers();
}

Vector<String>* WeaponObject::getDefenderSecondaryDefenseModifiers() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getDefenderSecondaryDefenseModifiers();
}

Vector<String>* WeaponObject::getDefenderToughnessModifiers() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getDefenderToughnessModifiers();
}

void WeaponObject::setCertified(bool cert) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCERTIFIED__BOOL_);
		method.addBooleanParameter(cert);

		method.executeWithVoidReturn();
	} else
		_implementation->setCertified(cert);
}

int WeaponObject::getAttackType() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTACKTYPE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getAttackType();
}

void WeaponObject::setAttackType(int a) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETATTACKTYPE__INT_);
		method.addSignedIntParameter(a);

		method.executeWithVoidReturn();
	} else
		_implementation->setAttackType(a);
}

bool WeaponObject::isCertified() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCERTIFIED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCertified();
}

int WeaponObject::getPointBlankAccuracy(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPOINTBLANKACCURACY__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getPointBlankAccuracy(withPup);
}

void WeaponObject::setPointBlankAccuracy(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPOINTBLANKACCURACY__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setPointBlankAccuracy(value);
}

int WeaponObject::getPointBlankRange(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPOINTBLANKRANGE__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getPointBlankRange(withPup);
}

int WeaponObject::getIdealRange(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETIDEALRANGE__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getIdealRange(withPup);
}

void WeaponObject::setIdealRange(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETIDEALRANGE__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setIdealRange(value);
}

int WeaponObject::getMaxRange(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXRANGE__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getMaxRange(withPup);
}

void WeaponObject::setMaxRange(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXRANGE__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setMaxRange(value);
}

int WeaponObject::getIdealAccuracy(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETIDEALACCURACY__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getIdealAccuracy(withPup);
}

void WeaponObject::setIdealAccuracy(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETIDEALACCURACY__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setIdealAccuracy(value);
}

int WeaponObject::getArmorPiercing() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETARMORPIERCING__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getArmorPiercing();
}

int WeaponObject::getMaxRangeAccuracy(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXRANGEACCURACY__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getMaxRangeAccuracy(withPup);
}

void WeaponObject::setMaxRangeAccuracy(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXRANGEACCURACY__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setMaxRangeAccuracy(value);
}

float WeaponObject::getAttackSpeed(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTACKSPEED__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getAttackSpeed(withPup);
}

void WeaponObject::setAttackSpeed(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETATTACKSPEED__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setAttackSpeed(value);
}

float WeaponObject::getMaxDamage(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXDAMAGE__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getMaxDamage(withPup);
}

void WeaponObject::setMaxDamage(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXDAMAGE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setMaxDamage(value);
}

float WeaponObject::getMinDamage(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINDAMAGE__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getMinDamage(withPup);
}

void WeaponObject::setMinDamage(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMINDAMAGE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setMinDamage(value);
}

float WeaponObject::getWoundsRatio(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWOUNDSRATIO__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getWoundsRatio(withPup);
}

void WeaponObject::setWoundsRatio(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWOUNDSRATIO__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setWoundsRatio(value);
}

float WeaponObject::getDamageRadius(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDAMAGERADIUS__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getDamageRadius(withPup);
}

void WeaponObject::setDamageRadius(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDAMAGERADIUS__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setDamageRadius(value);
}

int WeaponObject::getHealthAttackCost(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEALTHATTACKCOST__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getHealthAttackCost(withPup);
}

void WeaponObject::setHealthAttackCost(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHEALTHATTACKCOST__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setHealthAttackCost(value);
}

int WeaponObject::getActionAttackCost(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTIONATTACKCOST__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getActionAttackCost(withPup);
}

void WeaponObject::setActionAttackCost(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACTIONATTACKCOST__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setActionAttackCost(value);
}

int WeaponObject::getMindAttackCost(bool withPup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINDATTACKCOST__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getMindAttackCost(withPup);
}

void WeaponObject::setMindAttackCost(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMINDATTACKCOST__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setMindAttackCost(value);
}

int WeaponObject::getForceCost() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORCECOST__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getForceCost();
}

void WeaponObject::setForceCost(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFORCECOST__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setForceCost(value);
}

int WeaponObject::getBladeColor() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBLADECOLOR__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getBladeColor();
}

void WeaponObject::setBladeColor(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBLADECOLOR__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setBladeColor(value);
}

int WeaponObject::getDamageType() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDAMAGETYPE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDamageType();
}

String WeaponObject::getXpType() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETXPTYPE__);

		String _return_getXpType;
		method.executeWithAsciiReturn(_return_getXpType);
		return _return_getXpType;
	} else
		return _implementation->getXpType();
}

int WeaponObject::getDotType() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTTYPE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDotType();
}

int WeaponObject::getDotAttribute() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTATTRIBUTE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDotAttribute();
}

int WeaponObject::getDotStrength() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTSTRENGTH__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDotStrength();
}

int WeaponObject::getDotDuration() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTDURATION__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDotDuration();
}

int WeaponObject::getDotPotency() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTPOTENCY__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDotPotency();
}

int WeaponObject::getDotUses() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTUSES__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDotUses();
}

void WeaponObject::setDotType(int t) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDOTTYPE__INT_);
		method.addSignedIntParameter(t);

		method.executeWithVoidReturn();
	} else
		_implementation->setDotType(t);
}

void WeaponObject::setDotAttribute(int a) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDOTATTRIBUTE__INT_);
		method.addSignedIntParameter(a);

		method.executeWithVoidReturn();
	} else
		_implementation->setDotAttribute(a);
}

void WeaponObject::setDotStrength(int s) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDOTSTRENGTH__INT_);
		method.addSignedIntParameter(s);

		method.executeWithVoidReturn();
	} else
		_implementation->setDotStrength(s);
}

void WeaponObject::setDotDuration(int du) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDOTDURATION__INT_);
		method.addSignedIntParameter(du);

		method.executeWithVoidReturn();
	} else
		_implementation->setDotDuration(du);
}

void WeaponObject::setDotPotency(int po) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDOTPOTENCY__INT_);
		method.addSignedIntParameter(po);

		method.executeWithVoidReturn();
	} else
		_implementation->setDotPotency(po);
}

void WeaponObject::setDotUses(int u) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDOTUSES__INT_);
		method.addSignedIntParameter(u);

		method.executeWithVoidReturn();
	} else
		_implementation->setDotUses(u);
}

String WeaponObject::getWeaponType() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWEAPONTYPE__);

		String _return_getWeaponType;
		method.executeWithAsciiReturn(_return_getWeaponType);
		return _return_getWeaponType;
	} else
		return _implementation->getWeaponType();
}

bool WeaponObject::isUnarmedWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISUNARMEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isUnarmedWeapon();
}

bool WeaponObject::isMeleeWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMELEEWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isMeleeWeapon();
}

bool WeaponObject::isRangedWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRANGEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRangedWeapon();
}

bool WeaponObject::isRifleWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRIFLEWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRifleWeapon();
}

bool WeaponObject::isThrownWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTHROWNWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isThrownWeapon();
}

bool WeaponObject::isHeavyWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHEAVYWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isHeavyWeapon();
}

bool WeaponObject::isSpecialHeavyWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSPECIALHEAVYWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isSpecialHeavyWeapon();
}

bool WeaponObject::isLightningRifle() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLIGHTNINGRIFLE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLightningRifle();
}

bool WeaponObject::isFlameThrower() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFLAMETHROWER__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isFlameThrower();
}

bool WeaponObject::isHeavyAcidRifle() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHEAVYACIDRIFLE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isHeavyAcidRifle();
}

bool WeaponObject::isCarbineWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCARBINEWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCarbineWeapon();
}

bool WeaponObject::isPistolWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPISTOLWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPistolWeapon();
}

bool WeaponObject::isOneHandMeleeWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONEHANDMELEEWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOneHandMeleeWeapon();
}

bool WeaponObject::isPolearmWeaponObject() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPOLEARMWEAPONOBJECT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPolearmWeaponObject();
}

bool WeaponObject::isTwoHandMeleeWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTWOHANDMELEEWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isTwoHandMeleeWeapon();
}

bool WeaponObject::isMineWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMINEWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isMineWeapon();
}

bool WeaponObject::isJediWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDIWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isJediWeapon();
}

bool WeaponObject::isJediOneHandedWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDIONEHANDEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isJediOneHandedWeapon();
}

bool WeaponObject::isJediTwoHandedWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDITWOHANDEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isJediTwoHandedWeapon();
}

bool WeaponObject::isJediPolearmWeapon() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDIPOLEARMWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isJediPolearmWeapon();
}

bool WeaponObject::isWeaponObject() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISWEAPONOBJECT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isWeaponObject();
}

bool WeaponObject::hasPowerup() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASPOWERUP__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasPowerup();
}

void WeaponObject::applyPowerup(CreatureObject* player, PowerupObject* pup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_APPLYPOWERUP__CREATUREOBJECT_POWERUPOBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(pup);

		method.executeWithVoidReturn();
	} else
		_implementation->applyPowerup(player, pup);
}

PowerupObject* WeaponObject::removePowerup() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEPOWERUP__);

		return static_cast<PowerupObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->removePowerup();
}

void WeaponObject::decreasePowerupUses(CreatureObject* player) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECREASEPOWERUPUSES__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->decreasePowerupUses(player);
}

String WeaponObject::repairAttempt(int repairChance) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REPAIRATTEMPT__INT_);
		method.addSignedIntParameter(repairChance);

		String _return_repairAttempt;
		method.executeWithAsciiReturn(_return_repairAttempt);
		return _return_repairAttempt;
	} else
		return _implementation->repairAttempt(repairChance);
}

void WeaponObject::decay(CreatureObject* user, float damage) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECAY__CREATUREOBJECT_FLOAT_);
		method.addObjectParameter(user);
		method.addFloatParameter(damage);

		method.executeWithVoidReturn();
	} else
		_implementation->decay(user, damage);
}

void WeaponObject::setDamageSlice(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDAMAGESLICE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setDamageSlice(value);
}

void WeaponObject::setSpeedSlice(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPEEDSLICE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setSpeedSlice(value);
}

void WeaponObject::applySkillModsTo(CreatureObject* creature, bool doCheck) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_APPLYSKILLMODSTO__CREATUREOBJECT_BOOL_);
		method.addObjectParameter(creature);
		method.addBooleanParameter(doCheck);

		method.executeWithVoidReturn();
	} else
		_implementation->applySkillModsTo(creature, doCheck);
}

void WeaponObject::removeSkillModsFrom(CreatureObject* creature) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESKILLMODSFROM__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		_implementation->removeSkillModsFrom(creature);
}

void WeaponObject::addSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_);
		method.addSignedIntParameter(skillType);
		method.addAsciiParameter(skillMod);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addSkillMod(skillType, skillMod, value, notifyClient);
}

DistributedObjectServant* WeaponObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* WeaponObject::_getImplementationForRead() {
	return _impl;
}

void WeaponObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	WeaponObjectImplementation
 */

WeaponObjectImplementation::WeaponObjectImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}


WeaponObjectImplementation::~WeaponObjectImplementation() {
}


void WeaponObjectImplementation::finalize() {
}

void WeaponObjectImplementation::_initializeImplementation() {
	_setClassHelper(WeaponObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void WeaponObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<WeaponObject*>(stub);
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* WeaponObjectImplementation::_getStub() {
	return _this.get();
}

WeaponObjectImplementation::operator const WeaponObject*() {
	return _this.get();
}

void WeaponObjectImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void WeaponObjectImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void WeaponObjectImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void WeaponObjectImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void WeaponObjectImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void WeaponObjectImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void WeaponObjectImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void WeaponObjectImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("WeaponObject");

}

void WeaponObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(WeaponObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool WeaponObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xaf7c0a4b: //WeaponObject.attackType
		TypeInfo<int >::parseFromBinaryStream(&attackType, stream);
		return true;

	case 0xce821459: //WeaponObject.weaponEffect
		TypeInfo<String >::parseFromBinaryStream(&weaponEffect, stream);
		return true;

	case 0x3f0d10bc: //WeaponObject.weaponEffectIndex
		TypeInfo<int >::parseFromBinaryStream(&weaponEffectIndex, stream);
		return true;

	case 0x3115d69d: //WeaponObject.certified
		TypeInfo<bool >::parseFromBinaryStream(&certified, stream);
		return true;

	case 0x6b12d54f: //WeaponObject.armorPiercing
		TypeInfo<int >::parseFromBinaryStream(&armorPiercing, stream);
		return true;

	case 0x152e5f75: //WeaponObject.pointBlankAccuracy
		TypeInfo<int >::parseFromBinaryStream(&pointBlankAccuracy, stream);
		return true;

	case 0x670ae4ff: //WeaponObject.pointBlankRange
		TypeInfo<int >::parseFromBinaryStream(&pointBlankRange, stream);
		return true;

	case 0xc470ee9f: //WeaponObject.idealRange
		TypeInfo<int >::parseFromBinaryStream(&idealRange, stream);
		return true;

	case 0xd480b36e: //WeaponObject.idealAccuracy
		TypeInfo<int >::parseFromBinaryStream(&idealAccuracy, stream);
		return true;

	case 0x9890e346: //WeaponObject.maxRange
		TypeInfo<int >::parseFromBinaryStream(&maxRange, stream);
		return true;

	case 0x2613027b: //WeaponObject.maxRangeAccuracy
		TypeInfo<int >::parseFromBinaryStream(&maxRangeAccuracy, stream);
		return true;

	case 0xb67af664: //WeaponObject.damageType
		TypeInfo<int >::parseFromBinaryStream(&damageType, stream);
		return true;

	case 0x7e68aff1: //WeaponObject.attackSpeed
		TypeInfo<float >::parseFromBinaryStream(&attackSpeed, stream);
		return true;

	case 0x244a18e6: //WeaponObject.minDamage
		TypeInfo<float >::parseFromBinaryStream(&minDamage, stream);
		return true;

	case 0xb1865fc5: //WeaponObject.maxDamage
		TypeInfo<float >::parseFromBinaryStream(&maxDamage, stream);
		return true;

	case 0x80491112: //WeaponObject.damageRadius
		TypeInfo<float >::parseFromBinaryStream(&damageRadius, stream);
		return true;

	case 0xc038e1ce: //WeaponObject.woundsRatio
		TypeInfo<float >::parseFromBinaryStream(&woundsRatio, stream);
		return true;

	case 0x2b72cd02: //WeaponObject.healthAttackCost
		TypeInfo<int >::parseFromBinaryStream(&healthAttackCost, stream);
		return true;

	case 0x9957963b: //WeaponObject.actionAttackCost
		TypeInfo<int >::parseFromBinaryStream(&actionAttackCost, stream);
		return true;

	case 0x987636de: //WeaponObject.mindAttackCost
		TypeInfo<int >::parseFromBinaryStream(&mindAttackCost, stream);
		return true;

	case 0x42b7f5e: //WeaponObject.forceCost
		TypeInfo<int >::parseFromBinaryStream(&forceCost, stream);
		return true;

	case 0x2e53bceb: //WeaponObject.bladeColor
		TypeInfo<int >::parseFromBinaryStream(&bladeColor, stream);
		return true;

	case 0x39d8ea3d: //WeaponObject.powerupObject
		TypeInfo<ManagedReference<PowerupObject* > >::parseFromBinaryStream(&powerupObject, stream);
		return true;

	case 0x8cf72617: //WeaponObject.damageSlice
		TypeInfo<float >::parseFromBinaryStream(&damageSlice, stream);
		return true;

	case 0x949b206c: //WeaponObject.speedSlice
		TypeInfo<float >::parseFromBinaryStream(&speedSlice, stream);
		return true;

	case 0x40433917: //WeaponObject.dotType
		TypeInfo<int >::parseFromBinaryStream(&dotType, stream);
		return true;

	case 0x5662a29d: //WeaponObject.dotAttribute
		TypeInfo<int >::parseFromBinaryStream(&dotAttribute, stream);
		return true;

	case 0xe6ae6a5b: //WeaponObject.dotStrength
		TypeInfo<int >::parseFromBinaryStream(&dotStrength, stream);
		return true;

	case 0xe8f7f5b9: //WeaponObject.dotDuration
		TypeInfo<int >::parseFromBinaryStream(&dotDuration, stream);
		return true;

	case 0x8f640033: //WeaponObject.dotPotency
		TypeInfo<int >::parseFromBinaryStream(&dotPotency, stream);
		return true;

	case 0x40a17332: //WeaponObject.dotUses
		TypeInfo<int >::parseFromBinaryStream(&dotUses, stream);
		return true;

	case 0xdeec3bb7: //WeaponObject.wearableSkillMods
		TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&wearableSkillMods, stream);
		return true;

	}

	return false;
}

void WeaponObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = WeaponObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int WeaponObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xaf7c0a4b; //WeaponObject.attackType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&attackType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xce821459; //WeaponObject.weaponEffect
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&weaponEffect, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3f0d10bc; //WeaponObject.weaponEffectIndex
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&weaponEffectIndex, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3115d69d; //WeaponObject.certified
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&certified, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x6b12d54f; //WeaponObject.armorPiercing
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&armorPiercing, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x152e5f75; //WeaponObject.pointBlankAccuracy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&pointBlankAccuracy, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x670ae4ff; //WeaponObject.pointBlankRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&pointBlankRange, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc470ee9f; //WeaponObject.idealRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&idealRange, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd480b36e; //WeaponObject.idealAccuracy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&idealAccuracy, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x9890e346; //WeaponObject.maxRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxRange, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x2613027b; //WeaponObject.maxRangeAccuracy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxRangeAccuracy, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xb67af664; //WeaponObject.damageType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&damageType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x7e68aff1; //WeaponObject.attackSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&attackSpeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x244a18e6; //WeaponObject.minDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&minDamage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xb1865fc5; //WeaponObject.maxDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&maxDamage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x80491112; //WeaponObject.damageRadius
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&damageRadius, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc038e1ce; //WeaponObject.woundsRatio
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&woundsRatio, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x2b72cd02; //WeaponObject.healthAttackCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&healthAttackCost, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x9957963b; //WeaponObject.actionAttackCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&actionAttackCost, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x987636de; //WeaponObject.mindAttackCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&mindAttackCost, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x42b7f5e; //WeaponObject.forceCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&forceCost, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x2e53bceb; //WeaponObject.bladeColor
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&bladeColor, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x39d8ea3d; //WeaponObject.powerupObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<PowerupObject* > >::toBinaryStream(&powerupObject, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x8cf72617; //WeaponObject.damageSlice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&damageSlice, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x949b206c; //WeaponObject.speedSlice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&speedSlice, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x40433917; //WeaponObject.dotType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&dotType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x5662a29d; //WeaponObject.dotAttribute
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&dotAttribute, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe6ae6a5b; //WeaponObject.dotStrength
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&dotStrength, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe8f7f5b9; //WeaponObject.dotDuration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&dotDuration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x8f640033; //WeaponObject.dotPotency
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&dotPotency, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x40a17332; //WeaponObject.dotUses
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&dotUses, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xdeec3bb7; //WeaponObject.wearableSkillMods
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&wearableSkillMods, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 32;
}

WeaponObjectImplementation::WeaponObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		certified = false;
	certified = false;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		armorPiercing = 0;
	armorPiercing = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		healthAttackCost = 0;
	healthAttackCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		actionAttackCost = 0;
	actionAttackCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		mindAttackCost = 0;
	mindAttackCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		forceCost = 0;
	forceCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		pointBlankAccuracy = 0;
	pointBlankAccuracy = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		pointBlankRange = 0;
	pointBlankRange = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealRange = 0;
	idealRange = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealAccuracy = 0;
	idealAccuracy = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRange = 5;
	maxRange = 5;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRangeAccuracy = 0;
	maxRangeAccuracy = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageType = 0;
	damageType = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		minDamage = 1;
	minDamage = 1;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxDamage = 10;
	maxDamage = 10;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		woundsRatio = 0;
	woundsRatio = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageRadius = 0;
	damageRadius = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		attackSpeed = 1;
	attackSpeed = 1;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		weaponTemplate = null;
	weaponTemplate = NULL;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotType = 0;
	dotType = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotAttribute = 0;
	dotAttribute = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotStrength = 0;
	dotStrength = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotDuration = 0;
	dotDuration = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotPotency = 0;
	dotPotency = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotUses = 0;
	dotUses = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		Logger.setLoggingName("WeaponObject");
	Logger::setLoggingName("WeaponObject");
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageSlice = 1;
	damageSlice = 1;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		speedSlice = 1;
	speedSlice = 1;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		wearableSkillMods.setAllowOverwriteInsertPlan();
	(&wearableSkillMods)->setAllowOverwriteInsertPlan();
}

Vector<String>* WeaponObjectImplementation::getDamageModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getDamageModifiers();
	return weaponTemplate->getDamageModifiers();
}

Vector<String>* WeaponObjectImplementation::getSpeedModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getSpeedModifiers();
	return weaponTemplate->getSpeedModifiers();
}

Vector<String>* WeaponObjectImplementation::getCreatureAccuracyModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getCreatureAccuracyModifiers();
	return weaponTemplate->getCreatureAccuracyModifiers();
}

Vector<String>* WeaponObjectImplementation::getCreatureAimModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getCreatureAimModifiers();
	return weaponTemplate->getCreatureAimModifiers();
}

Vector<String>* WeaponObjectImplementation::getDefenderDefenseModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getDefenderDefenseModifiers();
	return weaponTemplate->getDefenderDefenseModifiers();
}

Vector<String>* WeaponObjectImplementation::getDefenderSecondaryDefenseModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getDefenderSecondaryDefenseModifiers();
	return weaponTemplate->getDefenderSecondaryDefenseModifiers();
}

Vector<String>* WeaponObjectImplementation::getDefenderToughnessModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getDefenderToughnessModifiers();
	return weaponTemplate->getDefenderToughnessModifiers();
}

void WeaponObjectImplementation::setCertified(bool cert) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		certified = cert;
	certified = cert;
}

int WeaponObjectImplementation::getAttackType() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return attackType;
	return attackType;
}

void WeaponObjectImplementation::setAttackType(int a) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		attackType = a;
	attackType = a;
}

bool WeaponObjectImplementation::isCertified() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return certified;
	return certified;
}

void WeaponObjectImplementation::setPointBlankAccuracy(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		pointBlankAccuracy = value;
	pointBlankAccuracy = value;
}

void WeaponObjectImplementation::setIdealRange(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealRange = value;
	idealRange = value;
}

void WeaponObjectImplementation::setMaxRange(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRange = value;
	maxRange = value;
}

void WeaponObjectImplementation::setIdealAccuracy(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealAccuracy = value;
	idealAccuracy = value;
}

int WeaponObjectImplementation::getArmorPiercing() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return armorPiercing;
	return armorPiercing;
}

void WeaponObjectImplementation::setMaxRangeAccuracy(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRangeAccuracy = value;
	maxRangeAccuracy = value;
}

void WeaponObjectImplementation::setAttackSpeed(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		attackSpeed = value;
	attackSpeed = value;
}

void WeaponObjectImplementation::setMaxDamage(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxDamage = value;
	maxDamage = value;
}

void WeaponObjectImplementation::setMinDamage(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		minDamage = value;
	minDamage = value;
}

void WeaponObjectImplementation::setWoundsRatio(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		woundsRatio = value;
	woundsRatio = value;
}

void WeaponObjectImplementation::setDamageRadius(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageRadius = value;
	damageRadius = value;
}

void WeaponObjectImplementation::setHealthAttackCost(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		healthAttackCost = value;
	healthAttackCost = value;
}

void WeaponObjectImplementation::setActionAttackCost(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		actionAttackCost = value;
	actionAttackCost = value;
}

void WeaponObjectImplementation::setMindAttackCost(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		mindAttackCost = value;
	mindAttackCost = value;
}

int WeaponObjectImplementation::getForceCost() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return forceCost;
	return forceCost;
}

void WeaponObjectImplementation::setForceCost(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		forceCost = value;
	forceCost = value;
}

int WeaponObjectImplementation::getBladeColor() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return bladeColor;
	return bladeColor;
}

void WeaponObjectImplementation::setBladeColor(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		bladeColor = value;
	bladeColor = value;
}

int WeaponObjectImplementation::getDamageType() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return damageType;
	return damageType;
}

String WeaponObjectImplementation::getXpType() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getXpType();
	return weaponTemplate->getXpType();
}

int WeaponObjectImplementation::getDotType() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotType;
	return dotType;
}

int WeaponObjectImplementation::getDotAttribute() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotAttribute;
	return dotAttribute;
}

int WeaponObjectImplementation::getDotStrength() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotStrength;
	return dotStrength;
}

int WeaponObjectImplementation::getDotDuration() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotDuration;
	return dotDuration;
}

int WeaponObjectImplementation::getDotPotency() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotPotency;
	return dotPotency;
}

int WeaponObjectImplementation::getDotUses() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotUses;
	return dotUses;
}

void WeaponObjectImplementation::setDotType(int t) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotType = t;
	dotType = t;
}

void WeaponObjectImplementation::setDotAttribute(int a) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotAttribute = a;
	dotAttribute = a;
}

void WeaponObjectImplementation::setDotStrength(int s) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotStrength = s;
	dotStrength = s;
}

void WeaponObjectImplementation::setDotDuration(int du) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotDuration = du;
	dotDuration = du;
}

void WeaponObjectImplementation::setDotPotency(int po) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotPotency = po;
	dotPotency = po;
}

void WeaponObjectImplementation::setDotUses(int u) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotUses = u;
	dotUses = u;
}

bool WeaponObjectImplementation::isUnarmedWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.WEAPON || super.gameObjectType == SceneObjectType.MELEEWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::WEAPON || TangibleObjectImplementation::gameObjectType == SceneObjectType::MELEEWEAPON;
}

bool WeaponObjectImplementation::isMeleeWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return attackType == MELEEATTACK;
	return attackType == MELEEATTACK;
}

bool WeaponObjectImplementation::isRangedWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return attackType == RANGEDATTACK;
	return attackType == RANGEDATTACK;
}

bool WeaponObjectImplementation::isRifleWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.RIFLE;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::RIFLE;
}

bool WeaponObjectImplementation::isThrownWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.THROWNWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::THROWNWEAPON;
}

bool WeaponObjectImplementation::isHeavyWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.HEAVYWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::HEAVYWEAPON;
}

bool WeaponObjectImplementation::isSpecialHeavyWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.SPECIALHEAVYWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::SPECIALHEAVYWEAPON;
}

bool WeaponObjectImplementation::isLightningRifle() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getServerObjectCRC() == 397924793;
	return weaponTemplate->getServerObjectCRC() == 397924793;
}

bool WeaponObjectImplementation::isFlameThrower() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.isDerivedFrom("object/weapon/ranged/rifle/rifle_flame_thrower.iff");
	return weaponTemplate->isDerivedFrom("object/weapon/ranged/rifle/rifle_flame_thrower.iff");
}

bool WeaponObjectImplementation::isHeavyAcidRifle() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.isDerivedFrom("object/weapon/ranged/rifle/rifle_acid_beam.iff");
	return weaponTemplate->isDerivedFrom("object/weapon/ranged/rifle/rifle_acid_beam.iff");
}

bool WeaponObjectImplementation::isCarbineWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.CARBINE;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::CARBINE;
}

bool WeaponObjectImplementation::isPistolWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.PISTOL;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::PISTOL;
}

bool WeaponObjectImplementation::isOneHandMeleeWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.ONEHANDMELEEWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::ONEHANDMELEEWEAPON;
}

bool WeaponObjectImplementation::isPolearmWeaponObject() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.POLEARM;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::POLEARM;
}

bool WeaponObjectImplementation::isTwoHandMeleeWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.TWOHANDMELEEWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::TWOHANDMELEEWEAPON;
}

bool WeaponObjectImplementation::isMineWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.MINE;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::MINE;
}

bool WeaponObjectImplementation::isJediWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return isJediOneHandedWeapon() || isJediTwoHandedWeapon() || isJediPolearmWeapon();
	return isJediOneHandedWeapon() || isJediTwoHandedWeapon() || isJediPolearmWeapon();
}

bool WeaponObjectImplementation::isJediOneHandedWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.isDerivedFrom("object/weapon/melee/sword/base/shared_crafted_lightsaber_base.iff");
	return weaponTemplate->isDerivedFrom("object/weapon/melee/sword/base/shared_crafted_lightsaber_base.iff");
}

bool WeaponObjectImplementation::isJediTwoHandedWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.isDerivedFrom("object/weapon/melee/2h_sword/base/shared_crafted_lightsaber_base.iff");
	return weaponTemplate->isDerivedFrom("object/weapon/melee/2h_sword/base/shared_crafted_lightsaber_base.iff");
}

bool WeaponObjectImplementation::isJediPolearmWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.isDerivedFrom("object/weapon/melee/polearm/base/shared_crafted_lance_lightsaber_base.iff");
	return weaponTemplate->isDerivedFrom("object/weapon/melee/polearm/base/shared_crafted_lance_lightsaber_base.iff");
}

bool WeaponObjectImplementation::isWeaponObject() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return true;
	return true;
}

bool WeaponObjectImplementation::hasPowerup() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return powerupObject != null;
	return powerupObject != NULL;
}

void WeaponObjectImplementation::applyPowerup(CreatureObject* player, PowerupObject* pup) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  	}
	if (!hasPowerup()){
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  			powerupObject = pup;
	powerupObject = pup;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  			sendAttributeListTo(
	if (pup->getParent() != NULL)	// server/zone/objects/tangible/weapon/WeaponObject.idl():  				pup.destroyObjectFromWorld(true);
	pup->destroyObjectFromWorld(true);
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  			sendAttributeListTo(player);
	sendAttributeListTo(player);
}
}

PowerupObject* WeaponObjectImplementation::removePowerup() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return 
	if (hasPowerup()){
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  			PowerupObject pup = powerupObject;
	ManagedReference<PowerupObject* > pup = powerupObject;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  			powerupObject = null;
	powerupObject = NULL;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  			return pup;
	return pup;
}
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return null;
	return NULL;
}

void WeaponObjectImplementation::setDamageSlice(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageSlice 
	if (value > 0.5f || value < 0)	// server/zone/objects/tangible/weapon/WeaponObject.idl():  			return;
	return;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageSlice = 1 + value;
	damageSlice = 1 + value;
}

void WeaponObjectImplementation::setSpeedSlice(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		speedSlice 
	if (value > 0.5f || value < 0)	// server/zone/objects/tangible/weapon/WeaponObject.idl():  			return;
	return;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		speedSlice = 1 - value;
	speedSlice = 1 - value;
}

void WeaponObjectImplementation::addSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		wearableSkillMods.put(skillMod, value);
	(&wearableSkillMods)->put(skillMod, value);
}

/*
 *	WeaponObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


WeaponObjectAdapter::WeaponObjectAdapter(WeaponObject* obj) : TangibleObjectAdapter(obj) {
}

void WeaponObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			initializeTransientMembers();
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			sendBaselinesTo(static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SENDCONTAINERTO__CREATUREOBJECT_:
		{
			sendContainerTo(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_CREATECHILDOBJECTS__:
		{
			createChildObjects();
		}
		break;
	case RPC_ISCERTIFIEDFOR__CREATUREOBJECT_:
		{
			resp->insertBoolean(isCertifiedFor(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_SETCERTIFIED__BOOL_:
		{
			setCertified(inv->getBooleanParameter());
		}
		break;
	case RPC_GETATTACKTYPE__:
		{
			resp->insertSignedInt(getAttackType());
		}
		break;
	case RPC_SETATTACKTYPE__INT_:
		{
			setAttackType(inv->getSignedIntParameter());
		}
		break;
	case RPC_ISCERTIFIED__:
		{
			resp->insertBoolean(isCertified());
		}
		break;
	case RPC_GETPOINTBLANKACCURACY__BOOL_:
		{
			resp->insertSignedInt(getPointBlankAccuracy(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETPOINTBLANKACCURACY__INT_:
		{
			setPointBlankAccuracy(inv->getSignedIntParameter());
		}
		break;
	case RPC_GETPOINTBLANKRANGE__BOOL_:
		{
			resp->insertSignedInt(getPointBlankRange(inv->getBooleanParameter()));
		}
		break;
	case RPC_GETIDEALRANGE__BOOL_:
		{
			resp->insertSignedInt(getIdealRange(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETIDEALRANGE__INT_:
		{
			setIdealRange(inv->getSignedIntParameter());
		}
		break;
	case RPC_GETMAXRANGE__BOOL_:
		{
			resp->insertSignedInt(getMaxRange(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETMAXRANGE__INT_:
		{
			setMaxRange(inv->getSignedIntParameter());
		}
		break;
	case RPC_GETIDEALACCURACY__BOOL_:
		{
			resp->insertSignedInt(getIdealAccuracy(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETIDEALACCURACY__INT_:
		{
			setIdealAccuracy(inv->getSignedIntParameter());
		}
		break;
	case RPC_GETARMORPIERCING__:
		{
			resp->insertSignedInt(getArmorPiercing());
		}
		break;
	case RPC_GETMAXRANGEACCURACY__BOOL_:
		{
			resp->insertSignedInt(getMaxRangeAccuracy(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETMAXRANGEACCURACY__INT_:
		{
			setMaxRangeAccuracy(inv->getSignedIntParameter());
		}
		break;
	case RPC_GETATTACKSPEED__BOOL_:
		{
			resp->insertFloat(getAttackSpeed(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETATTACKSPEED__FLOAT_:
		{
			setAttackSpeed(inv->getFloatParameter());
		}
		break;
	case RPC_GETMAXDAMAGE__BOOL_:
		{
			resp->insertFloat(getMaxDamage(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETMAXDAMAGE__FLOAT_:
		{
			setMaxDamage(inv->getFloatParameter());
		}
		break;
	case RPC_GETMINDAMAGE__BOOL_:
		{
			resp->insertFloat(getMinDamage(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETMINDAMAGE__FLOAT_:
		{
			setMinDamage(inv->getFloatParameter());
		}
		break;
	case RPC_GETWOUNDSRATIO__BOOL_:
		{
			resp->insertFloat(getWoundsRatio(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETWOUNDSRATIO__FLOAT_:
		{
			setWoundsRatio(inv->getFloatParameter());
		}
		break;
	case RPC_GETDAMAGERADIUS__BOOL_:
		{
			resp->insertFloat(getDamageRadius(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETDAMAGERADIUS__FLOAT_:
		{
			setDamageRadius(inv->getFloatParameter());
		}
		break;
	case RPC_GETHEALTHATTACKCOST__BOOL_:
		{
			resp->insertSignedInt(getHealthAttackCost(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETHEALTHATTACKCOST__INT_:
		{
			setHealthAttackCost(inv->getSignedIntParameter());
		}
		break;
	case RPC_GETACTIONATTACKCOST__BOOL_:
		{
			resp->insertSignedInt(getActionAttackCost(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETACTIONATTACKCOST__INT_:
		{
			setActionAttackCost(inv->getSignedIntParameter());
		}
		break;
	case RPC_GETMINDATTACKCOST__BOOL_:
		{
			resp->insertSignedInt(getMindAttackCost(inv->getBooleanParameter()));
		}
		break;
	case RPC_SETMINDATTACKCOST__INT_:
		{
			setMindAttackCost(inv->getSignedIntParameter());
		}
		break;
	case RPC_GETFORCECOST__:
		{
			resp->insertSignedInt(getForceCost());
		}
		break;
	case RPC_SETFORCECOST__INT_:
		{
			setForceCost(inv->getSignedIntParameter());
		}
		break;
	case RPC_GETBLADECOLOR__:
		{
			resp->insertSignedInt(getBladeColor());
		}
		break;
	case RPC_SETBLADECOLOR__INT_:
		{
			setBladeColor(inv->getSignedIntParameter());
		}
		break;
	case RPC_GETDAMAGETYPE__:
		{
			resp->insertSignedInt(getDamageType());
		}
		break;
	case RPC_GETXPTYPE__:
		{
			resp->insertAscii(getXpType());
		}
		break;
	case RPC_GETDOTTYPE__:
		{
			resp->insertSignedInt(getDotType());
		}
		break;
	case RPC_GETDOTATTRIBUTE__:
		{
			resp->insertSignedInt(getDotAttribute());
		}
		break;
	case RPC_GETDOTSTRENGTH__:
		{
			resp->insertSignedInt(getDotStrength());
		}
		break;
	case RPC_GETDOTDURATION__:
		{
			resp->insertSignedInt(getDotDuration());
		}
		break;
	case RPC_GETDOTPOTENCY__:
		{
			resp->insertSignedInt(getDotPotency());
		}
		break;
	case RPC_GETDOTUSES__:
		{
			resp->insertSignedInt(getDotUses());
		}
		break;
	case RPC_SETDOTTYPE__INT_:
		{
			setDotType(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETDOTATTRIBUTE__INT_:
		{
			setDotAttribute(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETDOTSTRENGTH__INT_:
		{
			setDotStrength(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETDOTDURATION__INT_:
		{
			setDotDuration(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETDOTPOTENCY__INT_:
		{
			setDotPotency(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETDOTUSES__INT_:
		{
			setDotUses(inv->getSignedIntParameter());
		}
		break;
	case RPC_GETWEAPONTYPE__:
		{
			resp->insertAscii(getWeaponType());
		}
		break;
	case RPC_ISUNARMEDWEAPON__:
		{
			resp->insertBoolean(isUnarmedWeapon());
		}
		break;
	case RPC_ISMELEEWEAPON__:
		{
			resp->insertBoolean(isMeleeWeapon());
		}
		break;
	case RPC_ISRANGEDWEAPON__:
		{
			resp->insertBoolean(isRangedWeapon());
		}
		break;
	case RPC_ISRIFLEWEAPON__:
		{
			resp->insertBoolean(isRifleWeapon());
		}
		break;
	case RPC_ISTHROWNWEAPON__:
		{
			resp->insertBoolean(isThrownWeapon());
		}
		break;
	case RPC_ISHEAVYWEAPON__:
		{
			resp->insertBoolean(isHeavyWeapon());
		}
		break;
	case RPC_ISSPECIALHEAVYWEAPON__:
		{
			resp->insertBoolean(isSpecialHeavyWeapon());
		}
		break;
	case RPC_ISLIGHTNINGRIFLE__:
		{
			resp->insertBoolean(isLightningRifle());
		}
		break;
	case RPC_ISFLAMETHROWER__:
		{
			resp->insertBoolean(isFlameThrower());
		}
		break;
	case RPC_ISHEAVYACIDRIFLE__:
		{
			resp->insertBoolean(isHeavyAcidRifle());
		}
		break;
	case RPC_ISCARBINEWEAPON__:
		{
			resp->insertBoolean(isCarbineWeapon());
		}
		break;
	case RPC_ISPISTOLWEAPON__:
		{
			resp->insertBoolean(isPistolWeapon());
		}
		break;
	case RPC_ISONEHANDMELEEWEAPON__:
		{
			resp->insertBoolean(isOneHandMeleeWeapon());
		}
		break;
	case RPC_ISPOLEARMWEAPONOBJECT__:
		{
			resp->insertBoolean(isPolearmWeaponObject());
		}
		break;
	case RPC_ISTWOHANDMELEEWEAPON__:
		{
			resp->insertBoolean(isTwoHandMeleeWeapon());
		}
		break;
	case RPC_ISMINEWEAPON__:
		{
			resp->insertBoolean(isMineWeapon());
		}
		break;
	case RPC_ISJEDIWEAPON__:
		{
			resp->insertBoolean(isJediWeapon());
		}
		break;
	case RPC_ISJEDIONEHANDEDWEAPON__:
		{
			resp->insertBoolean(isJediOneHandedWeapon());
		}
		break;
	case RPC_ISJEDITWOHANDEDWEAPON__:
		{
			resp->insertBoolean(isJediTwoHandedWeapon());
		}
		break;
	case RPC_ISJEDIPOLEARMWEAPON__:
		{
			resp->insertBoolean(isJediPolearmWeapon());
		}
		break;
	case RPC_ISWEAPONOBJECT__:
		{
			resp->insertBoolean(isWeaponObject());
		}
		break;
	case RPC_HASPOWERUP__:
		{
			resp->insertBoolean(hasPowerup());
		}
		break;
	case RPC_APPLYPOWERUP__CREATUREOBJECT_POWERUPOBJECT_:
		{
			applyPowerup(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<PowerupObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_REMOVEPOWERUP__:
		{
			resp->insertLong(removePowerup()->_getObjectID());
		}
		break;
	case RPC_DECREASEPOWERUPUSES__CREATUREOBJECT_:
		{
			decreasePowerupUses(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_REPAIRATTEMPT__INT_:
		{
			resp->insertAscii(repairAttempt(inv->getSignedIntParameter()));
		}
		break;
	case RPC_DECAY__CREATUREOBJECT_FLOAT_:
		{
			decay(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getFloatParameter());
		}
		break;
	case RPC_SETDAMAGESLICE__FLOAT_:
		{
			setDamageSlice(inv->getFloatParameter());
		}
		break;
	case RPC_SETSPEEDSLICE__FLOAT_:
		{
			setSpeedSlice(inv->getFloatParameter());
		}
		break;
	case RPC_APPLYSKILLMODSTO__CREATUREOBJECT_BOOL_:
		{
			applySkillModsTo(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getBooleanParameter());
		}
		break;
	case RPC_REMOVESKILLMODSFROM__CREATUREOBJECT_:
		{
			removeSkillModsFrom(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_:
		{
			String skillMod; 
			addSkillMod(inv->getSignedIntParameter(), inv->getAsciiParameter(skillMod), inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	default:
		throw Exception("Method does not exists");
	}
}

void WeaponObjectAdapter::initializeTransientMembers() {
	(static_cast<WeaponObject*>(stub))->initializeTransientMembers();
}

void WeaponObjectAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<WeaponObject*>(stub))->sendBaselinesTo(player);
}

void WeaponObjectAdapter::sendContainerTo(CreatureObject* player) {
	(static_cast<WeaponObject*>(stub))->sendContainerTo(player);
}

void WeaponObjectAdapter::createChildObjects() {
	(static_cast<WeaponObject*>(stub))->createChildObjects();
}

bool WeaponObjectAdapter::isCertifiedFor(CreatureObject* object) {
	return (static_cast<WeaponObject*>(stub))->isCertifiedFor(object);
}

void WeaponObjectAdapter::setCertified(bool cert) {
	(static_cast<WeaponObject*>(stub))->setCertified(cert);
}

int WeaponObjectAdapter::getAttackType() {
	return (static_cast<WeaponObject*>(stub))->getAttackType();
}

void WeaponObjectAdapter::setAttackType(int a) {
	(static_cast<WeaponObject*>(stub))->setAttackType(a);
}

bool WeaponObjectAdapter::isCertified() {
	return (static_cast<WeaponObject*>(stub))->isCertified();
}

int WeaponObjectAdapter::getPointBlankAccuracy(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getPointBlankAccuracy(withPup);
}

void WeaponObjectAdapter::setPointBlankAccuracy(int value) {
	(static_cast<WeaponObject*>(stub))->setPointBlankAccuracy(value);
}

int WeaponObjectAdapter::getPointBlankRange(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getPointBlankRange(withPup);
}

int WeaponObjectAdapter::getIdealRange(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getIdealRange(withPup);
}

void WeaponObjectAdapter::setIdealRange(int value) {
	(static_cast<WeaponObject*>(stub))->setIdealRange(value);
}

int WeaponObjectAdapter::getMaxRange(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getMaxRange(withPup);
}

void WeaponObjectAdapter::setMaxRange(int value) {
	(static_cast<WeaponObject*>(stub))->setMaxRange(value);
}

int WeaponObjectAdapter::getIdealAccuracy(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getIdealAccuracy(withPup);
}

void WeaponObjectAdapter::setIdealAccuracy(int value) {
	(static_cast<WeaponObject*>(stub))->setIdealAccuracy(value);
}

int WeaponObjectAdapter::getArmorPiercing() {
	return (static_cast<WeaponObject*>(stub))->getArmorPiercing();
}

int WeaponObjectAdapter::getMaxRangeAccuracy(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getMaxRangeAccuracy(withPup);
}

void WeaponObjectAdapter::setMaxRangeAccuracy(int value) {
	(static_cast<WeaponObject*>(stub))->setMaxRangeAccuracy(value);
}

float WeaponObjectAdapter::getAttackSpeed(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getAttackSpeed(withPup);
}

void WeaponObjectAdapter::setAttackSpeed(float value) {
	(static_cast<WeaponObject*>(stub))->setAttackSpeed(value);
}

float WeaponObjectAdapter::getMaxDamage(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getMaxDamage(withPup);
}

void WeaponObjectAdapter::setMaxDamage(float value) {
	(static_cast<WeaponObject*>(stub))->setMaxDamage(value);
}

float WeaponObjectAdapter::getMinDamage(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getMinDamage(withPup);
}

void WeaponObjectAdapter::setMinDamage(float value) {
	(static_cast<WeaponObject*>(stub))->setMinDamage(value);
}

float WeaponObjectAdapter::getWoundsRatio(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getWoundsRatio(withPup);
}

void WeaponObjectAdapter::setWoundsRatio(float value) {
	(static_cast<WeaponObject*>(stub))->setWoundsRatio(value);
}

float WeaponObjectAdapter::getDamageRadius(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getDamageRadius(withPup);
}

void WeaponObjectAdapter::setDamageRadius(float value) {
	(static_cast<WeaponObject*>(stub))->setDamageRadius(value);
}

int WeaponObjectAdapter::getHealthAttackCost(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getHealthAttackCost(withPup);
}

void WeaponObjectAdapter::setHealthAttackCost(int value) {
	(static_cast<WeaponObject*>(stub))->setHealthAttackCost(value);
}

int WeaponObjectAdapter::getActionAttackCost(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getActionAttackCost(withPup);
}

void WeaponObjectAdapter::setActionAttackCost(int value) {
	(static_cast<WeaponObject*>(stub))->setActionAttackCost(value);
}

int WeaponObjectAdapter::getMindAttackCost(bool withPup) {
	return (static_cast<WeaponObject*>(stub))->getMindAttackCost(withPup);
}

void WeaponObjectAdapter::setMindAttackCost(int value) {
	(static_cast<WeaponObject*>(stub))->setMindAttackCost(value);
}

int WeaponObjectAdapter::getForceCost() {
	return (static_cast<WeaponObject*>(stub))->getForceCost();
}

void WeaponObjectAdapter::setForceCost(int value) {
	(static_cast<WeaponObject*>(stub))->setForceCost(value);
}

int WeaponObjectAdapter::getBladeColor() {
	return (static_cast<WeaponObject*>(stub))->getBladeColor();
}

void WeaponObjectAdapter::setBladeColor(int value) {
	(static_cast<WeaponObject*>(stub))->setBladeColor(value);
}

int WeaponObjectAdapter::getDamageType() {
	return (static_cast<WeaponObject*>(stub))->getDamageType();
}

String WeaponObjectAdapter::getXpType() {
	return (static_cast<WeaponObject*>(stub))->getXpType();
}

int WeaponObjectAdapter::getDotType() {
	return (static_cast<WeaponObject*>(stub))->getDotType();
}

int WeaponObjectAdapter::getDotAttribute() {
	return (static_cast<WeaponObject*>(stub))->getDotAttribute();
}

int WeaponObjectAdapter::getDotStrength() {
	return (static_cast<WeaponObject*>(stub))->getDotStrength();
}

int WeaponObjectAdapter::getDotDuration() {
	return (static_cast<WeaponObject*>(stub))->getDotDuration();
}

int WeaponObjectAdapter::getDotPotency() {
	return (static_cast<WeaponObject*>(stub))->getDotPotency();
}

int WeaponObjectAdapter::getDotUses() {
	return (static_cast<WeaponObject*>(stub))->getDotUses();
}

void WeaponObjectAdapter::setDotType(int t) {
	(static_cast<WeaponObject*>(stub))->setDotType(t);
}

void WeaponObjectAdapter::setDotAttribute(int a) {
	(static_cast<WeaponObject*>(stub))->setDotAttribute(a);
}

void WeaponObjectAdapter::setDotStrength(int s) {
	(static_cast<WeaponObject*>(stub))->setDotStrength(s);
}

void WeaponObjectAdapter::setDotDuration(int du) {
	(static_cast<WeaponObject*>(stub))->setDotDuration(du);
}

void WeaponObjectAdapter::setDotPotency(int po) {
	(static_cast<WeaponObject*>(stub))->setDotPotency(po);
}

void WeaponObjectAdapter::setDotUses(int u) {
	(static_cast<WeaponObject*>(stub))->setDotUses(u);
}

String WeaponObjectAdapter::getWeaponType() {
	return (static_cast<WeaponObject*>(stub))->getWeaponType();
}

bool WeaponObjectAdapter::isUnarmedWeapon() {
	return (static_cast<WeaponObject*>(stub))->isUnarmedWeapon();
}

bool WeaponObjectAdapter::isMeleeWeapon() {
	return (static_cast<WeaponObject*>(stub))->isMeleeWeapon();
}

bool WeaponObjectAdapter::isRangedWeapon() {
	return (static_cast<WeaponObject*>(stub))->isRangedWeapon();
}

bool WeaponObjectAdapter::isRifleWeapon() {
	return (static_cast<WeaponObject*>(stub))->isRifleWeapon();
}

bool WeaponObjectAdapter::isThrownWeapon() {
	return (static_cast<WeaponObject*>(stub))->isThrownWeapon();
}

bool WeaponObjectAdapter::isHeavyWeapon() {
	return (static_cast<WeaponObject*>(stub))->isHeavyWeapon();
}

bool WeaponObjectAdapter::isSpecialHeavyWeapon() {
	return (static_cast<WeaponObject*>(stub))->isSpecialHeavyWeapon();
}

bool WeaponObjectAdapter::isLightningRifle() {
	return (static_cast<WeaponObject*>(stub))->isLightningRifle();
}

bool WeaponObjectAdapter::isFlameThrower() {
	return (static_cast<WeaponObject*>(stub))->isFlameThrower();
}

bool WeaponObjectAdapter::isHeavyAcidRifle() {
	return (static_cast<WeaponObject*>(stub))->isHeavyAcidRifle();
}

bool WeaponObjectAdapter::isCarbineWeapon() {
	return (static_cast<WeaponObject*>(stub))->isCarbineWeapon();
}

bool WeaponObjectAdapter::isPistolWeapon() {
	return (static_cast<WeaponObject*>(stub))->isPistolWeapon();
}

bool WeaponObjectAdapter::isOneHandMeleeWeapon() {
	return (static_cast<WeaponObject*>(stub))->isOneHandMeleeWeapon();
}

bool WeaponObjectAdapter::isPolearmWeaponObject() {
	return (static_cast<WeaponObject*>(stub))->isPolearmWeaponObject();
}

bool WeaponObjectAdapter::isTwoHandMeleeWeapon() {
	return (static_cast<WeaponObject*>(stub))->isTwoHandMeleeWeapon();
}

bool WeaponObjectAdapter::isMineWeapon() {
	return (static_cast<WeaponObject*>(stub))->isMineWeapon();
}

bool WeaponObjectAdapter::isJediWeapon() {
	return (static_cast<WeaponObject*>(stub))->isJediWeapon();
}

bool WeaponObjectAdapter::isJediOneHandedWeapon() {
	return (static_cast<WeaponObject*>(stub))->isJediOneHandedWeapon();
}

bool WeaponObjectAdapter::isJediTwoHandedWeapon() {
	return (static_cast<WeaponObject*>(stub))->isJediTwoHandedWeapon();
}

bool WeaponObjectAdapter::isJediPolearmWeapon() {
	return (static_cast<WeaponObject*>(stub))->isJediPolearmWeapon();
}

bool WeaponObjectAdapter::isWeaponObject() {
	return (static_cast<WeaponObject*>(stub))->isWeaponObject();
}

bool WeaponObjectAdapter::hasPowerup() {
	return (static_cast<WeaponObject*>(stub))->hasPowerup();
}

void WeaponObjectAdapter::applyPowerup(CreatureObject* player, PowerupObject* pup) {
	(static_cast<WeaponObject*>(stub))->applyPowerup(player, pup);
}

PowerupObject* WeaponObjectAdapter::removePowerup() {
	return (static_cast<WeaponObject*>(stub))->removePowerup();
}

void WeaponObjectAdapter::decreasePowerupUses(CreatureObject* player) {
	(static_cast<WeaponObject*>(stub))->decreasePowerupUses(player);
}

String WeaponObjectAdapter::repairAttempt(int repairChance) {
	return (static_cast<WeaponObject*>(stub))->repairAttempt(repairChance);
}

void WeaponObjectAdapter::decay(CreatureObject* user, float damage) {
	(static_cast<WeaponObject*>(stub))->decay(user, damage);
}

void WeaponObjectAdapter::setDamageSlice(float value) {
	(static_cast<WeaponObject*>(stub))->setDamageSlice(value);
}

void WeaponObjectAdapter::setSpeedSlice(float value) {
	(static_cast<WeaponObject*>(stub))->setSpeedSlice(value);
}

void WeaponObjectAdapter::applySkillModsTo(CreatureObject* creature, bool doCheck) {
	(static_cast<WeaponObject*>(stub))->applySkillModsTo(creature, doCheck);
}

void WeaponObjectAdapter::removeSkillModsFrom(CreatureObject* creature) {
	(static_cast<WeaponObject*>(stub))->removeSkillModsFrom(creature);
}

void WeaponObjectAdapter::addSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
	(static_cast<WeaponObject*>(stub))->addSkillMod(skillType, skillMod, value, notifyClient);
}

/*
 *	WeaponObjectHelper
 */

WeaponObjectHelper* WeaponObjectHelper::staticInitializer = WeaponObjectHelper::instance();

WeaponObjectHelper::WeaponObjectHelper() {
	className = "WeaponObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void WeaponObjectHelper::finalizeHelper() {
	WeaponObjectHelper::finalize();
}

DistributedObject* WeaponObjectHelper::instantiateObject() {
	return new WeaponObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* WeaponObjectHelper::instantiateServant() {
	return new WeaponObjectImplementation();
}

DistributedObjectAdapter* WeaponObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new WeaponObjectAdapter(static_cast<WeaponObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

