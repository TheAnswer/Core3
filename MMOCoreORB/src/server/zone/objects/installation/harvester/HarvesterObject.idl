/*
				Copyright <SWGEmu>
		See file COPYING for copying conditions.*/

package server.zone.objects.installation.harvester;

import server.zone.objects.installation.InstallationObject;
include server.zone.objects.installation.InstallationSynchronizedUi;
import server.zone.packets.object.ObjectMenuResponse;
include templates.SharedObjectTemplate;
include engine.log.Logger;
import server.zone.packets.scene.AttributeListMessage;
import server.zone.objects.creature.CreatureObject;
include server.zone.objects.resource.ResourceSpawn;
import system.util.Vector;
import system.util.VectorMap;
import system.lang.Time;

//@json
class HarvesterObject extends InstallationObject {
	protected boolean selfPowered;
	
	protected float installedExtractionRate;
	protected unsigned long resourceType;
	protected float maxExtractionRate;
	protected float currentExtractionRate;
	protected int maxHopperAmount;
	
	@dereferenced 
	protected transient Vector<ResourceSpawn> surveyList;
	
	@dereferenced
	protected Time lastSurveyTime;
	
	protected VectorMap<unsigned long, float> hopperContents;
	
	@dereferenced
	protected transient Vector<CreatureObject> currentOperators;
	
	@dereferenced
	protected transient InstallationSynchronizedUi syncUi;

	public HarvesterObject() {
		Logger.setLoggingName("HarvesterObject");
		selfPowered = false;
		
		hopperContents.setNullValue(0);
		hopperContents.setAllowOverwriteInsertPlan();
		
		installedExtractionRate = 0;
		resourceType = 0;
		maxExtractionRate = 0;
		currentExtractionRate = 0;
		maxHopperAmount = 0;
	}

	@preLocked
	public void setSelfPowered(boolean isSelfPowered) {
		selfPowered = isSelfPowered;
	}
	
	@read
	public float getCurrentExtractionRate() {
		return currentExtractionRate;
	}
	
	@read
	public float getMaxExtractionRate() {
		return maxExtractionRate;
	}
	
	@read
	public float getInstalledExtractionRate() {
		return installedExtractionRate;
	}
	
	@read
	public unsigned long getResourceType() {
		return resourceType;
	}
	
	@read
	public int getMaxHopperAmount() {
		return maxHopperAmount;
	}

	@read
	public boolean isSelfPowered() {
		return selfPowered;
	}

	@read
	public int getBasePowerRate() {
		if(isSelfPowered())
			return 0;
		else
			return super.getBasePowerRate();
	}
	
	public void setMaxExtractionRate(float rate) {
		if (currentExtractionRate > rate)
			currentExtractionRate = rate;
		
		maxExtractionRate = rate;
	}
	
	public native void setCurrentExtractionRate(float rate);

	public void setMaxHopperSize(int size) {
		maxHopperAmount = size;
	}

	/**
	 * Reads and sets the template data from a SharedObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { SceneObject members are initialized }
	 * @param templateData templateData points to the LuaObject that is used to initialize SceneObejct members
	 */
	@local
	public native void loadTemplateData(SharedObjectTemplate templateData) {
		super.loadTemplateData(templateData);
	}

	/**
	 * Fills the radial options, needs to be overriden
	 * @pre { this object is locked }
	 * @post { this object is locked, menuResponse is complete}
	 * @param menuResponse ObjectMenuResponse that will be sent to the client
	 */
	@local
	@dirty
	public native void fillObjectMenuResponse(ObjectMenuResponse menuResponse, CreatureObject player);

	/**
	 * Handles the radial selection sent by the client, must be overriden by inherited objects
	 * @pre { this object is locked, player is locked }
	 * @post { this object is locked, player is locked }
	 * @param player CreatureObject that selected the option
	 * @param selectedID selected menu id
	 * @returns 0 if successfull
	 */
	@preLocked
	@arg1preLocked
	public native int handleObjectMenuSelect(CreatureObject player, byte selectedID);

	@dirty
	public boolean isHarvesterObject() {
		return true;
	}

	/**
	 * Fills the attribute list message options that are sent to player creature
	 * @pre { }
	 * @post { }
	 * @param msg attribute list message with the attributes
	 * @param object player creature to which the message is sent
	 */
	@local
	@dirty
	public native void fillAttributeList(AttributeListMessage msg, CreatureObject object);
	
	public native ResourceSpawn getSelectedResourcePool();
	
	@local
	public native float getHopperContents(VectorMap<unsigned long, float> hopperList = null);
	
	@preLocked
	public native void activate(CreatureObject player);
	
	@preLocked
	public native void installationTick();
	
	@preLocked
	public native void deactivate();
	
	public native void scheduleTickTask(boolean immediate);
	
	@local
	@dirty
	public native void selectResource(unsigned long resourceID, CreatureObject player);
	
	@preLocked
	@local
	public native void emptyHopper(CreatureObject player, unsigned long resourceID, int amount, boolean discard, byte sequenceID);
	
	public void addResource(unsigned long resourceId, float amount) {
		float curAmount = hopperContents.get(resourceId);
		
		float newAmount = curAmount + amount;
		
		if (newAmount < 0)
			newAmount = 0;
		
		hopperContents.put(resourceId, newAmount);
	}
	
	public int getOperatorCount() {
		return currentOperators.size();
	}
	
	public void discardHopperContents() {
		hopperContents.removeAll();
	}
	
	public native void takeSurvey();
	
	@local
	public native InstallationSynchronizedUi getSynchronizedUi();
}
