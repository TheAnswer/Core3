/*
 				Copyright <SWGEmu>
		See file COPYING for copying conditions. */

#ifndef STARTDANCECOMMAND_H_
#define STARTDANCECOMMAND_H_

#include "server/zone/objects/player/sessions/EntertainingSession.h"
#include "server/zone/objects/player/sui/listbox/SuiListBox.h"
#include "server/zone/managers/skill/SkillManager.h"
#include "server/zone/managers/skill/PerformanceManager.h"

class StartDanceCommand: public QueueCommand {

public:
	StartDanceCommand(const String& name, ZoneProcessServer* server) :
		QueueCommand(name, server) {

	}

	static void startDance(CreatureObject* creature, int performanceIndex) {
		ManagedReference<Facade*> facade = creature->getActiveSession(SessionFacadeType::ENTERTAINING);
		ManagedReference<EntertainingSession*> session = dynamic_cast<EntertainingSession*> (facade.get());

		if (session == nullptr) {
			session = new EntertainingSession(creature);
			creature->addActiveSession(SessionFacadeType::ENTERTAINING, session);
		}

		session->startDancing(performanceIndex);
	}

<<<<<<< Updated upstream
	static void sendAvailableDances(CreatureObject* player, PlayerObject* ghost, uint32 suiType = SuiWindowType::DANCING_START) {
		ManagedReference<SuiListBox*> sui = new SuiListBox(player, suiType);
		sui->setPromptTitle("@performance:available_dances");
		sui->setPromptText("@performance:select_dance");

		const AbilityList* list = ghost->getAbilityList();

		for (int i = 0; i < list->size(); ++i) {
			const Ability* ability = list->get(i);

			String abilityName = ability->getAbilityName();

			if (abilityName.indexOf("startDance") != -1) {
				int args = abilityName.indexOf("+");

				if (args != -1) {
					String arg = abilityName.subString(args + 1);

					sui->addMenuItem(arg);
				}
			}
		}

		ghost->addSuiBox(sui);
		player->sendMessage(sui->generateMessage());

		return;
	}

	int doQueueCommand(CreatureObject* creature, const uint64& target,
			const UnicodeString& arguments) const {
=======
	int doQueueCommand(CreatureObject* creature, const uint64& target, const UnicodeString& arguments) const {
>>>>>>> Stashed changes

		if (!checkStateMask(creature))
			return INVALIDSTATE;

		if (!checkInvalidLocomotions(creature))
			return INVALIDLOCOMOTION;

		if (!creature->isPlayerCreature())
			return GENERALERROR;

		ManagedReference<Facade*> facade = creature->getActiveSession(SessionFacadeType::ENTERTAINING);
		ManagedReference<EntertainingSession*> session = dynamic_cast<EntertainingSession*> (facade.get());

		if (session != nullptr && (session->isPlayingMusic() || session->isDancing())) {
			creature->sendSystemMessage("@performance:already_performing_self"); // You are already performing.
			return GENERALERROR;
		}

		Reference<PlayerObject*> ghost = creature->getPlayerObject();

		if (ghost == nullptr)
			return GENERALERROR;

		String args = arguments.toString();

		PerformanceManager* performanceManager = SkillManager::instance()->getPerformanceManager();

		if (args.length() < 1) {
			performanceManager->sendAvailableDances(creature);
			return SUCCESS;
		}

		Performance* performance = performanceManager->getDance(args);

		if (performance == nullptr) {
			creature->sendSystemMessage("@performance:dance_unknown_self"); 	// You do not know that dance.
			return GENERALERROR;
		}

		String fullString = String("startDance") + "+" + args;

		if (!ghost->hasAbility(fullString)) {
			creature->sendSystemMessage("@performance:dance_lack_skill_self"); 	// You do not have the skill to perform the dance.
			return GENERALERROR;
		}

		startDance(creature, performance->getPerformanceIndex());

		return SUCCESS;
	}

};

#endif //STARTDANCECOMMAND_H_
