/*
 *	server/zone/objects/creature/CreatureObject.cpp generated by engine3 IDL compiler 0.60
 */

#include "CreatureObject.h"

#include "server/chat/StringIdChatParameter.h"

#include "server/zone/objects/group/GroupObject.h"

#include "server/zone/objects/guild/GuildObject.h"

#include "server/zone/objects/tangible/weapon/WeaponObject.h"

#include "server/zone/managers/objectcontroller/ObjectController.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/creature/ai/AiActor.h"

#include "server/zone/objects/player/PlayerObject.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/intangible/ControlDevice.h"

#include "server/zone/objects/area/ActiveArea.h"

#include "server/zone/objects/area/CampSiteActiveArea.h"

#include "server/zone/Zone.h"

#include "server/zone/templates/SharedObjectTemplate.h"

#include "server/zone/objects/creature/buffs/Buff.h"

#include "server/zone/objects/tangible/weapon/WeaponObject.h"

#include "server/zone/ZoneClientSession.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

/*
 *	CreatureObjectStub
 */

enum {RPC_INITIALIZEMEMBERS__ = 6,RPC_FINALIZE__,RPC_CREATECHILDOBJECTS__,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_CLEARQUEUEACTION__INT_FLOAT_INT_INT_,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_SENDTOOWNER__BOOL_,RPC_SENDTO__SCENEOBJECT_BOOL_,RPC_SENDSYSTEMMESSAGE__STRING_,RPC_PLAYMUSICMESSAGE__STRING_,RPC_SENDNEWBIETUTORIALREQUEST__STRING_,RPC_SENDNEWBIETUTORIALENABLEHUDELEMENT__STRING_BOOL_,RPC_SENDOPENHOLOCRONTOPAGEMESSAGE__,RPC_SENDSYSTEMMESSAGE__UNICODESTRING_,RPC_SENDSLOTTEDOBJECTSTO__SCENEOBJECT_,RPC_SETCOMBATSTATE__,RPC_CLEARCOMBATSTATE__BOOL_,RPC_SETPOSTURE__INT_BOOL_,RPC_CALCULATESPEED__,RPC_UPDATELOCOMOTION__,RPC_SETHEIGHT__FLOAT_BOOL_,RPC_SETACCELERATIONMULTIPLIERBASE__FLOAT_BOOL_,RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_BOOL_,RPC_SETSPEEDMULTIPLIERBASE__FLOAT_BOOL_,RPC_SETSPEEDMULTIPLIERMOD__FLOAT_BOOL_,RPC_SETTURNSCALE__FLOAT_BOOL_,RPC_SETRUNSPEED__FLOAT_BOOL_,RPC_SETCURRENTSPEED__FLOAT_,RPC_SETHAM__INT_INT_BOOL_,RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_,RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_,RPC_HASDAMAGE__INT_,RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_,RPC_HEALWOUND__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_,RPC_SETBASEHAM__INT_INT_BOOL_,RPC_SETWOUNDS__INT_INT_BOOL_,RPC_ADDWOUNDS__INT_INT_BOOL_,RPC_SETMAXHAM__INT_INT_BOOL_,RPC_ADDMAXHAM__INT_INT_BOOL_,RPC_SETENCUMBRANCE__INT_INT_BOOL_,RPC_ADDENCUMBRANCE__INT_INT_BOOL_,RPC_SETWEAPON__WEAPONOBJECT_BOOL_,RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_,RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_,RPC_SETINSTRUMENTID__INT_BOOL_,RPC_SETLISTENTOID__LONG_BOOL_,RPC_SETPERFORMANCECOUNTER__INT_BOOL_,RPC_SETPERFORMANCEANIMATION__STRING_BOOL_,RPC_SETSHOCKWOUNDS__INT_BOOL_,RPC_ADDSHOCKWOUNDS__INT_BOOL_,RPC_SETTARGETID__LONG_BOOL_,RPC_SETBANKCREDITS__INT_BOOL_,RPC_ADDBUFF__BUFF_,RPC_REMOVEBUFF__INT_,RPC_REMOVEBUFF__BUFF_,RPC_REMOVESTATEBUFF__LONG_,RPC_CLEARBUFFS__BOOL_,RPC_ADDWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_,RPC_REMOVEWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_,RPC_SENDBUFFSTO__CREATUREOBJECT_,RPC_GETBUFF__INT_,RPC_GETSKILLMODFROMBUFFS__STRING_,RPC_ADDDOTSTATE__LONG_LONG_INT_BYTE_INT_FLOAT_INT_,RPC_HEALDOT__LONG_INT_,RPC_CLEARDOTS__,RPC_HASBUFF__INT_,RPC_NOTIFYSELFPOSITIONUPDATE__,RPC_NOTIFYPOSTURECHANGE__INT_,RPC_SETLEVEL__INT_,RPC_UPDATETODATABASEALLOBJECTS__BOOL_,RPC_ISRESUSCITABLE__,RPC_ADDBANKCREDITS__INT_BOOL_,RPC_ADDCASHCREDITS__INT_BOOL_,RPC_SUBTRACTBANKCREDITS__INT_,RPC_SUBTRACTCASHCREDITS__INT_,RPC_VERIFYCASHCREDITS__INT_,RPC_VERIFYBANKCREDITS__INT_,RPC_ISDANCING__,RPC_ISPLAYINGMUSIC__,RPC_STOPENTERTAINING__,RPC_ISENTERTAINING__,RPC_SETCASHCREDITS__INT_BOOL_,RPC_SETTERRAINNEGOTIATION__FLOAT_BOOL_,RPC_ADDSKILL__STRING_BOOL_,RPC_REMOVESKILL__STRING_BOOL_,RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_,RPC_REMOVESKILLMOD__INT_STRING_INT_BOOL_,RPC_REMOVEALLSKILLMODSOFTYPE__INT_BOOL_,RPC_UPDATEGROUPINVITERID__LONG_BOOL_,RPC_UPDATEGROUP__GROUPOBJECT_BOOL_,RPC_ENQUEUECOMMAND__INT_INT_LONG_UNICODESTRING_INT_,RPC_SETMOOD__BYTE_BOOL_,RPC_SETMOODSTRING__STRING_BOOL_,RPC_DELETEQUEUEACTION__INT_,RPC_SETSTATE__LONG_BOOL_,RPC_CLEARSTATE__LONG_BOOL_,RPC_SETCONTROLDEVICE__CONTROLDEVICE_,RPC_SETCREATURELINK__CREATUREOBJECT_BOOL_,RPC_EXECUTEOBJECTCONTROLLERACTION__INT_,RPC_EXECUTEOBJECTCONTROLLERACTION__INT_LONG_UNICODESTRING_,RPC_ISATTACKABLEBY__CREATUREOBJECT_,RPC_ISATTACKABLEBY__TANGIBLEOBJECT_,RPC_ISHEALABLEBY__CREATUREOBJECT_,RPC_ISINBOUNTYMISSION__CREATUREOBJECT_CREATUREOBJECT_,RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_,RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_,RPC_SENDMESSAGE__BASEPACKET_,RPC_SENDEXECUTECONSOLECOMMAND__STRING_,RPC_ISAGGRESSIVETO__CREATUREOBJECT_,RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_,RPC_NOTIFYOBJECTKILLOBSERVERS__TANGIBLEOBJECT_,RPC_NOTIFYLOADFROMDATABASE__,RPC_SETFACTIONRANK__INT_BOOL_,RPC_GETFIRSTNAME__,RPC_GETLASTNAME__,RPC_ISONLINE__,RPC_CANTREATINJURIES__,RPC_CANTREATSTATES__,RPC_CANTREATWOUNDS__,RPC_CANTREATCONDITIONS__,RPC_GETPLAYEROBJECT__,RPC_GETACTOROBJECT__,RPC_ISLISTENING__,RPC_ISWATCHING__,RPC_SETCLIENT__ZONECLIENTSESSION_,RPC_DISMOUNT__,RPC_CALCULATEBFRATIO__,RPC_SETDIZZIEDSTATE__INT_,RPC_SETRALLIEDSTATE__INT_,RPC_SETAIMINGSTATE__INT_,RPC_SETCOVERSTATE__INT_,RPC_SETBERSERKEDSTATE__INT_,RPC_SETSTUNNEDSTATE__INT_,RPC_SETBLINDEDSTATE__INT_,RPC_SETINTIMIDATEDSTATE__INT_INT_,RPC_SETSNAREDSTATE__INT_,RPC_SETROOTEDSTATE__INT_,RPC_SETNEXTATTACKDELAY__INT_INT_,RPC_SETMEDITATESTATE__,RPC_ACTIVATEHAMREGENERATION__,RPC_ACTIVATEPASSIVEWOUNDREGENERATION__,RPC_ACTIVATESTATERECOVERY__,RPC_UPDATETIMEOFDEATH__,RPC_HASATTACKDELAY__,RPC_REMOVEATTACKDELAY__,RPC_HASSPICE__,RPC_UPDATELASTSUCCESSFULCOMBATACTION__,RPC_UPDATEKNOCKDOWNRECOVERY__,RPC_QUEUEDIZZYFALLEVENT__,RPC_UPDATELASTKNOCKDOWN__,RPC_CHECKKNOCKDOWNRECOVERY__,RPC_CHECKLASTKNOCKDOWN__,RPC_UPDATEPOSTUREDOWNRECOVERY__,RPC_UPDATEPOSTUREUPRECOVERY__,RPC_CHECKPOSTUREDOWNRECOVERY__,RPC_GETSCREENPLAYSTATE__STRING_,RPC_SETSCREENPLAYSTATE__STRING_LONG_,RPC_CHECKPOSTUREUPRECOVERY__,RPC_UPDATECOOLDOWNTIMER__STRING_INT_,RPC_CHECKCOOLDOWNRECOVERY__STRING_,RPC_ADDCOOLDOWN__STRING_INT_,RPC_DOANIMATION__STRING_,RPC_DOCOMBATANIMATION__CREATUREOBJECT_INT_BYTE_BYTE_,RPC_PLAYEFFECT__STRING_STRING_,RPC_PLAYEFFECT__STRING_,RPC_ACTIVATEQUEUEACTION__,RPC_ACTIVATEIMMEDIATEACTION__,RPC_GETCREATURENAME__,RPC_ISGROUPED__,RPC_GETBANKCREDITS__,RPC_GETCASHCREDITS__,RPC_GETBASEHAM__INT_,RPC_GETWOUNDS__INT_,RPC_GETHAM__INT_,RPC_GETMAXHAM__INT_,RPC_GETENCUMBRANCE__INT_,RPC_GETPOSTURE__,RPC_GETLOCOMOTION__,RPC_GETFACTIONRANK__,RPC_GETLINKEDCREATURE__,RPC_GETCREATURELINKID__,RPC_GETSHOCKWOUNDS__,RPC_GETWATCHTOID__,RPC_GETSTATEBITMASK__,RPC_HASSTATE__LONG_,RPC_HASSTATES__,RPC_GETLISTENID__,RPC_GETACCELERATIONMULTIPLIERBASE__,RPC_GETACCELERATIONMULTIPLIERMOD__,RPC_GETSPEEDMULTIPLIERBASE__,RPC_GETSPEEDMULTIPLIERMOD__,RPC_GETCURRENTSPEED__,RPC_GETRUNSPEED__,RPC_GETWALKSPEED__,RPC_GETTURNSCALE__,RPC_GETTERRAINNEGOTIATION__,RPC_GETRUNACCELERATION__,RPC_GETWALKACCELERATION__,RPC_GETPERFORMANCEANIMATION__,RPC_GETMOODSTRING__,RPC_GETWEAPONID__,RPC_GETWEAPON__,RPC_GETGUILDOBJECT__,RPC_GETGUILDID__,RPC_ISINGUILD__,RPC_SETGUILDOBJECT__GUILDOBJECT_,RPC_GETGROUPID__,RPC_GETGROUPINVITERID__,RPC_GETGROUP__,RPC_GETGROUPINVITECOUNTER__,RPC_GETTARGETID__,RPC_GETMOODID__,RPC_GETSLOPEMODPERCENT__,RPC_GETPERFORMANCECOUNTER__,RPC_GETINSTRUMENTID__,RPC_GETFROZEN__,RPC_GETHEIGHT__,RPC_GETSPECIES__,RPC_GETSPECIESNAME__,RPC_GETGENDER__,RPC_GETSKILLMOD__STRING_,RPC_HASSKILL__STRING_,RPC_SETWATCHTOID__LONG_,RPC_ISCREATUREOBJECT__,RPC_ISNEXTACTIONPAST__,RPC_ISTRAINERCREATURE__,RPC_ISSWIMMING__,RPC_GETCLIENT__,RPC_ISRIDINGMOUNT__,RPC_GETCONTROLDEVICE__,RPC_GETSWIMHEIGHT__,RPC_ISINCAPACITATED__,RPC_ISDEAD__,RPC_ISKNOCKEDDOWN__,RPC_ISKNEELING__,RPC_ISPRONE__,RPC_ISSTANDING__,RPC_ISSITTING__,RPC_ISSKILLANIMATING__,RPC_ISRALLIED__,RPC_ISINCOMBAT__,RPC_ISDIZZIED__,RPC_ISBERSERKED__,RPC_ISSTUNNED__,RPC_ISBLINDED__,RPC_ISINTIMIDATED__,RPC_ISSNARED__,RPC_ISIMMOBILIZED__,RPC_ISROOTED__,RPC_ISFROZEN__,RPC_ISDISEASED__,RPC_ISPOISONED__,RPC_ISBLEEDING__,RPC_ISONFIRE__,RPC_ISMOUNTED__,RPC_ISRIDINGCREATURE__,RPC_ISPEACED__,RPC_ISMEDITATING__,RPC_ISAIMING__,RPC_ISINCOVER__,RPC_ISRUNNING__,RPC_ISNONPLAYERCREATUREOBJECT__,RPC_ISCREATURE__,RPC_ISPLAYERCREATURE__,RPC_ISAIACTOR__,RPC_ISINFORMANTCREATURE__,RPC_GETCURRENTCAMP__,RPC_GETCURRENTWEATHER__,RPC_SETCURRENTWEATHER__BYTE_,RPC_GETCURRENTWIND__,RPC_SETCURRENTWIND__BYTE_,RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_,RPC_FILLATTRIBUTELIST__ATTRIBUTELISTMESSAGE_CREATUREOBJECT_,RPC_DESTROYOBJECTFROMWORLD__BOOL_,RPC_ISINVISIBLE__,RPC_SETINVISIBLE__BOOL_,RPC_CALCULATECOSTADJUSTMENT__BYTE_FLOAT_};

CreatureObject::CreatureObject() : TangibleObject(DummyConstructorParameter::instance()) {
	CreatureObjectImplementation* _implementation = new CreatureObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("CreatureObject");
}

CreatureObject::CreatureObject(DummyConstructorParameter* param) : TangibleObject(param) {
	_setClassName("CreatureObject");
}

CreatureObject::~CreatureObject() {
}



void CreatureObject::initializeMembers() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEMEMBERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeMembers();
}

void CreatureObject::createChildObjects() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATECHILDOBJECTS__);

		method.executeWithVoidReturn();
	} else
		_implementation->createChildObjects();
}

void CreatureObject::loadTemplateData(SharedObjectTemplate* templateData) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->loadTemplateData(templateData);
}

void CreatureObject::initializeTransientMembers() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeTransientMembers();
}

void CreatureObject::clearQueueAction(unsigned int actioncntr, float timer, unsigned int tab1, unsigned int tab2) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARQUEUEACTION__INT_FLOAT_INT_INT_);
		method.addUnsignedIntParameter(actioncntr);
		method.addFloatParameter(timer);
		method.addUnsignedIntParameter(tab1);
		method.addUnsignedIntParameter(tab2);

		method.executeWithVoidReturn();
	} else
		_implementation->clearQueueAction(actioncntr, timer, tab1, tab2);
}

void CreatureObject::sendBaselinesTo(SceneObject* player) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendBaselinesTo(player);
}

void CreatureObject::sendToOwner(bool doClose) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTOOWNER__BOOL_);
		method.addBooleanParameter(doClose);

		method.executeWithVoidReturn();
	} else
		_implementation->sendToOwner(doClose);
}

void CreatureObject::sendTo(SceneObject* player, bool doClose) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTO__SCENEOBJECT_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(doClose);

		method.executeWithVoidReturn();
	} else
		_implementation->sendTo(player, doClose);
}

void CreatureObject::sendSystemMessage(const String& message) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSYSTEMMESSAGE__STRING_);
		method.addAsciiParameter(message);

		method.executeWithVoidReturn();
	} else
		_implementation->sendSystemMessage(message);
}

void CreatureObject::playMusicMessage(const String& file) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PLAYMUSICMESSAGE__STRING_);
		method.addAsciiParameter(file);

		method.executeWithVoidReturn();
	} else
		_implementation->playMusicMessage(file);
}

void CreatureObject::sendNewbieTutorialRequest(const String& request) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDNEWBIETUTORIALREQUEST__STRING_);
		method.addAsciiParameter(request);

		method.executeWithVoidReturn();
	} else
		_implementation->sendNewbieTutorialRequest(request);
}

void CreatureObject::sendNewbieTutorialEnableHudElement(const String& ui, bool enable) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDNEWBIETUTORIALENABLEHUDELEMENT__STRING_BOOL_);
		method.addAsciiParameter(ui);
		method.addBooleanParameter(enable);

		method.executeWithVoidReturn();
	} else
		_implementation->sendNewbieTutorialEnableHudElement(ui, enable);
}

void CreatureObject::sendOpenHolocronToPageMessage() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDOPENHOLOCRONTOPAGEMESSAGE__);

		method.executeWithVoidReturn();
	} else
		_implementation->sendOpenHolocronToPageMessage();
}

void CreatureObject::sendSystemMessage(UnicodeString& message) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSYSTEMMESSAGE__UNICODESTRING_);
		method.addUnicodeParameter(message);

		method.executeWithVoidReturn();
	} else
		_implementation->sendSystemMessage(message);
}

void CreatureObject::sendSystemMessage(StringIdChatParameter& stringid) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->sendSystemMessage(stringid);
}

void CreatureObject::sendSlottedObjectsTo(SceneObject* player) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSLOTTEDOBJECTSTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendSlottedObjectsTo(player);
}

void CreatureObject::setCombatState() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMBATSTATE__);

		method.executeWithVoidReturn();
	} else
		_implementation->setCombatState();
}

void CreatureObject::clearCombatState(bool clearDefenders) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCOMBATSTATE__BOOL_);
		method.addBooleanParameter(clearDefenders);

		method.executeWithVoidReturn();
	} else
		_implementation->clearCombatState(clearDefenders);
}

void CreatureObject::setPosture(int newPosture, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPOSTURE__INT_BOOL_);
		method.addSignedIntParameter(newPosture);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setPosture(newPosture, notifyClient);
}

float CreatureObject::calculateSpeed() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATESPEED__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->calculateSpeed();
}

void CreatureObject::updateLocomotion() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELOCOMOTION__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateLocomotion();
}

void CreatureObject::setHeight(float heigh, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHEIGHT__FLOAT_BOOL_);
		method.addFloatParameter(heigh);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setHeight(heigh, notifyClient);
}

void CreatureObject::setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCELERATIONMULTIPLIERBASE__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierBase);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setAccelerationMultiplierBase(newMultiplierBase, notifyClient);
}

void CreatureObject::setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierMod);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setAccelerationMultiplierMod(newMultiplierMod, notifyClient);
}

void CreatureObject::setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPEEDMULTIPLIERBASE__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierBase);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setSpeedMultiplierBase(newMultiplierBase, notifyClient);
}

void CreatureObject::setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPEEDMULTIPLIERMOD__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierMod);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setSpeedMultiplierMod(newMultiplierMod, notifyClient);
}

void CreatureObject::setTurnScale(float newMultiplierMod, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTURNSCALE__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierMod);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setTurnScale(newMultiplierMod, notifyClient);
}

void CreatureObject::setRunSpeed(float newSpeed, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRUNSPEED__FLOAT_BOOL_);
		method.addFloatParameter(newSpeed);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setRunSpeed(newSpeed, notifyClient);
}

void CreatureObject::setCurrentSpeed(float newSpeed) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCURRENTSPEED__FLOAT_);
		method.addFloatParameter(newSpeed);

		method.executeWithVoidReturn();
	} else
		_implementation->setCurrentSpeed(newSpeed);
}

void CreatureObject::setHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setHAM(type, value, notifyClient);
}

int CreatureObject::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addFloatParameter(damage);
		method.addBooleanParameter(destroy);
		method.addBooleanParameter(notifyClient);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->inflictDamage(attacker, damageType, damage, destroy, notifyClient);
}

int CreatureObject::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addFloatParameter(damage);
		method.addBooleanParameter(destroy);
		method.addAsciiParameter(xp);
		method.addBooleanParameter(notifyClient);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient);
}

bool CreatureObject::hasDamage(int attribute) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASDAMAGE__INT_);
		method.addSignedIntParameter(attribute);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasDamage(attribute);
}

int CreatureObject::healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_);
		method.addObjectParameter(healer);
		method.addSignedIntParameter(damageType);
		method.addSignedIntParameter(damage);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(notifyObservers);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->healDamage(healer, damageType, damage, notifyClient, notifyObservers);
}

int CreatureObject::healWound(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALWOUND__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_);
		method.addObjectParameter(healer);
		method.addSignedIntParameter(damageType);
		method.addSignedIntParameter(damage);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(notifyObservers);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->healWound(healer, damageType, damage, notifyClient, notifyObservers);
}

void CreatureObject::setBaseHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBASEHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setBaseHAM(type, value, notifyClient);
}

void CreatureObject::setWounds(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWOUNDS__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setWounds(type, value, notifyClient);
}

int CreatureObject::addWounds(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDWOUNDS__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->addWounds(type, value, notifyClient);
}

void CreatureObject::setMaxHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setMaxHAM(type, value, notifyClient);
}

void CreatureObject::addMaxHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDMAXHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addMaxHAM(type, value, notifyClient);
}

void CreatureObject::setEncumbrance(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETENCUMBRANCE__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setEncumbrance(type, value, notifyClient);
}

void CreatureObject::addEncumbrance(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDENCUMBRANCE__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addEncumbrance(type, value, notifyClient);
}

void CreatureObject::setWeapon(WeaponObject* weao, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWEAPON__WEAPONOBJECT_BOOL_);
		method.addObjectParameter(weao);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setWeapon(weao, notifyClient);
}

int CreatureObject::notifyObjectInserted(SceneObject* object) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->notifyObjectInserted(object);
}

int CreatureObject::notifyObjectRemoved(SceneObject* object) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->notifyObjectRemoved(object);
}

void CreatureObject::setInstrumentID(int instrumentid, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINSTRUMENTID__INT_BOOL_);
		method.addSignedIntParameter(instrumentid);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setInstrumentID(instrumentid, notifyClient);
}

void CreatureObject::setListenToID(unsigned long long id, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLISTENTOID__LONG_BOOL_);
		method.addUnsignedLongParameter(id);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setListenToID(id, notifyClient);
}

void CreatureObject::setPerformanceCounter(int counter, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPERFORMANCECOUNTER__INT_BOOL_);
		method.addSignedIntParameter(counter);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setPerformanceCounter(counter, notifyClient);
}

void CreatureObject::setPerformanceAnimation(const String& animation, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPERFORMANCEANIMATION__STRING_BOOL_);
		method.addAsciiParameter(animation);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setPerformanceAnimation(animation, notifyClient);
}

void CreatureObject::setShockWounds(int newShock, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSHOCKWOUNDS__INT_BOOL_);
		method.addSignedIntParameter(newShock);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setShockWounds(newShock, notifyClient);
}

void CreatureObject::addShockWounds(int shockToAdd, bool notiyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSHOCKWOUNDS__INT_BOOL_);
		method.addSignedIntParameter(shockToAdd);
		method.addBooleanParameter(notiyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addShockWounds(shockToAdd, notiyClient);
}

void CreatureObject::setTargetID(unsigned long long targetID, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTARGETID__LONG_BOOL_);
		method.addUnsignedLongParameter(targetID);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setTargetID(targetID, notifyClient);
}

void CreatureObject::setBankCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBANKCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setBankCredits(credits, notifyClient);
}

void CreatureObject::addBuff(Buff* buff) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDBUFF__BUFF_);
		method.addObjectParameter(buff);

		method.executeWithVoidReturn();
	} else
		_implementation->addBuff(buff);
}

bool CreatureObject::removeBuff(unsigned int buffcrc) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEBUFF__INT_);
		method.addUnsignedIntParameter(buffcrc);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->removeBuff(buffcrc);
}

void CreatureObject::removeBuff(Buff* buff) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEBUFF__BUFF_);
		method.addObjectParameter(buff);

		method.executeWithVoidReturn();
	} else
		_implementation->removeBuff(buff);
}

bool CreatureObject::removeStateBuff(unsigned long long state) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESTATEBUFF__LONG_);
		method.addUnsignedLongParameter(state);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->removeStateBuff(state);
}

void CreatureObject::clearBuffs(bool updateclient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARBUFFS__BOOL_);
		method.addBooleanParameter(updateclient);

		method.executeWithVoidReturn();
	} else
		_implementation->clearBuffs(updateclient);
}

void CreatureObject::addWearableObject(TangibleObject* object, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_);
		method.addObjectParameter(object);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addWearableObject(object, notifyClient);
}

void CreatureObject::removeWearableObject(TangibleObject* object, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_);
		method.addObjectParameter(object);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeWearableObject(object, notifyClient);
}

WearablesDeltaVector* CreatureObject::getWearablesDeltaVector() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getWearablesDeltaVector();
}

void CreatureObject::sendBuffsTo(CreatureObject* creature) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBUFFSTO__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		_implementation->sendBuffsTo(creature);
}

BuffList* CreatureObject::getBuffList() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getBuffList();
}

Buff* CreatureObject::getBuff(unsigned int buffcrc) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBUFF__INT_);
		method.addUnsignedIntParameter(buffcrc);

		return static_cast<Buff*>(method.executeWithObjectReturn());
	} else
		return _implementation->getBuff(buffcrc);
}

long long CreatureObject::getSkillModFromBuffs(const String& skillMod) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSKILLMODFROMBUFFS__STRING_);
		method.addAsciiParameter(skillMod);

		return method.executeWithSignedLongReturn();
	} else
		return _implementation->getSkillModFromBuffs(skillMod);
}

int CreatureObject::addDotState(unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDOTSTATE__LONG_LONG_INT_BYTE_INT_FLOAT_INT_);
		method.addUnsignedLongParameter(dotType);
		method.addUnsignedLongParameter(objectID);
		method.addUnsignedIntParameter(strength);
		method.addByteParameter(type);
		method.addUnsignedIntParameter(duration);
		method.addFloatParameter(potency);
		method.addUnsignedIntParameter(defense);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->addDotState(dotType, objectID, strength, type, duration, potency, defense);
}

bool CreatureObject::healDot(unsigned long long dotType, int reduction) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALDOT__LONG_INT_);
		method.addUnsignedLongParameter(dotType);
		method.addSignedIntParameter(reduction);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->healDot(dotType, reduction);
}

void CreatureObject::clearDots() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARDOTS__);

		method.executeWithVoidReturn();
	} else
		_implementation->clearDots();
}

DamageOverTimeList* CreatureObject::getDamageOverTimeList() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getDamageOverTimeList();
}

bool CreatureObject::hasBuff(unsigned int buffcrc) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASBUFF__INT_);
		method.addUnsignedIntParameter(buffcrc);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasBuff(buffcrc);
}

void CreatureObject::notifySelfPositionUpdate() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYSELFPOSITIONUPDATE__);

		method.executeWithVoidReturn();
	} else
		_implementation->notifySelfPositionUpdate();
}

void CreatureObject::notifyPostureChange(int newPosture) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYPOSTURECHANGE__INT_);
		method.addSignedIntParameter(newPosture);

		method.executeWithVoidReturn();
	} else
		_implementation->notifyPostureChange(newPosture);
}

void CreatureObject::setLevel(int level) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLEVEL__INT_);
		method.addSignedIntParameter(level);

		method.executeWithVoidReturn();
	} else
		_implementation->setLevel(level);
}

void CreatureObject::updateToDatabaseAllObjects(bool startTask) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATETODATABASEALLOBJECTS__BOOL_);
		method.addBooleanParameter(startTask);

		method.executeWithVoidReturn();
	} else
		_implementation->updateToDatabaseAllObjects(startTask);
}

bool CreatureObject::isResuscitable() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRESUSCITABLE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isResuscitable();
}

void CreatureObject::addBankCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDBANKCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addBankCredits(credits, notifyClient);
}

void CreatureObject::addCashCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCASHCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addCashCredits(credits, notifyClient);
}

void CreatureObject::subtractBankCredits(int credits) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SUBTRACTBANKCREDITS__INT_);
		method.addSignedIntParameter(credits);

		method.executeWithVoidReturn();
	} else
		_implementation->subtractBankCredits(credits);
}

void CreatureObject::subtractCashCredits(int credits) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SUBTRACTCASHCREDITS__INT_);
		method.addSignedIntParameter(credits);

		method.executeWithVoidReturn();
	} else
		_implementation->subtractCashCredits(credits);
}

bool CreatureObject::verifyCashCredits(int credits) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VERIFYCASHCREDITS__INT_);
		method.addSignedIntParameter(credits);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->verifyCashCredits(credits);
}

bool CreatureObject::verifyBankCredits(int credits) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VERIFYBANKCREDITS__INT_);
		method.addSignedIntParameter(credits);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->verifyBankCredits(credits);
}

bool CreatureObject::isDancing() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDANCING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDancing();
}

bool CreatureObject::isPlayingMusic() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLAYINGMUSIC__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPlayingMusic();
}

void CreatureObject::stopEntertaining() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPENTERTAINING__);

		method.executeWithVoidReturn();
	} else
		_implementation->stopEntertaining();
}

bool CreatureObject::isEntertaining() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISENTERTAINING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isEntertaining();
}

void CreatureObject::setCashCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCASHCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setCashCredits(credits, notifyClient);
}

void CreatureObject::setTerrainNegotiation(float value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTERRAINNEGOTIATION__FLOAT_BOOL_);
		method.addFloatParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setTerrainNegotiation(value, notifyClient);
}

void CreatureObject::addSkill(Skill* skill, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->addSkill(skill, notifyClient);
}

void CreatureObject::addSkill(const String& skill, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILL__STRING_BOOL_);
		method.addAsciiParameter(skill);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addSkill(skill, notifyClient);
}

void CreatureObject::removeSkill(Skill* skill, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->removeSkill(skill, notifyClient);
}

void CreatureObject::removeSkill(const String& skill, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESKILL__STRING_BOOL_);
		method.addAsciiParameter(skill);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeSkill(skill, notifyClient);
}

void CreatureObject::addSkillMod(const int modType, const String& skillMod, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_);
		method.addSignedIntParameter(modType);
		method.addAsciiParameter(skillMod);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addSkillMod(modType, skillMod, value, notifyClient);
}

void CreatureObject::removeSkillMod(const int modType, const String& skillMod, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESKILLMOD__INT_STRING_INT_BOOL_);
		method.addSignedIntParameter(modType);
		method.addAsciiParameter(skillMod);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeSkillMod(modType, skillMod, value, notifyClient);
}

void CreatureObject::removeAllSkillModsOfType(const int modType, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEALLSKILLMODSOFTYPE__INT_BOOL_);
		method.addSignedIntParameter(modType);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeAllSkillModsOfType(modType, notifyClient);
}

void CreatureObject::updateGroupInviterID(unsigned long long id, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEGROUPINVITERID__LONG_BOOL_);
		method.addUnsignedLongParameter(id);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->updateGroupInviterID(id, notifyClient);
}

void CreatureObject::updateGroup(GroupObject* group, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEGROUP__GROUPOBJECT_BOOL_);
		method.addObjectParameter(group);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->updateGroup(group, notifyClient);
}

void CreatureObject::enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENQUEUECOMMAND__INT_INT_LONG_UNICODESTRING_INT_);
		method.addUnsignedIntParameter(actionCRC);
		method.addUnsignedIntParameter(actionCount);
		method.addUnsignedLongParameter(targetID);
		method.addUnicodeParameter(arguments);
		method.addSignedIntParameter(priority);

		method.executeWithVoidReturn();
	} else
		_implementation->enqueueCommand(actionCRC, actionCount, targetID, arguments, priority);
}

void CreatureObject::setMood(byte moodID, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMOOD__BYTE_BOOL_);
		method.addByteParameter(moodID);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setMood(moodID, notifyClient);
}

void CreatureObject::setMoodString(const String& animation, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMOODSTRING__STRING_BOOL_);
		method.addAsciiParameter(animation);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setMoodString(animation, notifyClient);
}

void CreatureObject::deleteQueueAction(unsigned int actionCount) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DELETEQUEUEACTION__INT_);
		method.addUnsignedIntParameter(actionCount);

		method.executeWithVoidReturn();
	} else
		_implementation->deleteQueueAction(actionCount);
}

bool CreatureObject::setState(unsigned long long state, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTATE__LONG_BOOL_);
		method.addUnsignedLongParameter(state);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->setState(state, notifyClient);
}

bool CreatureObject::clearState(unsigned long long state, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARSTATE__LONG_BOOL_);
		method.addUnsignedLongParameter(state);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->clearState(state, notifyClient);
}

void CreatureObject::setControlDevice(ControlDevice* device) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONTROLDEVICE__CONTROLDEVICE_);
		method.addObjectParameter(device);

		method.executeWithVoidReturn();
	} else
		_implementation->setControlDevice(device);
}

void CreatureObject::setCreatureLink(CreatureObject* object, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCREATURELINK__CREATUREOBJECT_BOOL_);
		method.addObjectParameter(object);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setCreatureLink(object, notifyClient);
}

void CreatureObject::executeObjectControllerAction(unsigned int actionCRC) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_EXECUTEOBJECTCONTROLLERACTION__INT_);
		method.addUnsignedIntParameter(actionCRC);

		method.executeWithVoidReturn();
	} else
		_implementation->executeObjectControllerAction(actionCRC);
}

void CreatureObject::executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_EXECUTEOBJECTCONTROLLERACTION__INT_LONG_UNICODESTRING_);
		method.addUnsignedIntParameter(actionCRC);
		method.addUnsignedLongParameter(targetID);
		method.addUnicodeParameter(args);

		method.executeWithVoidReturn();
	} else
		_implementation->executeObjectControllerAction(actionCRC, targetID, args);
}

bool CreatureObject::isAttackableBy(CreatureObject* object) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isAttackableBy(object);
}

bool CreatureObject::isAttackableBy(TangibleObject* attacker) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__TANGIBLEOBJECT_);
		method.addObjectParameter(attacker);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isAttackableBy(attacker);
}

bool CreatureObject::isHealableBy(CreatureObject* object) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHEALABLEBY__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isHealableBy(object);
}

bool CreatureObject::isInBountyMission(CreatureObject* bountyHunter, CreatureObject* target) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINBOUNTYMISSION__CREATUREOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(bountyHunter);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInBountyMission(bountyHunter, target);
}

void CreatureObject::sendConversationStartTo(SceneObject* player) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendConversationStartTo(player);
}

void CreatureObject::selectConversationOption(int option, SceneObject* obj) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_);
		method.addSignedIntParameter(option);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		_implementation->selectConversationOption(option, obj);
}

void CreatureObject::sendMessage(BasePacket* msg) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDMESSAGE__BASEPACKET_);
		method.addObjectParameter(msg);

		method.executeWithVoidReturn();
	} else
		_implementation->sendMessage(msg);
}

void CreatureObject::sendExecuteConsoleCommand(const String& command) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDEXECUTECONSOLECOMMAND__STRING_);
		method.addAsciiParameter(command);

		method.executeWithVoidReturn();
	} else
		_implementation->sendExecuteConsoleCommand(command);
}

bool CreatureObject::isAggressiveTo(CreatureObject* object) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAGGRESSIVETO__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isAggressiveTo(object);
}

int CreatureObject::notifyObjectDestructionObservers(TangibleObject* attacker, int condition) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(condition);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->notifyObjectDestructionObservers(attacker, condition);
}

int CreatureObject::notifyObjectKillObservers(TangibleObject* killer) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTKILLOBSERVERS__TANGIBLEOBJECT_);
		method.addObjectParameter(killer);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->notifyObjectKillObservers(killer);
}

void CreatureObject::notifyLoadFromDatabase() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else
		_implementation->notifyLoadFromDatabase();
}

void CreatureObject::setFactionRank(int rank, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFACTIONRANK__INT_BOOL_);
		method.addSignedIntParameter(rank);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setFactionRank(rank, notifyClient);
}

String CreatureObject::getFirstName() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFIRSTNAME__);

		String _return_getFirstName;
		method.executeWithAsciiReturn(_return_getFirstName);
		return _return_getFirstName;
	} else
		return _implementation->getFirstName();
}

String CreatureObject::getLastName() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTNAME__);

		String _return_getLastName;
		method.executeWithAsciiReturn(_return_getLastName);
		return _return_getLastName;
	} else
		return _implementation->getLastName();
}

bool CreatureObject::isOnline() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONLINE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOnline();
}

bool CreatureObject::canTreatInjuries() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATINJURIES__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canTreatInjuries();
}

bool CreatureObject::canTreatStates() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATSTATES__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canTreatStates();
}

bool CreatureObject::canTreatWounds() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATWOUNDS__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canTreatWounds();
}

bool CreatureObject::canTreatConditions() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATCONDITIONS__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canTreatConditions();
}

PlayerObject* CreatureObject::getPlayerObject() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLAYEROBJECT__);

		return static_cast<PlayerObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getPlayerObject();
}

AiActor* CreatureObject::getActorObject() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTOROBJECT__);

		return static_cast<AiActor*>(method.executeWithObjectReturn());
	} else
		return _implementation->getActorObject();
}

bool CreatureObject::isListening() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLISTENING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isListening();
}

bool CreatureObject::isWatching() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISWATCHING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isWatching();
}

void CreatureObject::setClient(ZoneClientSession* cli) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCLIENT__ZONECLIENTSESSION_);
		method.addObjectParameter(cli);

		method.executeWithVoidReturn();
	} else
		_implementation->setClient(cli);
}

void CreatureObject::dismount() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DISMOUNT__);

		method.executeWithVoidReturn();
	} else
		_implementation->dismount();
}

float CreatureObject::calculateBFRatio() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEBFRATIO__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->calculateBFRatio();
}

void CreatureObject::setDizziedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDIZZIEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setDizziedState(durationSeconds);
}

void CreatureObject::setRalliedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRALLIEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setRalliedState(durationSeconds);
}

void CreatureObject::setAimingState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAIMINGSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setAimingState(durationSeconds);
}

void CreatureObject::setCoverState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOVERSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setCoverState(durationSeconds);
}

void CreatureObject::setBerserkedState(unsigned int duration) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBERSERKEDSTATE__INT_);
		method.addUnsignedIntParameter(duration);

		method.executeWithVoidReturn();
	} else
		_implementation->setBerserkedState(duration);
}

void CreatureObject::setStunnedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTUNNEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setStunnedState(durationSeconds);
}

void CreatureObject::setBlindedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBLINDEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setBlindedState(durationSeconds);
}

void CreatureObject::setIntimidatedState(unsigned int mod, int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINTIMIDATEDSTATE__INT_INT_);
		method.addUnsignedIntParameter(mod);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setIntimidatedState(mod, durationSeconds);
}

void CreatureObject::setSnaredState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSNAREDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setSnaredState(durationSeconds);
}

void CreatureObject::setRootedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETROOTEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setRootedState(durationSeconds);
}

bool CreatureObject::setNextAttackDelay(unsigned int mod, int del) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNEXTATTACKDELAY__INT_INT_);
		method.addUnsignedIntParameter(mod);
		method.addSignedIntParameter(del);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->setNextAttackDelay(mod, del);
}

void CreatureObject::setMeditateState() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMEDITATESTATE__);

		method.executeWithVoidReturn();
	} else
		_implementation->setMeditateState();
}

void CreatureObject::activateHAMRegeneration() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEHAMREGENERATION__);

		method.executeWithVoidReturn();
	} else
		_implementation->activateHAMRegeneration();
}

void CreatureObject::activatePassiveWoundRegeneration() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEPASSIVEWOUNDREGENERATION__);

		method.executeWithVoidReturn();
	} else
		_implementation->activatePassiveWoundRegeneration();
}

void CreatureObject::activateStateRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATESTATERECOVERY__);

		method.executeWithVoidReturn();
	} else
		_implementation->activateStateRecovery();
}

void CreatureObject::updateTimeOfDeath() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATETIMEOFDEATH__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateTimeOfDeath();
}

bool CreatureObject::hasAttackDelay() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASATTACKDELAY__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasAttackDelay();
}

void CreatureObject::removeAttackDelay() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEATTACKDELAY__);

		method.executeWithVoidReturn();
	} else
		_implementation->removeAttackDelay();
}

CooldownTimerMap* CreatureObject::getCooldownTimerMap() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getCooldownTimerMap();
}

bool CreatureObject::hasSpice() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSPICE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSpice();
}

void CreatureObject::updateLastSuccessfulCombatAction() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTSUCCESSFULCOMBATACTION__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateLastSuccessfulCombatAction();
}

void CreatureObject::updateKnockdownRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEKNOCKDOWNRECOVERY__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateKnockdownRecovery();
}

void CreatureObject::queueDizzyFallEvent() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_QUEUEDIZZYFALLEVENT__);

		method.executeWithVoidReturn();
	} else
		_implementation->queueDizzyFallEvent();
}

void CreatureObject::updateLastKnockdown() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTKNOCKDOWN__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateLastKnockdown();
}

bool CreatureObject::checkKnockdownRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKKNOCKDOWNRECOVERY__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->checkKnockdownRecovery();
}

bool CreatureObject::checkLastKnockdown() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKLASTKNOCKDOWN__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->checkLastKnockdown();
}

void CreatureObject::updatePostureDownRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPOSTUREDOWNRECOVERY__);

		method.executeWithVoidReturn();
	} else
		_implementation->updatePostureDownRecovery();
}

void CreatureObject::updatePostureUpRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPOSTUREUPRECOVERY__);

		method.executeWithVoidReturn();
	} else
		_implementation->updatePostureUpRecovery();
}

bool CreatureObject::checkPostureDownRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKPOSTUREDOWNRECOVERY__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->checkPostureDownRecovery();
}

unsigned long long CreatureObject::getScreenPlayState(const String& screenPlay) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSCREENPLAYSTATE__STRING_);
		method.addAsciiParameter(screenPlay);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getScreenPlayState(screenPlay);
}

void CreatureObject::setScreenPlayState(const String& screenPlay, unsigned long long state) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSCREENPLAYSTATE__STRING_LONG_);
		method.addAsciiParameter(screenPlay);
		method.addUnsignedLongParameter(state);

		method.executeWithVoidReturn();
	} else
		_implementation->setScreenPlayState(screenPlay, state);
}

bool CreatureObject::checkPostureUpRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKPOSTUREUPRECOVERY__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->checkPostureUpRecovery();
}

void CreatureObject::updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATECOOLDOWNTIMER__STRING_INT_);
		method.addAsciiParameter(coooldownTimer);
		method.addUnsignedIntParameter(miliSecondsToAdd);

		method.executeWithVoidReturn();
	} else
		_implementation->updateCooldownTimer(coooldownTimer, miliSecondsToAdd);
}

bool CreatureObject::checkCooldownRecovery(const String& cooldown) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKCOOLDOWNRECOVERY__STRING_);
		method.addAsciiParameter(cooldown);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->checkCooldownRecovery(cooldown);
}

Time* CreatureObject::getCooldownTime(const String& cooldown) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getCooldownTime(cooldown);
}

void CreatureObject::addCooldown(const String& name, unsigned int miliseconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCOOLDOWN__STRING_INT_);
		method.addAsciiParameter(name);
		method.addUnsignedIntParameter(miliseconds);

		method.executeWithVoidReturn();
	} else
		_implementation->addCooldown(name, miliseconds);
}

void CreatureObject::doAnimation(const String& animation) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOANIMATION__STRING_);
		method.addAsciiParameter(animation);

		method.executeWithVoidReturn();
	} else
		_implementation->doAnimation(animation);
}

void CreatureObject::doCombatAnimation(CreatureObject* defender, unsigned int animationCRC, byte hit, byte trails) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOCOMBATANIMATION__CREATUREOBJECT_INT_BYTE_BYTE_);
		method.addObjectParameter(defender);
		method.addUnsignedIntParameter(animationCRC);
		method.addByteParameter(hit);
		method.addByteParameter(trails);

		method.executeWithVoidReturn();
	} else
		_implementation->doCombatAnimation(defender, animationCRC, hit, trails);
}

void CreatureObject::playEffect(const String& file, const String& aux) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PLAYEFFECT__STRING_STRING_);
		method.addAsciiParameter(file);
		method.addAsciiParameter(aux);

		method.executeWithVoidReturn();
	} else
		_implementation->playEffect(file, aux);
}

void CreatureObject::playEffect(const String& file) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PLAYEFFECT__STRING_);
		method.addAsciiParameter(file);

		method.executeWithVoidReturn();
	} else
		_implementation->playEffect(file);
}

void CreatureObject::activateQueueAction() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEQUEUEACTION__);

		method.executeWithVoidReturn();
	} else
		_implementation->activateQueueAction();
}

void CreatureObject::activateImmediateAction() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEIMMEDIATEACTION__);

		method.executeWithVoidReturn();
	} else
		_implementation->activateImmediateAction();
}

UnicodeString CreatureObject::getCreatureName() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCREATURENAME__);

		UnicodeString _return_getCreatureName;
		method.executeWithUnicodeReturn(_return_getCreatureName);
		return _return_getCreatureName;
	} else
		return _implementation->getCreatureName();
}

bool CreatureObject::isGrouped() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISGROUPED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isGrouped();
}

int CreatureObject::getBankCredits() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBANKCREDITS__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getBankCredits();
}

int CreatureObject::getCashCredits() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCASHCREDITS__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getCashCredits();
}

int CreatureObject::getBaseHAM(int idx) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASEHAM__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getBaseHAM(idx);
}

int CreatureObject::getWounds(int idx) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWOUNDS__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getWounds(idx);
}

DeltaVector<int>* CreatureObject::getWounds() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getWounds();
}

int CreatureObject::getHAM(int idx) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHAM__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getHAM(idx);
}

DeltaVector<int>* CreatureObject::getHAM() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getHAM();
}

int CreatureObject::getMaxHAM(int idx) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXHAM__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getMaxHAM(idx);
}

DeltaVector<int>* CreatureObject::getMaxHAM() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getMaxHAM();
}

int CreatureObject::getEncumbrance(int idx) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENCUMBRANCE__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getEncumbrance(idx);
}

DeltaVector<int>* CreatureObject::getEncumbrances() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getEncumbrances();
}

byte CreatureObject::getPosture() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPOSTURE__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getPosture();
}

byte CreatureObject::getLocomotion() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLOCOMOTION__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getLocomotion();
}

byte CreatureObject::getFactionRank() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONRANK__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getFactionRank();
}

ManagedWeakReference<CreatureObject* > CreatureObject::getLinkedCreature() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLINKEDCREATURE__);

		return static_cast<CreatureObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getLinkedCreature();
}

unsigned long long CreatureObject::getCreatureLinkID() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCREATURELINKID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getCreatureLinkID();
}

float CreatureObject::getShockWounds() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSHOCKWOUNDS__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getShockWounds();
}

unsigned long long CreatureObject::getWatchToID() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWATCHTOID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getWatchToID();
}

unsigned long long CreatureObject::getStateBitmask() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSTATEBITMASK__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getStateBitmask();
}

bool CreatureObject::hasState(unsigned long long state) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSTATE__LONG_);
		method.addUnsignedLongParameter(state);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasState(state);
}

bool CreatureObject::hasStates() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSTATES__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasStates();
}

unsigned long long CreatureObject::getListenID() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLISTENID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getListenID();
}

float CreatureObject::getAccelerationMultiplierBase() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCELERATIONMULTIPLIERBASE__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getAccelerationMultiplierBase();
}

float CreatureObject::getAccelerationMultiplierMod() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCELERATIONMULTIPLIERMOD__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getAccelerationMultiplierMod();
}

float CreatureObject::getSpeedMultiplierBase() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPEEDMULTIPLIERBASE__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getSpeedMultiplierBase();
}

float CreatureObject::getSpeedMultiplierMod() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPEEDMULTIPLIERMOD__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getSpeedMultiplierMod();
}

float CreatureObject::getCurrentSpeed() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURRENTSPEED__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getCurrentSpeed();
}

SpeedMultiplierModChanges* CreatureObject::getSpeedMultiplierModChanges() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getSpeedMultiplierModChanges();
}

CommandQueueActionVector* CreatureObject::getCommandQueue() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getCommandQueue();
}

float CreatureObject::getRunSpeed() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRUNSPEED__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getRunSpeed();
}

float CreatureObject::getWalkSpeed() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWALKSPEED__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getWalkSpeed();
}

float CreatureObject::getTurnScale() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTURNSCALE__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getTurnScale();
}

float CreatureObject::getTerrainNegotiation() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTERRAINNEGOTIATION__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getTerrainNegotiation();
}

float CreatureObject::getRunAcceleration() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRUNACCELERATION__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getRunAcceleration();
}

float CreatureObject::getWalkAcceleration() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWALKACCELERATION__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getWalkAcceleration();
}

String CreatureObject::getPerformanceAnimation() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERFORMANCEANIMATION__);

		String _return_getPerformanceAnimation;
		method.executeWithAsciiReturn(_return_getPerformanceAnimation);
		return _return_getPerformanceAnimation;
	} else
		return _implementation->getPerformanceAnimation();
}

String CreatureObject::getMoodString() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMOODSTRING__);

		String _return_getMoodString;
		method.executeWithAsciiReturn(_return_getMoodString);
		return _return_getMoodString;
	} else
		return _implementation->getMoodString();
}

unsigned long long CreatureObject::getWeaponID() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWEAPONID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getWeaponID();
}

WeaponObject* CreatureObject::getWeapon() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWEAPON__);

		return static_cast<WeaponObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getWeapon();
}

GuildObject* CreatureObject::getGuildObject() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGUILDOBJECT__);

		return static_cast<GuildObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getGuildObject();
}

int CreatureObject::getGuildID() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGUILDID__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getGuildID();
}

bool CreatureObject::isInGuild() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINGUILD__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInGuild();
}

void CreatureObject::setGuildObject(GuildObject* guildobj) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETGUILDOBJECT__GUILDOBJECT_);
		method.addObjectParameter(guildobj);

		method.executeWithVoidReturn();
	} else
		_implementation->setGuildObject(guildobj);
}

unsigned long long CreatureObject::getGroupID() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUPID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getGroupID();
}

unsigned long long CreatureObject::getGroupInviterID() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUPINVITERID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getGroupInviterID();
}

GroupObject* CreatureObject::getGroup() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUP__);

		return static_cast<GroupObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getGroup();
}

unsigned long long CreatureObject::getGroupInviteCounter() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUPINVITECOUNTER__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getGroupInviteCounter();
}

unsigned long long CreatureObject::getTargetID() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTARGETID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getTargetID();
}

byte CreatureObject::getMoodID() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMOODID__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getMoodID();
}

float CreatureObject::getSlopeModPercent() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSLOPEMODPERCENT__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getSlopeModPercent();
}

int CreatureObject::getPerformanceCounter() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERFORMANCECOUNTER__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getPerformanceCounter();
}

int CreatureObject::getInstrumentID() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINSTRUMENTID__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getInstrumentID();
}

byte CreatureObject::getFrozen() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFROZEN__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getFrozen();
}

float CreatureObject::getHeight() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEIGHT__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getHeight();
}

int CreatureObject::getSpecies() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPECIES__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getSpecies();
}

String CreatureObject::getSpeciesName() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPECIESNAME__);

		String _return_getSpeciesName;
		method.executeWithAsciiReturn(_return_getSpeciesName);
		return _return_getSpeciesName;
	} else
		return _implementation->getSpeciesName();
}

int CreatureObject::getGender() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGENDER__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getGender();
}

DeltaVector<int>* CreatureObject::getBaseHAM() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getBaseHAM();
}

SkillList* CreatureObject::getSkillList() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getSkillList();
}

int CreatureObject::getSkillMod(const String& skillmod) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSKILLMOD__STRING_);
		method.addAsciiParameter(skillmod);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getSkillMod(skillmod);
}

bool CreatureObject::hasSkill(const String& skill) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSKILL__STRING_);
		method.addAsciiParameter(skill);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSkill(skill);
}

SkillModList* CreatureObject::getSkillModList() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getSkillModList();
}

void CreatureObject::setWatchToID(unsigned long long id) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWATCHTOID__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->setWatchToID(id);
}

bool CreatureObject::isCreatureObject() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCREATUREOBJECT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCreatureObject();
}

bool CreatureObject::isNextActionPast() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNEXTACTIONPAST__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isNextActionPast();
}

bool CreatureObject::isTrainerCreature() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTRAINERCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isTrainerCreature();
}

bool CreatureObject::isSwimming() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSWIMMING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isSwimming();
}

ZoneClientSession* CreatureObject::getClient() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCLIENT__);

		return static_cast<ZoneClientSession*>(method.executeWithObjectReturn());
	} else
		return _implementation->getClient();
}

bool CreatureObject::isRidingMount() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRIDINGMOUNT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRidingMount();
}

ManagedWeakReference<ControlDevice* > CreatureObject::getControlDevice() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONTROLDEVICE__);

		return static_cast<ControlDevice*>(method.executeWithObjectReturn());
	} else
		return _implementation->getControlDevice();
}

float CreatureObject::getSwimHeight() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSWIMHEIGHT__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getSwimHeight();
}

bool CreatureObject::isIncapacitated() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINCAPACITATED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isIncapacitated();
}

bool CreatureObject::isDead() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDEAD__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDead();
}

bool CreatureObject::isKnockedDown() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISKNOCKEDDOWN__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isKnockedDown();
}

bool CreatureObject::isKneeling() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISKNEELING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isKneeling();
}

bool CreatureObject::isProne() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPRONE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isProne();
}

bool CreatureObject::isStanding() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTANDING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isStanding();
}

bool CreatureObject::isSitting() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSITTING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isSitting();
}

bool CreatureObject::isSkillAnimating() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSKILLANIMATING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isSkillAnimating();
}

bool CreatureObject::isRallied() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRALLIED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRallied();
}

bool CreatureObject::isInCombat() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINCOMBAT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInCombat();
}

bool CreatureObject::isDizzied() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDIZZIED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDizzied();
}

bool CreatureObject::isBerserked() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBERSERKED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isBerserked();
}

bool CreatureObject::isStunned() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTUNNED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isStunned();
}

bool CreatureObject::isBlinded() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBLINDED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isBlinded();
}

bool CreatureObject::isIntimidated() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINTIMIDATED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isIntimidated();
}

bool CreatureObject::isSnared() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSNARED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isSnared();
}

bool CreatureObject::isImmobilized() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISIMMOBILIZED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isImmobilized();
}

bool CreatureObject::isRooted() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISROOTED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRooted();
}

bool CreatureObject::isFrozen() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFROZEN__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isFrozen();
}

bool CreatureObject::isDiseased() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDISEASED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDiseased();
}

bool CreatureObject::isPoisoned() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPOISONED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPoisoned();
}

bool CreatureObject::isBleeding() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBLEEDING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isBleeding();
}

bool CreatureObject::isOnFire() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONFIRE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOnFire();
}

bool CreatureObject::isMounted() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMOUNTED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isMounted();
}

bool CreatureObject::isRidingCreature() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRIDINGCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRidingCreature();
}

bool CreatureObject::isPeaced() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPEACED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPeaced();
}

bool CreatureObject::isMeditating() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMEDITATING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isMeditating();
}

bool CreatureObject::isAiming() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAIMING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isAiming();
}

bool CreatureObject::isInCover() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINCOVER__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInCover();
}

bool CreatureObject::isRunning() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRUNNING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRunning();
}

bool CreatureObject::isNonPlayerCreatureObject() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNONPLAYERCREATUREOBJECT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isNonPlayerCreatureObject();
}

bool CreatureObject::isCreature() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCreature();
}

bool CreatureObject::isPlayerCreature() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLAYERCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPlayerCreature();
}

bool CreatureObject::isAiActor() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAIACTOR__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isAiActor();
}

bool CreatureObject::isInformantCreature() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINFORMANTCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInformantCreature();
}

CampSiteActiveArea* CreatureObject::getCurrentCamp() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURRENTCAMP__);

		return static_cast<CampSiteActiveArea*>(method.executeWithObjectReturn());
	} else
		return _implementation->getCurrentCamp();
}

byte CreatureObject::getCurrentWeather() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURRENTWEATHER__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getCurrentWeather();
}

void CreatureObject::setCurrentWeather(byte value) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCURRENTWEATHER__BYTE_);
		method.addByteParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setCurrentWeather(value);
}

byte CreatureObject::getCurrentWind() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURRENTWIND__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getCurrentWind();
}

void CreatureObject::setCurrentWind(byte value) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCURRENTWIND__BYTE_);
		method.addByteParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setCurrentWind(value);
}

int CreatureObject::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->handleObjectMenuSelect(player, selectedID);
}

void CreatureObject::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_FILLATTRIBUTELIST__ATTRIBUTELISTMESSAGE_CREATUREOBJECT_);
		method.addObjectParameter(msg);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else
		_implementation->fillAttributeList(msg, object);
}

void CreatureObject::destroyObjectFromWorld(bool sendSelfDestroy) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMWORLD__BOOL_);
		method.addBooleanParameter(sendSelfDestroy);

		method.executeWithVoidReturn();
	} else
		_implementation->destroyObjectFromWorld(sendSelfDestroy);
}

bool CreatureObject::isInvisible() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINVISIBLE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInvisible();
}

void CreatureObject::setInvisible(bool invis) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINVISIBLE__BOOL_);
		method.addBooleanParameter(invis);

		method.executeWithVoidReturn();
	} else
		_implementation->setInvisible(invis);
}

Mutex* CreatureObject::getSkillModMutex() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getSkillModMutex();
}

float CreatureObject::calculateCostAdjustment(byte stat, float baseCost) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATECOSTADJUSTMENT__BYTE_FLOAT_);
		method.addByteParameter(stat);
		method.addFloatParameter(baseCost);

		return method.executeWithFloatReturn();
	} else
		return _implementation->calculateCostAdjustment(stat, baseCost);
}

DistributedObjectServant* CreatureObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* CreatureObject::_getImplementationForRead() {
	return _impl;
}

void CreatureObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	CreatureObjectImplementation
 */

CreatureObjectImplementation::CreatureObjectImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}


CreatureObjectImplementation::~CreatureObjectImplementation() {
	CreatureObjectImplementation::finalize();
}


void CreatureObjectImplementation::_initializeImplementation() {
	_setClassHelper(CreatureObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void CreatureObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<CreatureObject*>(stub);
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* CreatureObjectImplementation::_getStub() {
	return _this.get();
}

CreatureObjectImplementation::operator const CreatureObject*() {
	return _this.get();
}

void CreatureObjectImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void CreatureObjectImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void CreatureObjectImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void CreatureObjectImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void CreatureObjectImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void CreatureObjectImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void CreatureObjectImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void CreatureObjectImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("CreatureObject");

}

void CreatureObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(CreatureObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool CreatureObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x4efbe84d: //CreatureObject.bankCredits
		TypeInfo<int >::parseFromBinaryStream(&bankCredits, stream);
		return true;

	case 0xfaf33732: //CreatureObject.cashCredits
		TypeInfo<int >::parseFromBinaryStream(&cashCredits, stream);
		return true;

	case 0x151a6a8b: //CreatureObject.gender
		TypeInfo<int >::parseFromBinaryStream(&gender, stream);
		return true;

	case 0xabdc9a49: //CreatureObject.species
		TypeInfo<int >::parseFromBinaryStream(&species, stream);
		return true;

	case 0xe9b502e0: //CreatureObject.baseHAM
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&baseHAM, stream);
		return true;

	case 0xeb725d47: //CreatureObject.posture
		TypeInfo<byte >::parseFromBinaryStream(&posture, stream);
		return true;

	case 0x1baa7e7: //CreatureObject.locomotion
		TypeInfo<byte >::parseFromBinaryStream(&locomotion, stream);
		return true;

	case 0xc718f22f: //CreatureObject.factionRank
		TypeInfo<byte >::parseFromBinaryStream(&factionRank, stream);
		return true;

	case 0xcd929817: //CreatureObject.invisible
		TypeInfo<bool >::parseFromBinaryStream(&invisible, stream);
		return true;

	case 0xb981d90d: //CreatureObject.linkedCreature
		TypeInfo<ManagedWeakReference<CreatureObject* > >::parseFromBinaryStream(&linkedCreature, stream);
		return true;

	case 0x49ffc563: //CreatureObject.controlDevice
		TypeInfo<ManagedWeakReference<ControlDevice* > >::parseFromBinaryStream(&controlDevice, stream);
		return true;

	case 0xed4a9523: //CreatureObject.shockWounds
		TypeInfo<float >::parseFromBinaryStream(&shockWounds, stream);
		return true;

	case 0xc58d8e3a: //CreatureObject.wounds
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&wounds, stream);
		return true;

	case 0x28d872c3: //CreatureObject.stateBitmask
		TypeInfo<unsigned long long >::parseFromBinaryStream(&stateBitmask, stream);
		return true;

	case 0x7efecb9a: //CreatureObject.encumbrances
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&encumbrances, stream);
		return true;

	case 0x3f51e181: //CreatureObject.wearablesVector
		TypeInfo<WearablesDeltaVector >::parseFromBinaryStream(&wearablesVector, stream);
		return true;

	case 0xed98f6f1: //CreatureObject.accelerationMultiplierBase
		TypeInfo<float >::parseFromBinaryStream(&accelerationMultiplierBase, stream);
		return true;

	case 0xc1ae38c: //CreatureObject.accelerationMultiplierMod
		TypeInfo<float >::parseFromBinaryStream(&accelerationMultiplierMod, stream);
		return true;

	case 0x4114cdb5: //CreatureObject.speedMultiplierBase
		TypeInfo<float >::parseFromBinaryStream(&speedMultiplierBase, stream);
		return true;

	case 0x45a23b71: //CreatureObject.speedMultiplierModChanges
		TypeInfo<SpeedMultiplierModChanges >::parseFromBinaryStream(&speedMultiplierModChanges, stream);
		return true;

	case 0x612b07f7: //CreatureObject.speedMultiplierMod
		TypeInfo<float >::parseFromBinaryStream(&speedMultiplierMod, stream);
		return true;

	case 0xc5da611d: //CreatureObject.turnScale
		TypeInfo<float >::parseFromBinaryStream(&turnScale, stream);
		return true;

	case 0x76595507: //CreatureObject.runSpeed
		TypeInfo<float >::parseFromBinaryStream(&runSpeed, stream);
		return true;

	case 0x99e420df: //CreatureObject.walkSpeed
		TypeInfo<float >::parseFromBinaryStream(&walkSpeed, stream);
		return true;

	case 0x27abda40: //CreatureObject.currentSpeed
		TypeInfo<float >::parseFromBinaryStream(&currentSpeed, stream);
		return true;

	case 0xe5a6e8cb: //CreatureObject.terrainNegotiation
		TypeInfo<float >::parseFromBinaryStream(&terrainNegotiation, stream);
		return true;

	case 0xd126abdf: //CreatureObject.runAcceleration
		TypeInfo<float >::parseFromBinaryStream(&runAcceleration, stream);
		return true;

	case 0x7889ea2d: //CreatureObject.walkAcceleration
		TypeInfo<float >::parseFromBinaryStream(&walkAcceleration, stream);
		return true;

	case 0x949ac654: //CreatureObject.height
		TypeInfo<float >::parseFromBinaryStream(&height, stream);
		return true;

	case 0xe0f234f7: //CreatureObject.swimHeight
		TypeInfo<float >::parseFromBinaryStream(&swimHeight, stream);
		return true;

	case 0x3acb18b3: //CreatureObject.slopeModPercent
		TypeInfo<float >::parseFromBinaryStream(&slopeModPercent, stream);
		return true;

	case 0x1f13576: //CreatureObject.slopeModAngle
		TypeInfo<float >::parseFromBinaryStream(&slopeModAngle, stream);
		return true;

	case 0xc1faba17: //CreatureObject.listenToID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&listenToID, stream);
		return true;

	case 0x2322b2f8: //CreatureObject.watchToID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&watchToID, stream);
		return true;

	case 0xc8ec9744: //CreatureObject.performanceAnimation
		TypeInfo<String >::parseFromBinaryStream(&performanceAnimation, stream);
		return true;

	case 0xe9808458: //CreatureObject.moodString
		TypeInfo<String >::parseFromBinaryStream(&moodString, stream);
		return true;

	case 0xf7c21f8: //CreatureObject.weapon
		TypeInfo<ManagedReference<WeaponObject* > >::parseFromBinaryStream(&weapon, stream);
		return true;

	case 0x40463fdc: //CreatureObject.group
		TypeInfo<ManagedReference<GroupObject* > >::parseFromBinaryStream(&group, stream);
		return true;

	case 0x764b5acf: //CreatureObject.groupInviterID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&groupInviterID, stream);
		return true;

	case 0x80dbd4b5: //CreatureObject.groupInviteCounter
		TypeInfo<unsigned long long >::parseFromBinaryStream(&groupInviteCounter, stream);
		return true;

	case 0x4f029e94: //CreatureObject.guild
		TypeInfo<ManagedReference<GuildObject* > >::parseFromBinaryStream(&guild, stream);
		return true;

	case 0xeb62addf: //CreatureObject.targetID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&targetID, stream);
		return true;

	case 0xd4ef3def: //CreatureObject.moodID
		TypeInfo<byte >::parseFromBinaryStream(&moodID, stream);
		return true;

	case 0x83a587da: //CreatureObject.performanceCounter
		TypeInfo<int >::parseFromBinaryStream(&performanceCounter, stream);
		return true;

	case 0x41617b95: //CreatureObject.instrumentID
		TypeInfo<int >::parseFromBinaryStream(&instrumentID, stream);
		return true;

	case 0xe7af3a39: //CreatureObject.hamList
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&hamList, stream);
		return true;

	case 0xe055bce7: //CreatureObject.maxHamList
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&maxHamList, stream);
		return true;

	case 0xc4efdf12: //CreatureObject.frozen
		TypeInfo<byte >::parseFromBinaryStream(&frozen, stream);
		return true;

	case 0xd6174e91: //CreatureObject.templateString
		TypeInfo<String >::parseFromBinaryStream(&templateString, stream);
		return true;

	case 0x1a1789b3: //CreatureObject.skillList
		TypeInfo<SkillList >::parseFromBinaryStream(&skillList, stream);
		return true;

	case 0xbc739f7e: //CreatureObject.skillModList
		TypeInfo<SkillModList >::parseFromBinaryStream(&skillModList, stream);
		return true;

	case 0x763c81e: //CreatureObject.nextAction
		TypeInfo<Time >::parseFromBinaryStream(&nextAction, stream);
		return true;

	case 0xbc44e9f6: //CreatureObject.cooldownTimerMap
		TypeInfo<Reference<CooldownTimerMap* > >::parseFromBinaryStream(&cooldownTimerMap, stream);
		return true;

	case 0x905e244e: //CreatureObject.creatureBuffs
		TypeInfo<BuffList >::parseFromBinaryStream(&creatureBuffs, stream);
		return true;

	case 0xf65f1375: //CreatureObject.damageOverTimeList
		TypeInfo<DamageOverTimeList >::parseFromBinaryStream(&damageOverTimeList, stream);
		return true;

	case 0xe0c29f16: //CreatureObject.lastSuccessfulCombatAction
		TypeInfo<Time >::parseFromBinaryStream(&lastSuccessfulCombatAction, stream);
		return true;

	case 0x93032da8: //CreatureObject.timeOfDeath
		TypeInfo<Time >::parseFromBinaryStream(&timeOfDeath, stream);
		return true;

	case 0xfaac264a: //CreatureObject.screenPlayStates
		TypeInfo<VectorMap<String, unsigned long long> >::parseFromBinaryStream(&screenPlayStates, stream);
		return true;

	}

	return false;
}

void CreatureObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = CreatureObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int CreatureObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x4efbe84d; //CreatureObject.bankCredits
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&bankCredits, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xfaf33732; //CreatureObject.cashCredits
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&cashCredits, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x151a6a8b; //CreatureObject.gender
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&gender, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xabdc9a49; //CreatureObject.species
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&species, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe9b502e0; //CreatureObject.baseHAM
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&baseHAM, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xeb725d47; //CreatureObject.posture
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&posture, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x1baa7e7; //CreatureObject.locomotion
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&locomotion, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc718f22f; //CreatureObject.factionRank
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&factionRank, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xcd929817; //CreatureObject.invisible
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&invisible, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xb981d90d; //CreatureObject.linkedCreature
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<CreatureObject* > >::toBinaryStream(&linkedCreature, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x49ffc563; //CreatureObject.controlDevice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<ControlDevice* > >::toBinaryStream(&controlDevice, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xed4a9523; //CreatureObject.shockWounds
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&shockWounds, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc58d8e3a; //CreatureObject.wounds
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&wounds, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x28d872c3; //CreatureObject.stateBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&stateBitmask, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x7efecb9a; //CreatureObject.encumbrances
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&encumbrances, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3f51e181; //CreatureObject.wearablesVector
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<WearablesDeltaVector >::toBinaryStream(&wearablesVector, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xed98f6f1; //CreatureObject.accelerationMultiplierBase
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&accelerationMultiplierBase, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc1ae38c; //CreatureObject.accelerationMultiplierMod
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&accelerationMultiplierMod, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x4114cdb5; //CreatureObject.speedMultiplierBase
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&speedMultiplierBase, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x45a23b71; //CreatureObject.speedMultiplierModChanges
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SpeedMultiplierModChanges >::toBinaryStream(&speedMultiplierModChanges, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x612b07f7; //CreatureObject.speedMultiplierMod
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&speedMultiplierMod, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc5da611d; //CreatureObject.turnScale
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&turnScale, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x76595507; //CreatureObject.runSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&runSpeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x99e420df; //CreatureObject.walkSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&walkSpeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x27abda40; //CreatureObject.currentSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&currentSpeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe5a6e8cb; //CreatureObject.terrainNegotiation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&terrainNegotiation, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd126abdf; //CreatureObject.runAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&runAcceleration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x7889ea2d; //CreatureObject.walkAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&walkAcceleration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x949ac654; //CreatureObject.height
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&height, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe0f234f7; //CreatureObject.swimHeight
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&swimHeight, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3acb18b3; //CreatureObject.slopeModPercent
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&slopeModPercent, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x1f13576; //CreatureObject.slopeModAngle
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&slopeModAngle, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc1faba17; //CreatureObject.listenToID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&listenToID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x2322b2f8; //CreatureObject.watchToID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&watchToID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc8ec9744; //CreatureObject.performanceAnimation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&performanceAnimation, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe9808458; //CreatureObject.moodString
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&moodString, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xf7c21f8; //CreatureObject.weapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObject* > >::toBinaryStream(&weapon, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x40463fdc; //CreatureObject.group
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<GroupObject* > >::toBinaryStream(&group, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x764b5acf; //CreatureObject.groupInviterID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&groupInviterID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x80dbd4b5; //CreatureObject.groupInviteCounter
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&groupInviteCounter, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x4f029e94; //CreatureObject.guild
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<GuildObject* > >::toBinaryStream(&guild, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xeb62addf; //CreatureObject.targetID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&targetID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd4ef3def; //CreatureObject.moodID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&moodID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x83a587da; //CreatureObject.performanceCounter
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&performanceCounter, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x41617b95; //CreatureObject.instrumentID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&instrumentID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe7af3a39; //CreatureObject.hamList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&hamList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe055bce7; //CreatureObject.maxHamList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&maxHamList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc4efdf12; //CreatureObject.frozen
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&frozen, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd6174e91; //CreatureObject.templateString
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&templateString, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x1a1789b3; //CreatureObject.skillList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SkillList >::toBinaryStream(&skillList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xbc739f7e; //CreatureObject.skillModList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SkillModList >::toBinaryStream(&skillModList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x763c81e; //CreatureObject.nextAction
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&nextAction, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xbc44e9f6; //CreatureObject.cooldownTimerMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Reference<CooldownTimerMap* > >::toBinaryStream(&cooldownTimerMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x905e244e; //CreatureObject.creatureBuffs
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<BuffList >::toBinaryStream(&creatureBuffs, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xf65f1375; //CreatureObject.damageOverTimeList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DamageOverTimeList >::toBinaryStream(&damageOverTimeList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe0c29f16; //CreatureObject.lastSuccessfulCombatAction
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastSuccessfulCombatAction, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x93032da8; //CreatureObject.timeOfDeath
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&timeOfDeath, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xfaac264a; //CreatureObject.screenPlayStates
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, unsigned long long> >::toBinaryStream(&screenPlayStates, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 58;
}

CreatureObjectImplementation::CreatureObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/creature/CreatureObject.idl():  		Logger.setLoggingName("CreatureObject");
	Logger::setLoggingName("CreatureObject");
	// server/zone/objects/creature/CreatureObject.idl():  		initializeMembers();
	initializeMembers();
}

void CreatureObjectImplementation::setCurrentSpeed(float newSpeed) {
	// server/zone/objects/creature/CreatureObject.idl():  		currentSpeed = newSpeed;
	currentSpeed = newSpeed;
}

bool CreatureObjectImplementation::hasDamage(int attribute) {
	// server/zone/objects/creature/CreatureObject.idl():  		return hamList.get(attribute) + wounds.get(attribute) < maxHamList.get(attribute);
	return (&hamList)->get(attribute) + (&wounds)->get(attribute) < (&maxHamList)->get(attribute);
}

bool CreatureObjectImplementation::removeStateBuff(unsigned long long state) {
	// server/zone/objects/creature/CreatureObject.idl():  		return removeBuff(Long.hashCode(state));
	return removeBuff(Long::hashCode(state));
}

WearablesDeltaVector* CreatureObjectImplementation::getWearablesDeltaVector() {
	// server/zone/objects/creature/CreatureObject.idl():  		return wearablesVector;
	return (&wearablesVector);
}

void CreatureObjectImplementation::sendBuffsTo(CreatureObject* creature) {
	// server/zone/objects/creature/CreatureObject.idl():  		creatureBuffs.sendTo(creature);
	(&creatureBuffs)->sendTo(creature);
}

BuffList* CreatureObjectImplementation::getBuffList() {
	// server/zone/objects/creature/CreatureObject.idl():  		return creatureBuffs;
	return (&creatureBuffs);
}

Buff* CreatureObjectImplementation::getBuff(unsigned int buffcrc) {
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if ((&creatureBuffs)->hasBuff(buffcrc))	// server/zone/objects/creature/CreatureObject.idl():  			return creatureBuffs.getBuffByCRC(buffcrc);
	return (&creatureBuffs)->getBuffByCRC(buffcrc);
	// server/zone/objects/creature/CreatureObject.idl():  		return null;
	return NULL;
}

long long CreatureObjectImplementation::getSkillModFromBuffs(const String& skillMod) {
	// server/zone/objects/creature/CreatureObject.idl():  		return creatureBuffs.getModifierByName(skillMod);
	return (&creatureBuffs)->getModifierByName(skillMod);
}

int CreatureObjectImplementation::addDotState(unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense) {
	// server/zone/objects/creature/CreatureObject.idl():  		return damageOverTimeList.addDot(this, objectID, duration, dotType, type, strength, potency, defense);
	return (&damageOverTimeList)->addDot(_this.get(), objectID, duration, dotType, type, strength, potency, defense);
}

bool CreatureObjectImplementation::healDot(unsigned long long dotType, int reduction) {
	// server/zone/objects/creature/CreatureObject.idl():  		return damageOverTimeList.healState(this, dotType, reduction);
	return (&damageOverTimeList)->healState(_this.get(), dotType, reduction);
}

void CreatureObjectImplementation::clearDots() {
	// server/zone/objects/creature/CreatureObject.idl():  		damageOverTimeList.clear(this);
	(&damageOverTimeList)->clear(_this.get());
}

DamageOverTimeList* CreatureObjectImplementation::getDamageOverTimeList() {
	// server/zone/objects/creature/CreatureObject.idl():  		return damageOverTimeList;
	return (&damageOverTimeList);
}

bool CreatureObjectImplementation::hasBuff(unsigned int buffcrc) {
	// server/zone/objects/creature/CreatureObject.idl():  		return creatureBuffs.hasBuff(buffcrc);
	return (&creatureBuffs)->hasBuff(buffcrc);
}

void CreatureObjectImplementation::addBankCredits(int credits, bool notifyClient) {
	// server/zone/objects/creature/CreatureObject.idl():  		int newCredits = bankCredits + credits;
	int newCredits = bankCredits + credits;
	// server/zone/objects/creature/CreatureObject.idl():  		setBankCredits(newCredits);
	setBankCredits(newCredits);
}

void CreatureObjectImplementation::addCashCredits(int credits, bool notifyClient) {
	// server/zone/objects/creature/CreatureObject.idl():  		int newCredits = cashCredits + credits;
	int newCredits = cashCredits + credits;
	// server/zone/objects/creature/CreatureObject.idl():  		setCashCredits(newCredits);
	setCashCredits(newCredits);
}

bool CreatureObjectImplementation::verifyCashCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl():  		if 
	if (credits < 0)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if (cashCredits < credits)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return true;
	return true;
}

bool CreatureObjectImplementation::verifyBankCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl():  		if 
	if (credits < 0)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if (bankCredits < credits)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return true;
	return true;
}

bool CreatureObjectImplementation::isEntertaining() {
	// server/zone/objects/creature/CreatureObject.idl():  		return isDancing() || isPlayingMusic();
	return isDancing() || isPlayingMusic();
}

void CreatureObjectImplementation::setControlDevice(ControlDevice* device) {
	// server/zone/objects/creature/CreatureObject.idl():  		controlDevice = device;
	controlDevice = device;
}

void CreatureObjectImplementation::sendConversationStartTo(SceneObject* player) {
	// server/zone/objects/creature/CreatureObject.idl():  	}
	if (isAiActor())	// server/zone/objects/creature/CreatureObject.idl():  			getActorObject().sendConversationStartTo(player);
	getActorObject()->sendConversationStartTo(player);
}

void CreatureObjectImplementation::selectConversationOption(int option, SceneObject* obj) {
}

bool CreatureObjectImplementation::isOnline() {
	// server/zone/objects/creature/CreatureObject.idl():  		PlayerObject ghost = getPlayerObject();
	ManagedReference<PlayerObject* > ghost = getPlayerObject();
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if (ghost == NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return ghost.isOnline();
	return ghost->isOnline();
}

bool CreatureObjectImplementation::canTreatInjuries() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("injuryTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("injuryTreatment") == NULL;
}

bool CreatureObjectImplementation::canTreatStates() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("stateTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("stateTreatment") == NULL;
}

bool CreatureObjectImplementation::canTreatWounds() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("woundTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("woundTreatment") == NULL;
}

bool CreatureObjectImplementation::canTreatConditions() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("conditionTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("conditionTreatment") == NULL;
}

bool CreatureObjectImplementation::isListening() {
	// server/zone/objects/creature/CreatureObject.idl():  		return listenToID != 0;
	return listenToID != 0;
}

bool CreatureObjectImplementation::isWatching() {
	// server/zone/objects/creature/CreatureObject.idl():  		return watchToID != 0;
	return watchToID != 0;
}

void CreatureObjectImplementation::setClient(ZoneClientSession* cli) {
	// server/zone/objects/creature/CreatureObject.idl():  		owner = cli;
	owner = cli;
}

void CreatureObjectImplementation::updateTimeOfDeath() {
	// server/zone/objects/creature/CreatureObject.idl():  		timeOfDeath.updateToCurrentTime();
	(&timeOfDeath)->updateToCurrentTime();
}

bool CreatureObjectImplementation::hasAttackDelay() {
	// server/zone/objects/creature/CreatureObject.idl():  		return !cooldownTimerMap.isPast("nextAttackDelay");
	return !cooldownTimerMap->isPast("nextAttackDelay");
}

void CreatureObjectImplementation::removeAttackDelay() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentTime("nextAttackDelay");
	cooldownTimerMap->updateToCurrentTime("nextAttackDelay");
}

CooldownTimerMap* CreatureObjectImplementation::getCooldownTimerMap() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap;
	return cooldownTimerMap;
}

bool CreatureObjectImplementation::hasSpice() {
	// server/zone/objects/creature/CreatureObject.idl():  		return creatureBuffs.hasSpice();
	return (&creatureBuffs)->hasSpice();
}

void CreatureObjectImplementation::updateLastSuccessfulCombatAction() {
	// server/zone/objects/creature/CreatureObject.idl():  		lastSuccessfulCombatAction.updateToCurrentTime();
	(&lastSuccessfulCombatAction)->updateToCurrentTime();
}

void CreatureObjectImplementation::updateKnockdownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("knockdownRecovery", 5000);
	cooldownTimerMap->updateToCurrentAndAddMili("knockdownRecovery", 5000);
}

void CreatureObjectImplementation::updateLastKnockdown() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("lastKnockdown", 60000);
	cooldownTimerMap->updateToCurrentAndAddMili("lastKnockdown", 60000);
}

bool CreatureObjectImplementation::checkKnockdownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("knockdownRecovery");
	return cooldownTimerMap->isPast("knockdownRecovery");
}

bool CreatureObjectImplementation::checkLastKnockdown() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("lastKnockdown");
	return cooldownTimerMap->isPast("lastKnockdown");
}

void CreatureObjectImplementation::updatePostureDownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("postureDownRecovery", 30000);
	cooldownTimerMap->updateToCurrentAndAddMili("postureDownRecovery", 30000);
}

void CreatureObjectImplementation::updatePostureUpRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("postureUpRecovery", 30000);
	cooldownTimerMap->updateToCurrentAndAddMili("postureUpRecovery", 30000);
}

bool CreatureObjectImplementation::checkPostureDownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("postureDownRecovery");
	return cooldownTimerMap->isPast("postureDownRecovery");
}

unsigned long long CreatureObjectImplementation::getScreenPlayState(const String& screenPlay) {
	// server/zone/objects/creature/CreatureObject.idl():  		return screenPlayStates.get(screenPlay);
	return (&screenPlayStates)->get(screenPlay);
}

void CreatureObjectImplementation::setScreenPlayState(const String& screenPlay, unsigned long long state) {
	// server/zone/objects/creature/CreatureObject.idl():  		screenPlayStates.put(screenPlay, state);
	(&screenPlayStates)->put(screenPlay, state);
}

bool CreatureObjectImplementation::checkPostureUpRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("postureUpRecovery");
	return cooldownTimerMap->isPast("postureUpRecovery");
}

void CreatureObjectImplementation::updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd) {
	// server/zone/objects/creature/CreatureObject.idl():  		}
	if (miliSecondsToAdd != 0){
	// server/zone/objects/creature/CreatureObject.idl():  			cooldownTimerMap.updateToCurrentAndAddMili(coooldownTimer, miliSecondsToAdd);
	cooldownTimerMap->updateToCurrentAndAddMili(coooldownTimer, miliSecondsToAdd);
}

	else {
	// server/zone/objects/creature/CreatureObject.idl():  			cooldownTimerMap.updateToCurrentTime(coooldownTimer);
	cooldownTimerMap->updateToCurrentTime(coooldownTimer);
}
}

bool CreatureObjectImplementation::checkCooldownRecovery(const String& cooldown) {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast(cooldown);
	return cooldownTimerMap->isPast(cooldown);
}

Time* CreatureObjectImplementation::getCooldownTime(const String& cooldown) {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.getTime(cooldown);
	return cooldownTimerMap->getTime(cooldown);
}

void CreatureObjectImplementation::addCooldown(const String& name, unsigned int miliseconds) {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili(name, miliseconds);
	cooldownTimerMap->updateToCurrentAndAddMili(name, miliseconds);
}

void CreatureObjectImplementation::playEffect(const String& file) {
	// server/zone/objects/creature/CreatureObject.idl():  		playEffect(file, "");
	playEffect(file, "");
}

bool CreatureObjectImplementation::isGrouped() {
	// server/zone/objects/creature/CreatureObject.idl():  		return group != null;
	return group != NULL;
}

int CreatureObjectImplementation::getBankCredits() {
	// server/zone/objects/creature/CreatureObject.idl():  		return bankCredits;
	return bankCredits;
}

int CreatureObjectImplementation::getCashCredits() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cashCredits;
	return cashCredits;
}

int CreatureObjectImplementation::getBaseHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return baseHAM.get(idx);
	return (&baseHAM)->get(idx);
}

int CreatureObjectImplementation::getWounds(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return wounds.get(idx);
	return (&wounds)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getWounds() {
	// server/zone/objects/creature/CreatureObject.idl():  		return wounds;
	return (&wounds);
}

int CreatureObjectImplementation::getHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return hamList.get(idx);
	return (&hamList)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getHAM() {
	// server/zone/objects/creature/CreatureObject.idl():  		return hamList;
	return (&hamList);
}

int CreatureObjectImplementation::getMaxHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return maxHamList.get(idx);
	return (&maxHamList)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getMaxHAM() {
	// server/zone/objects/creature/CreatureObject.idl():  		return maxHamList;
	return (&maxHamList);
}

int CreatureObjectImplementation::getEncumbrance(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return encumbrances.get(idx);
	return (&encumbrances)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getEncumbrances() {
	// server/zone/objects/creature/CreatureObject.idl():  		return encumbrances;
	return (&encumbrances);
}

byte CreatureObjectImplementation::getPosture() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture;
	return posture;
}

byte CreatureObjectImplementation::getLocomotion() {
	// server/zone/objects/creature/CreatureObject.idl():  		return locomotion;
	return locomotion;
}

byte CreatureObjectImplementation::getFactionRank() {
	// server/zone/objects/creature/CreatureObject.idl():  		return factionRank;
	return factionRank;
}

ManagedWeakReference<CreatureObject* > CreatureObjectImplementation::getLinkedCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return linkedCreature;
	return linkedCreature;
}

unsigned long long CreatureObjectImplementation::getCreatureLinkID() {
	// server/zone/objects/creature/CreatureObject.idl():  		CreatureObject strongRef = linkedCreature;
	ManagedReference<CreatureObject* > strongRef = linkedCreature;
	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	if (strongRef != NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return strongRef.getObjectID();
	return strongRef->getObjectID();

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;
}

float CreatureObjectImplementation::getShockWounds() {
	// server/zone/objects/creature/CreatureObject.idl():  		return shockWounds;
	return shockWounds;
}

unsigned long long CreatureObjectImplementation::getWatchToID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return watchToID;
	return watchToID;
}

unsigned long long CreatureObjectImplementation::getStateBitmask() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask;
	return stateBitmask;
}

bool CreatureObjectImplementation::hasState(unsigned long long state) {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & state;
	return stateBitmask & state;
}

bool CreatureObjectImplementation::hasStates() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask != 0;
	return stateBitmask != 0;
}

unsigned long long CreatureObjectImplementation::getListenID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return listenToID;
	return listenToID;
}

float CreatureObjectImplementation::getAccelerationMultiplierBase() {
	// server/zone/objects/creature/CreatureObject.idl():  		return accelerationMultiplierBase;
	return accelerationMultiplierBase;
}

float CreatureObjectImplementation::getAccelerationMultiplierMod() {
	// server/zone/objects/creature/CreatureObject.idl():  		return accelerationMultiplierMod;
	return accelerationMultiplierMod;
}

float CreatureObjectImplementation::getSpeedMultiplierBase() {
	// server/zone/objects/creature/CreatureObject.idl():  		return speedMultiplierBase;
	return speedMultiplierBase;
}

float CreatureObjectImplementation::getSpeedMultiplierMod() {
	// server/zone/objects/creature/CreatureObject.idl():  		return speedMultiplierMod;
	return speedMultiplierMod;
}

float CreatureObjectImplementation::getCurrentSpeed() {
	// server/zone/objects/creature/CreatureObject.idl():  		return currentSpeed;
	return currentSpeed;
}

SpeedMultiplierModChanges* CreatureObjectImplementation::getSpeedMultiplierModChanges() {
	// server/zone/objects/creature/CreatureObject.idl():  		return speedMultiplierModChanges;
	return (&speedMultiplierModChanges);
}

CommandQueueActionVector* CreatureObjectImplementation::getCommandQueue() {
	// server/zone/objects/creature/CreatureObject.idl():  		return commandQueue;
	return commandQueue;
}

float CreatureObjectImplementation::getRunSpeed() {
	// server/zone/objects/creature/CreatureObject.idl():  		return runSpeed;
	return runSpeed;
}

float CreatureObjectImplementation::getWalkSpeed() {
	// server/zone/objects/creature/CreatureObject.idl():  		return walkSpeed;
	return walkSpeed;
}

float CreatureObjectImplementation::getTurnScale() {
	// server/zone/objects/creature/CreatureObject.idl():  		return turnScale;
	return turnScale;
}

float CreatureObjectImplementation::getRunAcceleration() {
	// server/zone/objects/creature/CreatureObject.idl():  		return runAcceleration;
	return runAcceleration;
}

float CreatureObjectImplementation::getWalkAcceleration() {
	// server/zone/objects/creature/CreatureObject.idl():  		return walkAcceleration;
	return walkAcceleration;
}

String CreatureObjectImplementation::getPerformanceAnimation() {
	// server/zone/objects/creature/CreatureObject.idl():  		return performanceAnimation;
	return performanceAnimation;
}

String CreatureObjectImplementation::getMoodString() {
	// server/zone/objects/creature/CreatureObject.idl():  		return moodString;
	return moodString;
}

unsigned long long CreatureObjectImplementation::getWeaponID() {
	// server/zone/objects/creature/CreatureObject.idl():  			return weapon.getObjectID();
	if (weapon == NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return weapon.getObjectID();
	return weapon->getObjectID();
}

WeaponObject* CreatureObjectImplementation::getWeapon() {
	// server/zone/objects/creature/CreatureObject.idl():  			return weapon;
	if (weapon == NULL){
	// server/zone/objects/creature/CreatureObject.idl():  			return (WeaponObject) super.getSlottedObject("default_weapon");
	return (WeaponObject*) TangibleObjectImplementation::getSlottedObject("default_weapon");
}

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return weapon;
	return weapon;
}

GuildObject* CreatureObjectImplementation::getGuildObject() {
	// server/zone/objects/creature/CreatureObject.idl():  		return guild;
	return guild;
}

int CreatureObjectImplementation::getGuildID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if (guild == NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/CreatureObject.idl():  		return guild.getGuildID();
	return guild->getGuildID();
}

bool CreatureObjectImplementation::isInGuild() {
	// server/zone/objects/creature/CreatureObject.idl():  		return guild != null;
	return guild != NULL;
}

void CreatureObjectImplementation::setGuildObject(GuildObject* guildobj) {
	// server/zone/objects/creature/CreatureObject.idl():  		guild = guildobj;
	guild = guildobj;
}

unsigned long long CreatureObjectImplementation::getGroupID() {
	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	if (group != NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return group.getObjectID();
	return group->getObjectID();

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;
}

unsigned long long CreatureObjectImplementation::getGroupInviterID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return groupInviterID;
	return groupInviterID;
}

GroupObject* CreatureObjectImplementation::getGroup() {
	// server/zone/objects/creature/CreatureObject.idl():  		return group;
	return group;
}

unsigned long long CreatureObjectImplementation::getGroupInviteCounter() {
	// server/zone/objects/creature/CreatureObject.idl():  		return groupInviteCounter;
	return groupInviteCounter;
}

unsigned long long CreatureObjectImplementation::getTargetID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return targetID;
	return targetID;
}

byte CreatureObjectImplementation::getMoodID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return moodID;
	return moodID;
}

float CreatureObjectImplementation::getSlopeModPercent() {
	// server/zone/objects/creature/CreatureObject.idl():  		return slopeModPercent;
	return slopeModPercent;
}

int CreatureObjectImplementation::getPerformanceCounter() {
	// server/zone/objects/creature/CreatureObject.idl():  		return performanceCounter;
	return performanceCounter;
}

int CreatureObjectImplementation::getInstrumentID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return instrumentID;
	return instrumentID;
}

byte CreatureObjectImplementation::getFrozen() {
	// server/zone/objects/creature/CreatureObject.idl():  		return frozen;
	return frozen;
}

float CreatureObjectImplementation::getHeight() {
	// server/zone/objects/creature/CreatureObject.idl():  		return height;
	return height;
}

int CreatureObjectImplementation::getSpecies() {
	// server/zone/objects/creature/CreatureObject.idl():  		return species;
	return species;
}

String CreatureObjectImplementation::getSpeciesName() {
	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 0)	// server/zone/objects/creature/CreatureObject.idl():  			return "human";
	return "human";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 1)	// server/zone/objects/creature/CreatureObject.idl():  			return "rodian";
	return "rodian";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 2)	// server/zone/objects/creature/CreatureObject.idl():  			return "trandoshan";
	return "trandoshan";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 3)	// server/zone/objects/creature/CreatureObject.idl():  			return "moncal";
	return "moncal";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 4)	// server/zone/objects/creature/CreatureObject.idl():  			return "wookiee";
	return "wookiee";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 5)	// server/zone/objects/creature/CreatureObject.idl():  			return "bothan";
	return "bothan";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 6)	// server/zone/objects/creature/CreatureObject.idl():  			return "twilek";
	return "twilek";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 7)	// server/zone/objects/creature/CreatureObject.idl():  			return "zabrak";
	return "zabrak";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 0x21)	// server/zone/objects/creature/CreatureObject.idl():  			return "ithorian";
	return "ithorian";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 0x31)	// server/zone/objects/creature/CreatureObject.idl():  			return "sullustan";
	return "sullustan";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	return "";
}

int CreatureObjectImplementation::getGender() {
	// server/zone/objects/creature/CreatureObject.idl():  		return gender;
	return gender;
}

DeltaVector<int>* CreatureObjectImplementation::getBaseHAM() {
	// server/zone/objects/creature/CreatureObject.idl():  		return baseHAM;
	return (&baseHAM);
}

SkillList* CreatureObjectImplementation::getSkillList() {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillList;
	return (&skillList);
}

bool CreatureObjectImplementation::hasSkill(const String& skill) {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillList.containsSkill(skill);
	return (&skillList)->containsSkill(skill);
}

SkillModList* CreatureObjectImplementation::getSkillModList() {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillModList;
	return (&skillModList);
}

void CreatureObjectImplementation::setWatchToID(unsigned long long id) {
	// server/zone/objects/creature/CreatureObject.idl():  		watchToID = id;
	watchToID = id;
}

bool CreatureObjectImplementation::isCreatureObject() {
	// server/zone/objects/creature/CreatureObject.idl():  		return true;
	return true;
}

bool CreatureObjectImplementation::isNextActionPast() {
	// server/zone/objects/creature/CreatureObject.idl():  		return nextAction.isPast();
	return (&nextAction)->isPast();
}

bool CreatureObjectImplementation::isTrainerCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

bool CreatureObjectImplementation::isSwimming() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.SWIMMING;
	return stateBitmask & CreatureState::SWIMMING;
}

ZoneClientSession* CreatureObjectImplementation::getClient() {
	// server/zone/objects/creature/CreatureObject.idl():  		return owner;
	return owner;
}

bool CreatureObjectImplementation::isRidingMount() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.RIDINGMOUNT;
	return stateBitmask & CreatureState::RIDINGMOUNT;
}

ManagedWeakReference<ControlDevice* > CreatureObjectImplementation::getControlDevice() {
	// server/zone/objects/creature/CreatureObject.idl():  		return controlDevice;
	return controlDevice;
}

float CreatureObjectImplementation::getSwimHeight() {
	// server/zone/objects/creature/CreatureObject.idl():  		return swimHeight;
	return swimHeight;
}

bool CreatureObjectImplementation::isIncapacitated() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.INCAPACITATED;
	return posture == CreaturePosture::INCAPACITATED;
}

bool CreatureObjectImplementation::isDead() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.DEAD;
	return posture == CreaturePosture::DEAD;
}

bool CreatureObjectImplementation::isKnockedDown() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.KNOCKEDDOWN;
	return posture == CreaturePosture::KNOCKEDDOWN;
}

bool CreatureObjectImplementation::isKneeling() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.CROUCHED;
	return posture == CreaturePosture::CROUCHED;
}

bool CreatureObjectImplementation::isProne() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.PRONE;
	return posture == CreaturePosture::PRONE;
}

bool CreatureObjectImplementation::isStanding() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.UPRIGHT;
	return posture == CreaturePosture::UPRIGHT;
}

bool CreatureObjectImplementation::isSitting() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.SITTING;
	return posture == CreaturePosture::SITTING;
}

bool CreatureObjectImplementation::isSkillAnimating() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.SKILLANIMATING;
	return posture == CreaturePosture::SKILLANIMATING;
}

bool CreatureObjectImplementation::isRallied() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.RALLIED;
	return stateBitmask & CreatureState::RALLIED;
}

bool CreatureObjectImplementation::isInCombat() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.COMBAT;
	return stateBitmask & CreatureState::COMBAT;
}

bool CreatureObjectImplementation::isDizzied() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.DIZZY;
	return stateBitmask & CreatureState::DIZZY;
}

bool CreatureObjectImplementation::isBerserked() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.BERSERK;
	return stateBitmask & CreatureState::BERSERK;
}

bool CreatureObjectImplementation::isStunned() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.STUNNED;
	return stateBitmask & CreatureState::STUNNED;
}

bool CreatureObjectImplementation::isBlinded() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.BLINDED;
	return stateBitmask & CreatureState::BLINDED;
}

bool CreatureObjectImplementation::isIntimidated() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.INTIMIDATED;
	return stateBitmask & CreatureState::INTIMIDATED;
}

bool CreatureObjectImplementation::isSnared() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.IMMOBILIZED;
	return stateBitmask & CreatureState::IMMOBILIZED;
}

bool CreatureObjectImplementation::isImmobilized() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.IMMOBILIZED;
	return stateBitmask & CreatureState::IMMOBILIZED;
}

bool CreatureObjectImplementation::isRooted() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.FROZEN;
	return stateBitmask & CreatureState::FROZEN;
}

bool CreatureObjectImplementation::isFrozen() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.FROZEN;
	return stateBitmask & CreatureState::FROZEN;
}

bool CreatureObjectImplementation::isDiseased() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.DISEASED;
	return stateBitmask & CreatureState::DISEASED;
}

bool CreatureObjectImplementation::isPoisoned() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.POISONED;
	return stateBitmask & CreatureState::POISONED;
}

bool CreatureObjectImplementation::isBleeding() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.BLEEDING;
	return stateBitmask & CreatureState::BLEEDING;
}

bool CreatureObjectImplementation::isOnFire() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.ONFIRE;
	return stateBitmask & CreatureState::ONFIRE;
}

bool CreatureObjectImplementation::isMounted() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.RIDINGMOUNT;
	return stateBitmask & CreatureState::RIDINGMOUNT;
}

bool CreatureObjectImplementation::isRidingCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.MOUNTEDCREATURE;
	return stateBitmask & CreatureState::MOUNTEDCREATURE;
}

bool CreatureObjectImplementation::isPeaced() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.PEACE;
	return stateBitmask & CreatureState::PEACE;
}

bool CreatureObjectImplementation::isMeditating() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.ALERT;
	return stateBitmask & CreatureState::ALERT;
}

bool CreatureObjectImplementation::isAiming() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.AIMING;
	return stateBitmask & CreatureState::AIMING;
}

bool CreatureObjectImplementation::isInCover() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.COVER;
	return stateBitmask & CreatureState::COVER;
}

bool CreatureObjectImplementation::isRunning() {
	// server/zone/objects/creature/CreatureObject.idl():  		return currentSpeed >= runSpeed;
	return currentSpeed >= runSpeed;
}

bool CreatureObjectImplementation::isNonPlayerCreatureObject() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

bool CreatureObjectImplementation::isCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

bool CreatureObjectImplementation::isPlayerCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return getPlayerObject() != null;
	return getPlayerObject() != NULL;
}

bool CreatureObjectImplementation::isAiActor() {
	// server/zone/objects/creature/CreatureObject.idl():  		return getActorObject() != null;
	return getActorObject() != NULL;
}

bool CreatureObjectImplementation::isInformantCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

byte CreatureObjectImplementation::getCurrentWeather() {
	// server/zone/objects/creature/CreatureObject.idl():  		return currentWeather;
	return currentWeather;
}

void CreatureObjectImplementation::setCurrentWeather(byte value) {
	// server/zone/objects/creature/CreatureObject.idl():  		currentWeather = value;
	currentWeather = value;
}

byte CreatureObjectImplementation::getCurrentWind() {
	// server/zone/objects/creature/CreatureObject.idl():  		return currentWind;
	return currentWind;
}

void CreatureObjectImplementation::setCurrentWind(byte value) {
	// server/zone/objects/creature/CreatureObject.idl():  		currentWind = value;
	currentWind = value;
}

void CreatureObjectImplementation::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	// server/zone/objects/creature/CreatureObject.idl():  	}
	if (isAiActor()){
	// server/zone/objects/creature/CreatureObject.idl():  			getActorObject().fillAttributeList(msg, object);
	getActorObject()->fillAttributeList(msg, object);
}
}

void CreatureObjectImplementation::destroyObjectFromWorld(bool sendSelfDestroy) {
	// server/zone/objects/creature/CreatureObject.idl():  		super.destroyObjectFromWorld(sendSelfDestroy);
	TangibleObjectImplementation::destroyObjectFromWorld(sendSelfDestroy);
	// server/zone/objects/creature/CreatureObject.idl():  	}
	if (isAiActor()){
	// server/zone/objects/creature/CreatureObject.idl():  			getActorObject().notifyDespawn(getZone());
	getActorObject()->notifyDespawn(getZone());
}
}

bool CreatureObjectImplementation::isInvisible() {
	// server/zone/objects/creature/CreatureObject.idl():  		return invisible;
	return invisible;
}

void CreatureObjectImplementation::setInvisible(bool invis) {
	// server/zone/objects/creature/CreatureObject.idl():  		invisible = invis;
	invisible = invis;
}

Mutex* CreatureObjectImplementation::getSkillModMutex() {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillModMutex;
	return (&skillModMutex);
}

/*
 *	CreatureObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


CreatureObjectAdapter::CreatureObjectAdapter(CreatureObject* obj) : TangibleObjectAdapter(obj) {
}

void CreatureObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZEMEMBERS__:
		{
			initializeMembers();
		}
		break;
	case RPC_FINALIZE__:
		{
			finalize();
		}
		break;
	case RPC_CREATECHILDOBJECTS__:
		{
			createChildObjects();
		}
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			initializeTransientMembers();
		}
		break;
	case RPC_CLEARQUEUEACTION__INT_FLOAT_INT_INT_:
		{
			clearQueueAction(inv->getUnsignedIntParameter(), inv->getFloatParameter(), inv->getUnsignedIntParameter(), inv->getUnsignedIntParameter());
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			sendBaselinesTo(static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SENDTOOWNER__BOOL_:
		{
			sendToOwner(inv->getBooleanParameter());
		}
		break;
	case RPC_SENDTO__SCENEOBJECT_BOOL_:
		{
			sendTo(static_cast<SceneObject*>(inv->getObjectParameter()), inv->getBooleanParameter());
		}
		break;
	case RPC_SENDSYSTEMMESSAGE__STRING_:
		{
			String message; 
			sendSystemMessage(inv->getAsciiParameter(message));
		}
		break;
	case RPC_PLAYMUSICMESSAGE__STRING_:
		{
			String file; 
			playMusicMessage(inv->getAsciiParameter(file));
		}
		break;
	case RPC_SENDNEWBIETUTORIALREQUEST__STRING_:
		{
			String request; 
			sendNewbieTutorialRequest(inv->getAsciiParameter(request));
		}
		break;
	case RPC_SENDNEWBIETUTORIALENABLEHUDELEMENT__STRING_BOOL_:
		{
			String ui; 
			sendNewbieTutorialEnableHudElement(inv->getAsciiParameter(ui), inv->getBooleanParameter());
		}
		break;
	case RPC_SENDOPENHOLOCRONTOPAGEMESSAGE__:
		{
			sendOpenHolocronToPageMessage();
		}
		break;
	case RPC_SENDSYSTEMMESSAGE__UNICODESTRING_:
		{
			UnicodeString message; 
			sendSystemMessage(inv->getUnicodeParameter(message));
		}
		break;
	case RPC_SENDSLOTTEDOBJECTSTO__SCENEOBJECT_:
		{
			sendSlottedObjectsTo(static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SETCOMBATSTATE__:
		{
			setCombatState();
		}
		break;
	case RPC_CLEARCOMBATSTATE__BOOL_:
		{
			clearCombatState(inv->getBooleanParameter());
		}
		break;
	case RPC_SETPOSTURE__INT_BOOL_:
		{
			setPosture(inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_CALCULATESPEED__:
		{
			resp->insertFloat(calculateSpeed());
		}
		break;
	case RPC_UPDATELOCOMOTION__:
		{
			updateLocomotion();
		}
		break;
	case RPC_SETHEIGHT__FLOAT_BOOL_:
		{
			setHeight(inv->getFloatParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETACCELERATIONMULTIPLIERBASE__FLOAT_BOOL_:
		{
			setAccelerationMultiplierBase(inv->getFloatParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_BOOL_:
		{
			setAccelerationMultiplierMod(inv->getFloatParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETSPEEDMULTIPLIERBASE__FLOAT_BOOL_:
		{
			setSpeedMultiplierBase(inv->getFloatParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETSPEEDMULTIPLIERMOD__FLOAT_BOOL_:
		{
			setSpeedMultiplierMod(inv->getFloatParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETTURNSCALE__FLOAT_BOOL_:
		{
			setTurnScale(inv->getFloatParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETRUNSPEED__FLOAT_BOOL_:
		{
			setRunSpeed(inv->getFloatParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETCURRENTSPEED__FLOAT_:
		{
			setCurrentSpeed(inv->getFloatParameter());
		}
		break;
	case RPC_SETHAM__INT_INT_BOOL_:
		{
			setHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_:
		{
			resp->insertSignedInt(inflictDamage(static_cast<TangibleObject*>(inv->getObjectParameter()), inv->getSignedIntParameter(), inv->getFloatParameter(), inv->getBooleanParameter(), inv->getBooleanParameter()));
		}
		break;
	case RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_:
		{
			String xp; 
			resp->insertSignedInt(inflictDamage(static_cast<TangibleObject*>(inv->getObjectParameter()), inv->getSignedIntParameter(), inv->getFloatParameter(), inv->getBooleanParameter(), inv->getAsciiParameter(xp), inv->getBooleanParameter()));
		}
		break;
	case RPC_HASDAMAGE__INT_:
		{
			resp->insertBoolean(hasDamage(inv->getSignedIntParameter()));
		}
		break;
	case RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_:
		{
			resp->insertSignedInt(healDamage(static_cast<TangibleObject*>(inv->getObjectParameter()), inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter(), inv->getBooleanParameter()));
		}
		break;
	case RPC_HEALWOUND__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_:
		{
			resp->insertSignedInt(healWound(static_cast<TangibleObject*>(inv->getObjectParameter()), inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter(), inv->getBooleanParameter()));
		}
		break;
	case RPC_SETBASEHAM__INT_INT_BOOL_:
		{
			setBaseHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETWOUNDS__INT_INT_BOOL_:
		{
			setWounds(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_ADDWOUNDS__INT_INT_BOOL_:
		{
			resp->insertSignedInt(addWounds(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter()));
		}
		break;
	case RPC_SETMAXHAM__INT_INT_BOOL_:
		{
			setMaxHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_ADDMAXHAM__INT_INT_BOOL_:
		{
			addMaxHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETENCUMBRANCE__INT_INT_BOOL_:
		{
			setEncumbrance(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_ADDENCUMBRANCE__INT_INT_BOOL_:
		{
			addEncumbrance(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETWEAPON__WEAPONOBJECT_BOOL_:
		{
			setWeapon(static_cast<WeaponObject*>(inv->getObjectParameter()), inv->getBooleanParameter());
		}
		break;
	case RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_:
		{
			resp->insertSignedInt(notifyObjectInserted(static_cast<SceneObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_:
		{
			resp->insertSignedInt(notifyObjectRemoved(static_cast<SceneObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_SETINSTRUMENTID__INT_BOOL_:
		{
			setInstrumentID(inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETLISTENTOID__LONG_BOOL_:
		{
			setListenToID(inv->getUnsignedLongParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETPERFORMANCECOUNTER__INT_BOOL_:
		{
			setPerformanceCounter(inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETPERFORMANCEANIMATION__STRING_BOOL_:
		{
			String animation; 
			setPerformanceAnimation(inv->getAsciiParameter(animation), inv->getBooleanParameter());
		}
		break;
	case RPC_SETSHOCKWOUNDS__INT_BOOL_:
		{
			setShockWounds(inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_ADDSHOCKWOUNDS__INT_BOOL_:
		{
			addShockWounds(inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETTARGETID__LONG_BOOL_:
		{
			setTargetID(inv->getUnsignedLongParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETBANKCREDITS__INT_BOOL_:
		{
			setBankCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_ADDBUFF__BUFF_:
		{
			addBuff(static_cast<Buff*>(inv->getObjectParameter()));
		}
		break;
	case RPC_REMOVEBUFF__INT_:
		{
			resp->insertBoolean(removeBuff(inv->getUnsignedIntParameter()));
		}
		break;
	case RPC_REMOVEBUFF__BUFF_:
		{
			removeBuff(static_cast<Buff*>(inv->getObjectParameter()));
		}
		break;
	case RPC_REMOVESTATEBUFF__LONG_:
		{
			resp->insertBoolean(removeStateBuff(inv->getUnsignedLongParameter()));
		}
		break;
	case RPC_CLEARBUFFS__BOOL_:
		{
			clearBuffs(inv->getBooleanParameter());
		}
		break;
	case RPC_ADDWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_:
		{
			addWearableObject(static_cast<TangibleObject*>(inv->getObjectParameter()), inv->getBooleanParameter());
		}
		break;
	case RPC_REMOVEWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_:
		{
			removeWearableObject(static_cast<TangibleObject*>(inv->getObjectParameter()), inv->getBooleanParameter());
		}
		break;
	case RPC_SENDBUFFSTO__CREATUREOBJECT_:
		{
			sendBuffsTo(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_GETBUFF__INT_:
		{
			resp->insertLong(getBuff(inv->getUnsignedIntParameter())->_getObjectID());
		}
		break;
	case RPC_GETSKILLMODFROMBUFFS__STRING_:
		{
			String skillMod; 
			resp->insertSignedLong(getSkillModFromBuffs(inv->getAsciiParameter(skillMod)));
		}
		break;
	case RPC_ADDDOTSTATE__LONG_LONG_INT_BYTE_INT_FLOAT_INT_:
		{
			resp->insertSignedInt(addDotState(inv->getUnsignedLongParameter(), inv->getUnsignedLongParameter(), inv->getUnsignedIntParameter(), inv->getByteParameter(), inv->getUnsignedIntParameter(), inv->getFloatParameter(), inv->getUnsignedIntParameter()));
		}
		break;
	case RPC_HEALDOT__LONG_INT_:
		{
			resp->insertBoolean(healDot(inv->getUnsignedLongParameter(), inv->getSignedIntParameter()));
		}
		break;
	case RPC_CLEARDOTS__:
		{
			clearDots();
		}
		break;
	case RPC_HASBUFF__INT_:
		{
			resp->insertBoolean(hasBuff(inv->getUnsignedIntParameter()));
		}
		break;
	case RPC_NOTIFYSELFPOSITIONUPDATE__:
		{
			notifySelfPositionUpdate();
		}
		break;
	case RPC_NOTIFYPOSTURECHANGE__INT_:
		{
			notifyPostureChange(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETLEVEL__INT_:
		{
			setLevel(inv->getSignedIntParameter());
		}
		break;
	case RPC_UPDATETODATABASEALLOBJECTS__BOOL_:
		{
			updateToDatabaseAllObjects(inv->getBooleanParameter());
		}
		break;
	case RPC_ISRESUSCITABLE__:
		{
			resp->insertBoolean(isResuscitable());
		}
		break;
	case RPC_ADDBANKCREDITS__INT_BOOL_:
		{
			addBankCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_ADDCASHCREDITS__INT_BOOL_:
		{
			addCashCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SUBTRACTBANKCREDITS__INT_:
		{
			subtractBankCredits(inv->getSignedIntParameter());
		}
		break;
	case RPC_SUBTRACTCASHCREDITS__INT_:
		{
			subtractCashCredits(inv->getSignedIntParameter());
		}
		break;
	case RPC_VERIFYCASHCREDITS__INT_:
		{
			resp->insertBoolean(verifyCashCredits(inv->getSignedIntParameter()));
		}
		break;
	case RPC_VERIFYBANKCREDITS__INT_:
		{
			resp->insertBoolean(verifyBankCredits(inv->getSignedIntParameter()));
		}
		break;
	case RPC_ISDANCING__:
		{
			resp->insertBoolean(isDancing());
		}
		break;
	case RPC_ISPLAYINGMUSIC__:
		{
			resp->insertBoolean(isPlayingMusic());
		}
		break;
	case RPC_STOPENTERTAINING__:
		{
			stopEntertaining();
		}
		break;
	case RPC_ISENTERTAINING__:
		{
			resp->insertBoolean(isEntertaining());
		}
		break;
	case RPC_SETCASHCREDITS__INT_BOOL_:
		{
			setCashCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETTERRAINNEGOTIATION__FLOAT_BOOL_:
		{
			setTerrainNegotiation(inv->getFloatParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_ADDSKILL__STRING_BOOL_:
		{
			String skill; 
			addSkill(inv->getAsciiParameter(skill), inv->getBooleanParameter());
		}
		break;
	case RPC_REMOVESKILL__STRING_BOOL_:
		{
			String skill; 
			removeSkill(inv->getAsciiParameter(skill), inv->getBooleanParameter());
		}
		break;
	case RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_:
		{
			String skillMod; 
			addSkillMod(inv->getSignedIntParameter(), inv->getAsciiParameter(skillMod), inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_REMOVESKILLMOD__INT_STRING_INT_BOOL_:
		{
			String skillMod; 
			removeSkillMod(inv->getSignedIntParameter(), inv->getAsciiParameter(skillMod), inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_REMOVEALLSKILLMODSOFTYPE__INT_BOOL_:
		{
			removeAllSkillModsOfType(inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_UPDATEGROUPINVITERID__LONG_BOOL_:
		{
			updateGroupInviterID(inv->getUnsignedLongParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_UPDATEGROUP__GROUPOBJECT_BOOL_:
		{
			updateGroup(static_cast<GroupObject*>(inv->getObjectParameter()), inv->getBooleanParameter());
		}
		break;
	case RPC_ENQUEUECOMMAND__INT_INT_LONG_UNICODESTRING_INT_:
		{
			UnicodeString arguments; 
			enqueueCommand(inv->getUnsignedIntParameter(), inv->getUnsignedIntParameter(), inv->getUnsignedLongParameter(), inv->getUnicodeParameter(arguments), inv->getSignedIntParameter());
		}
		break;
	case RPC_SETMOOD__BYTE_BOOL_:
		{
			setMood(inv->getByteParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_SETMOODSTRING__STRING_BOOL_:
		{
			String animation; 
			setMoodString(inv->getAsciiParameter(animation), inv->getBooleanParameter());
		}
		break;
	case RPC_DELETEQUEUEACTION__INT_:
		{
			deleteQueueAction(inv->getUnsignedIntParameter());
		}
		break;
	case RPC_SETSTATE__LONG_BOOL_:
		{
			resp->insertBoolean(setState(inv->getUnsignedLongParameter(), inv->getBooleanParameter()));
		}
		break;
	case RPC_CLEARSTATE__LONG_BOOL_:
		{
			resp->insertBoolean(clearState(inv->getUnsignedLongParameter(), inv->getBooleanParameter()));
		}
		break;
	case RPC_SETCONTROLDEVICE__CONTROLDEVICE_:
		{
			setControlDevice(static_cast<ControlDevice*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SETCREATURELINK__CREATUREOBJECT_BOOL_:
		{
			setCreatureLink(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getBooleanParameter());
		}
		break;
	case RPC_EXECUTEOBJECTCONTROLLERACTION__INT_:
		{
			executeObjectControllerAction(inv->getUnsignedIntParameter());
		}
		break;
	case RPC_EXECUTEOBJECTCONTROLLERACTION__INT_LONG_UNICODESTRING_:
		{
			UnicodeString args; 
			executeObjectControllerAction(inv->getUnsignedIntParameter(), inv->getUnsignedLongParameter(), inv->getUnicodeParameter(args));
		}
		break;
	case RPC_ISATTACKABLEBY__CREATUREOBJECT_:
		{
			resp->insertBoolean(isAttackableBy(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ISATTACKABLEBY__TANGIBLEOBJECT_:
		{
			resp->insertBoolean(isAttackableBy(static_cast<TangibleObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ISHEALABLEBY__CREATUREOBJECT_:
		{
			resp->insertBoolean(isHealableBy(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ISINBOUNTYMISSION__CREATUREOBJECT_CREATUREOBJECT_:
		{
			resp->insertBoolean(isInBountyMission(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_:
		{
			sendConversationStartTo(static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_:
		{
			selectConversationOption(inv->getSignedIntParameter(), static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SENDMESSAGE__BASEPACKET_:
		{
			sendMessage(static_cast<BasePacket*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SENDEXECUTECONSOLECOMMAND__STRING_:
		{
			String command; 
			sendExecuteConsoleCommand(inv->getAsciiParameter(command));
		}
		break;
	case RPC_ISAGGRESSIVETO__CREATUREOBJECT_:
		{
			resp->insertBoolean(isAggressiveTo(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_:
		{
			resp->insertSignedInt(notifyObjectDestructionObservers(static_cast<TangibleObject*>(inv->getObjectParameter()), inv->getSignedIntParameter()));
		}
		break;
	case RPC_NOTIFYOBJECTKILLOBSERVERS__TANGIBLEOBJECT_:
		{
			resp->insertSignedInt(notifyObjectKillObservers(static_cast<TangibleObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			notifyLoadFromDatabase();
		}
		break;
	case RPC_SETFACTIONRANK__INT_BOOL_:
		{
			setFactionRank(inv->getSignedIntParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_GETFIRSTNAME__:
		{
			resp->insertAscii(getFirstName());
		}
		break;
	case RPC_GETLASTNAME__:
		{
			resp->insertAscii(getLastName());
		}
		break;
	case RPC_ISONLINE__:
		{
			resp->insertBoolean(isOnline());
		}
		break;
	case RPC_CANTREATINJURIES__:
		{
			resp->insertBoolean(canTreatInjuries());
		}
		break;
	case RPC_CANTREATSTATES__:
		{
			resp->insertBoolean(canTreatStates());
		}
		break;
	case RPC_CANTREATWOUNDS__:
		{
			resp->insertBoolean(canTreatWounds());
		}
		break;
	case RPC_CANTREATCONDITIONS__:
		{
			resp->insertBoolean(canTreatConditions());
		}
		break;
	case RPC_GETPLAYEROBJECT__:
		{
			resp->insertLong(getPlayerObject()->_getObjectID());
		}
		break;
	case RPC_GETACTOROBJECT__:
		{
			resp->insertLong(getActorObject()->_getObjectID());
		}
		break;
	case RPC_ISLISTENING__:
		{
			resp->insertBoolean(isListening());
		}
		break;
	case RPC_ISWATCHING__:
		{
			resp->insertBoolean(isWatching());
		}
		break;
	case RPC_SETCLIENT__ZONECLIENTSESSION_:
		{
			setClient(static_cast<ZoneClientSession*>(inv->getObjectParameter()));
		}
		break;
	case RPC_DISMOUNT__:
		{
			dismount();
		}
		break;
	case RPC_CALCULATEBFRATIO__:
		{
			resp->insertFloat(calculateBFRatio());
		}
		break;
	case RPC_SETDIZZIEDSTATE__INT_:
		{
			setDizziedState(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETRALLIEDSTATE__INT_:
		{
			setRalliedState(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETAIMINGSTATE__INT_:
		{
			setAimingState(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETCOVERSTATE__INT_:
		{
			setCoverState(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETBERSERKEDSTATE__INT_:
		{
			setBerserkedState(inv->getUnsignedIntParameter());
		}
		break;
	case RPC_SETSTUNNEDSTATE__INT_:
		{
			setStunnedState(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETBLINDEDSTATE__INT_:
		{
			setBlindedState(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETINTIMIDATEDSTATE__INT_INT_:
		{
			setIntimidatedState(inv->getUnsignedIntParameter(), inv->getSignedIntParameter());
		}
		break;
	case RPC_SETSNAREDSTATE__INT_:
		{
			setSnaredState(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETROOTEDSTATE__INT_:
		{
			setRootedState(inv->getSignedIntParameter());
		}
		break;
	case RPC_SETNEXTATTACKDELAY__INT_INT_:
		{
			resp->insertBoolean(setNextAttackDelay(inv->getUnsignedIntParameter(), inv->getSignedIntParameter()));
		}
		break;
	case RPC_SETMEDITATESTATE__:
		{
			setMeditateState();
		}
		break;
	case RPC_ACTIVATEHAMREGENERATION__:
		{
			activateHAMRegeneration();
		}
		break;
	case RPC_ACTIVATEPASSIVEWOUNDREGENERATION__:
		{
			activatePassiveWoundRegeneration();
		}
		break;
	case RPC_ACTIVATESTATERECOVERY__:
		{
			activateStateRecovery();
		}
		break;
	case RPC_UPDATETIMEOFDEATH__:
		{
			updateTimeOfDeath();
		}
		break;
	case RPC_HASATTACKDELAY__:
		{
			resp->insertBoolean(hasAttackDelay());
		}
		break;
	case RPC_REMOVEATTACKDELAY__:
		{
			removeAttackDelay();
		}
		break;
	case RPC_HASSPICE__:
		{
			resp->insertBoolean(hasSpice());
		}
		break;
	case RPC_UPDATELASTSUCCESSFULCOMBATACTION__:
		{
			updateLastSuccessfulCombatAction();
		}
		break;
	case RPC_UPDATEKNOCKDOWNRECOVERY__:
		{
			updateKnockdownRecovery();
		}
		break;
	case RPC_QUEUEDIZZYFALLEVENT__:
		{
			queueDizzyFallEvent();
		}
		break;
	case RPC_UPDATELASTKNOCKDOWN__:
		{
			updateLastKnockdown();
		}
		break;
	case RPC_CHECKKNOCKDOWNRECOVERY__:
		{
			resp->insertBoolean(checkKnockdownRecovery());
		}
		break;
	case RPC_CHECKLASTKNOCKDOWN__:
		{
			resp->insertBoolean(checkLastKnockdown());
		}
		break;
	case RPC_UPDATEPOSTUREDOWNRECOVERY__:
		{
			updatePostureDownRecovery();
		}
		break;
	case RPC_UPDATEPOSTUREUPRECOVERY__:
		{
			updatePostureUpRecovery();
		}
		break;
	case RPC_CHECKPOSTUREDOWNRECOVERY__:
		{
			resp->insertBoolean(checkPostureDownRecovery());
		}
		break;
	case RPC_GETSCREENPLAYSTATE__STRING_:
		{
			String screenPlay; 
			resp->insertLong(getScreenPlayState(inv->getAsciiParameter(screenPlay)));
		}
		break;
	case RPC_SETSCREENPLAYSTATE__STRING_LONG_:
		{
			String screenPlay; 
			setScreenPlayState(inv->getAsciiParameter(screenPlay), inv->getUnsignedLongParameter());
		}
		break;
	case RPC_CHECKPOSTUREUPRECOVERY__:
		{
			resp->insertBoolean(checkPostureUpRecovery());
		}
		break;
	case RPC_UPDATECOOLDOWNTIMER__STRING_INT_:
		{
			String coooldownTimer; 
			updateCooldownTimer(inv->getAsciiParameter(coooldownTimer), inv->getUnsignedIntParameter());
		}
		break;
	case RPC_CHECKCOOLDOWNRECOVERY__STRING_:
		{
			String cooldown; 
			resp->insertBoolean(checkCooldownRecovery(inv->getAsciiParameter(cooldown)));
		}
		break;
	case RPC_ADDCOOLDOWN__STRING_INT_:
		{
			String name; 
			addCooldown(inv->getAsciiParameter(name), inv->getUnsignedIntParameter());
		}
		break;
	case RPC_DOANIMATION__STRING_:
		{
			String animation; 
			doAnimation(inv->getAsciiParameter(animation));
		}
		break;
	case RPC_DOCOMBATANIMATION__CREATUREOBJECT_INT_BYTE_BYTE_:
		{
			doCombatAnimation(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getUnsignedIntParameter(), inv->getByteParameter(), inv->getByteParameter());
		}
		break;
	case RPC_PLAYEFFECT__STRING_STRING_:
		{
			String file; String aux; 
			playEffect(inv->getAsciiParameter(file), inv->getAsciiParameter(aux));
		}
		break;
	case RPC_PLAYEFFECT__STRING_:
		{
			String file; 
			playEffect(inv->getAsciiParameter(file));
		}
		break;
	case RPC_ACTIVATEQUEUEACTION__:
		{
			activateQueueAction();
		}
		break;
	case RPC_ACTIVATEIMMEDIATEACTION__:
		{
			activateImmediateAction();
		}
		break;
	case RPC_GETCREATURENAME__:
		{
			resp->insertUnicode(getCreatureName());
		}
		break;
	case RPC_ISGROUPED__:
		{
			resp->insertBoolean(isGrouped());
		}
		break;
	case RPC_GETBANKCREDITS__:
		{
			resp->insertSignedInt(getBankCredits());
		}
		break;
	case RPC_GETCASHCREDITS__:
		{
			resp->insertSignedInt(getCashCredits());
		}
		break;
	case RPC_GETBASEHAM__INT_:
		{
			resp->insertSignedInt(getBaseHAM(inv->getSignedIntParameter()));
		}
		break;
	case RPC_GETWOUNDS__INT_:
		{
			resp->insertSignedInt(getWounds(inv->getSignedIntParameter()));
		}
		break;
	case RPC_GETHAM__INT_:
		{
			resp->insertSignedInt(getHAM(inv->getSignedIntParameter()));
		}
		break;
	case RPC_GETMAXHAM__INT_:
		{
			resp->insertSignedInt(getMaxHAM(inv->getSignedIntParameter()));
		}
		break;
	case RPC_GETENCUMBRANCE__INT_:
		{
			resp->insertSignedInt(getEncumbrance(inv->getSignedIntParameter()));
		}
		break;
	case RPC_GETPOSTURE__:
		{
			resp->insertByte(getPosture());
		}
		break;
	case RPC_GETLOCOMOTION__:
		{
			resp->insertByte(getLocomotion());
		}
		break;
	case RPC_GETFACTIONRANK__:
		{
			resp->insertByte(getFactionRank());
		}
		break;
	case RPC_GETLINKEDCREATURE__:
		{
			resp->insertLong(getLinkedCreature().get()->_getObjectID());
		}
		break;
	case RPC_GETCREATURELINKID__:
		{
			resp->insertLong(getCreatureLinkID());
		}
		break;
	case RPC_GETSHOCKWOUNDS__:
		{
			resp->insertFloat(getShockWounds());
		}
		break;
	case RPC_GETWATCHTOID__:
		{
			resp->insertLong(getWatchToID());
		}
		break;
	case RPC_GETSTATEBITMASK__:
		{
			resp->insertLong(getStateBitmask());
		}
		break;
	case RPC_HASSTATE__LONG_:
		{
			resp->insertBoolean(hasState(inv->getUnsignedLongParameter()));
		}
		break;
	case RPC_HASSTATES__:
		{
			resp->insertBoolean(hasStates());
		}
		break;
	case RPC_GETLISTENID__:
		{
			resp->insertLong(getListenID());
		}
		break;
	case RPC_GETACCELERATIONMULTIPLIERBASE__:
		{
			resp->insertFloat(getAccelerationMultiplierBase());
		}
		break;
	case RPC_GETACCELERATIONMULTIPLIERMOD__:
		{
			resp->insertFloat(getAccelerationMultiplierMod());
		}
		break;
	case RPC_GETSPEEDMULTIPLIERBASE__:
		{
			resp->insertFloat(getSpeedMultiplierBase());
		}
		break;
	case RPC_GETSPEEDMULTIPLIERMOD__:
		{
			resp->insertFloat(getSpeedMultiplierMod());
		}
		break;
	case RPC_GETCURRENTSPEED__:
		{
			resp->insertFloat(getCurrentSpeed());
		}
		break;
	case RPC_GETRUNSPEED__:
		{
			resp->insertFloat(getRunSpeed());
		}
		break;
	case RPC_GETWALKSPEED__:
		{
			resp->insertFloat(getWalkSpeed());
		}
		break;
	case RPC_GETTURNSCALE__:
		{
			resp->insertFloat(getTurnScale());
		}
		break;
	case RPC_GETTERRAINNEGOTIATION__:
		{
			resp->insertFloat(getTerrainNegotiation());
		}
		break;
	case RPC_GETRUNACCELERATION__:
		{
			resp->insertFloat(getRunAcceleration());
		}
		break;
	case RPC_GETWALKACCELERATION__:
		{
			resp->insertFloat(getWalkAcceleration());
		}
		break;
	case RPC_GETPERFORMANCEANIMATION__:
		{
			resp->insertAscii(getPerformanceAnimation());
		}
		break;
	case RPC_GETMOODSTRING__:
		{
			resp->insertAscii(getMoodString());
		}
		break;
	case RPC_GETWEAPONID__:
		{
			resp->insertLong(getWeaponID());
		}
		break;
	case RPC_GETWEAPON__:
		{
			resp->insertLong(getWeapon()->_getObjectID());
		}
		break;
	case RPC_GETGUILDOBJECT__:
		{
			resp->insertLong(getGuildObject()->_getObjectID());
		}
		break;
	case RPC_GETGUILDID__:
		{
			resp->insertSignedInt(getGuildID());
		}
		break;
	case RPC_ISINGUILD__:
		{
			resp->insertBoolean(isInGuild());
		}
		break;
	case RPC_SETGUILDOBJECT__GUILDOBJECT_:
		{
			setGuildObject(static_cast<GuildObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_GETGROUPID__:
		{
			resp->insertLong(getGroupID());
		}
		break;
	case RPC_GETGROUPINVITERID__:
		{
			resp->insertLong(getGroupInviterID());
		}
		break;
	case RPC_GETGROUP__:
		{
			resp->insertLong(getGroup()->_getObjectID());
		}
		break;
	case RPC_GETGROUPINVITECOUNTER__:
		{
			resp->insertLong(getGroupInviteCounter());
		}
		break;
	case RPC_GETTARGETID__:
		{
			resp->insertLong(getTargetID());
		}
		break;
	case RPC_GETMOODID__:
		{
			resp->insertByte(getMoodID());
		}
		break;
	case RPC_GETSLOPEMODPERCENT__:
		{
			resp->insertFloat(getSlopeModPercent());
		}
		break;
	case RPC_GETPERFORMANCECOUNTER__:
		{
			resp->insertSignedInt(getPerformanceCounter());
		}
		break;
	case RPC_GETINSTRUMENTID__:
		{
			resp->insertSignedInt(getInstrumentID());
		}
		break;
	case RPC_GETFROZEN__:
		{
			resp->insertByte(getFrozen());
		}
		break;
	case RPC_GETHEIGHT__:
		{
			resp->insertFloat(getHeight());
		}
		break;
	case RPC_GETSPECIES__:
		{
			resp->insertSignedInt(getSpecies());
		}
		break;
	case RPC_GETSPECIESNAME__:
		{
			resp->insertAscii(getSpeciesName());
		}
		break;
	case RPC_GETGENDER__:
		{
			resp->insertSignedInt(getGender());
		}
		break;
	case RPC_GETSKILLMOD__STRING_:
		{
			String skillmod; 
			resp->insertSignedInt(getSkillMod(inv->getAsciiParameter(skillmod)));
		}
		break;
	case RPC_HASSKILL__STRING_:
		{
			String skill; 
			resp->insertBoolean(hasSkill(inv->getAsciiParameter(skill)));
		}
		break;
	case RPC_SETWATCHTOID__LONG_:
		{
			setWatchToID(inv->getUnsignedLongParameter());
		}
		break;
	case RPC_ISCREATUREOBJECT__:
		{
			resp->insertBoolean(isCreatureObject());
		}
		break;
	case RPC_ISNEXTACTIONPAST__:
		{
			resp->insertBoolean(isNextActionPast());
		}
		break;
	case RPC_ISTRAINERCREATURE__:
		{
			resp->insertBoolean(isTrainerCreature());
		}
		break;
	case RPC_ISSWIMMING__:
		{
			resp->insertBoolean(isSwimming());
		}
		break;
	case RPC_GETCLIENT__:
		{
			resp->insertLong(getClient()->_getObjectID());
		}
		break;
	case RPC_ISRIDINGMOUNT__:
		{
			resp->insertBoolean(isRidingMount());
		}
		break;
	case RPC_GETCONTROLDEVICE__:
		{
			resp->insertLong(getControlDevice().get()->_getObjectID());
		}
		break;
	case RPC_GETSWIMHEIGHT__:
		{
			resp->insertFloat(getSwimHeight());
		}
		break;
	case RPC_ISINCAPACITATED__:
		{
			resp->insertBoolean(isIncapacitated());
		}
		break;
	case RPC_ISDEAD__:
		{
			resp->insertBoolean(isDead());
		}
		break;
	case RPC_ISKNOCKEDDOWN__:
		{
			resp->insertBoolean(isKnockedDown());
		}
		break;
	case RPC_ISKNEELING__:
		{
			resp->insertBoolean(isKneeling());
		}
		break;
	case RPC_ISPRONE__:
		{
			resp->insertBoolean(isProne());
		}
		break;
	case RPC_ISSTANDING__:
		{
			resp->insertBoolean(isStanding());
		}
		break;
	case RPC_ISSITTING__:
		{
			resp->insertBoolean(isSitting());
		}
		break;
	case RPC_ISSKILLANIMATING__:
		{
			resp->insertBoolean(isSkillAnimating());
		}
		break;
	case RPC_ISRALLIED__:
		{
			resp->insertBoolean(isRallied());
		}
		break;
	case RPC_ISINCOMBAT__:
		{
			resp->insertBoolean(isInCombat());
		}
		break;
	case RPC_ISDIZZIED__:
		{
			resp->insertBoolean(isDizzied());
		}
		break;
	case RPC_ISBERSERKED__:
		{
			resp->insertBoolean(isBerserked());
		}
		break;
	case RPC_ISSTUNNED__:
		{
			resp->insertBoolean(isStunned());
		}
		break;
	case RPC_ISBLINDED__:
		{
			resp->insertBoolean(isBlinded());
		}
		break;
	case RPC_ISINTIMIDATED__:
		{
			resp->insertBoolean(isIntimidated());
		}
		break;
	case RPC_ISSNARED__:
		{
			resp->insertBoolean(isSnared());
		}
		break;
	case RPC_ISIMMOBILIZED__:
		{
			resp->insertBoolean(isImmobilized());
		}
		break;
	case RPC_ISROOTED__:
		{
			resp->insertBoolean(isRooted());
		}
		break;
	case RPC_ISFROZEN__:
		{
			resp->insertBoolean(isFrozen());
		}
		break;
	case RPC_ISDISEASED__:
		{
			resp->insertBoolean(isDiseased());
		}
		break;
	case RPC_ISPOISONED__:
		{
			resp->insertBoolean(isPoisoned());
		}
		break;
	case RPC_ISBLEEDING__:
		{
			resp->insertBoolean(isBleeding());
		}
		break;
	case RPC_ISONFIRE__:
		{
			resp->insertBoolean(isOnFire());
		}
		break;
	case RPC_ISMOUNTED__:
		{
			resp->insertBoolean(isMounted());
		}
		break;
	case RPC_ISRIDINGCREATURE__:
		{
			resp->insertBoolean(isRidingCreature());
		}
		break;
	case RPC_ISPEACED__:
		{
			resp->insertBoolean(isPeaced());
		}
		break;
	case RPC_ISMEDITATING__:
		{
			resp->insertBoolean(isMeditating());
		}
		break;
	case RPC_ISAIMING__:
		{
			resp->insertBoolean(isAiming());
		}
		break;
	case RPC_ISINCOVER__:
		{
			resp->insertBoolean(isInCover());
		}
		break;
	case RPC_ISRUNNING__:
		{
			resp->insertBoolean(isRunning());
		}
		break;
	case RPC_ISNONPLAYERCREATUREOBJECT__:
		{
			resp->insertBoolean(isNonPlayerCreatureObject());
		}
		break;
	case RPC_ISCREATURE__:
		{
			resp->insertBoolean(isCreature());
		}
		break;
	case RPC_ISPLAYERCREATURE__:
		{
			resp->insertBoolean(isPlayerCreature());
		}
		break;
	case RPC_ISAIACTOR__:
		{
			resp->insertBoolean(isAiActor());
		}
		break;
	case RPC_ISINFORMANTCREATURE__:
		{
			resp->insertBoolean(isInformantCreature());
		}
		break;
	case RPC_GETCURRENTCAMP__:
		{
			resp->insertLong(getCurrentCamp()->_getObjectID());
		}
		break;
	case RPC_GETCURRENTWEATHER__:
		{
			resp->insertByte(getCurrentWeather());
		}
		break;
	case RPC_SETCURRENTWEATHER__BYTE_:
		{
			setCurrentWeather(inv->getByteParameter());
		}
		break;
	case RPC_GETCURRENTWIND__:
		{
			resp->insertByte(getCurrentWind());
		}
		break;
	case RPC_SETCURRENTWIND__BYTE_:
		{
			setCurrentWind(inv->getByteParameter());
		}
		break;
	case RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_:
		{
			resp->insertSignedInt(handleObjectMenuSelect(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getByteParameter()));
		}
		break;
	case RPC_FILLATTRIBUTELIST__ATTRIBUTELISTMESSAGE_CREATUREOBJECT_:
		{
			fillAttributeList(static_cast<AttributeListMessage*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_DESTROYOBJECTFROMWORLD__BOOL_:
		{
			destroyObjectFromWorld(inv->getBooleanParameter());
		}
		break;
	case RPC_ISINVISIBLE__:
		{
			resp->insertBoolean(isInvisible());
		}
		break;
	case RPC_SETINVISIBLE__BOOL_:
		{
			setInvisible(inv->getBooleanParameter());
		}
		break;
	case RPC_CALCULATECOSTADJUSTMENT__BYTE_FLOAT_:
		{
			resp->insertFloat(calculateCostAdjustment(inv->getByteParameter(), inv->getFloatParameter()));
		}
		break;
	default:
		throw Exception("Method does not exists");
	}
}

void CreatureObjectAdapter::initializeMembers() {
	(static_cast<CreatureObject*>(stub))->initializeMembers();
}

void CreatureObjectAdapter::finalize() {
	(static_cast<CreatureObject*>(stub))->finalize();
}

void CreatureObjectAdapter::createChildObjects() {
	(static_cast<CreatureObject*>(stub))->createChildObjects();
}

void CreatureObjectAdapter::initializeTransientMembers() {
	(static_cast<CreatureObject*>(stub))->initializeTransientMembers();
}

void CreatureObjectAdapter::clearQueueAction(unsigned int actioncntr, float timer, unsigned int tab1, unsigned int tab2) {
	(static_cast<CreatureObject*>(stub))->clearQueueAction(actioncntr, timer, tab1, tab2);
}

void CreatureObjectAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<CreatureObject*>(stub))->sendBaselinesTo(player);
}

void CreatureObjectAdapter::sendToOwner(bool doClose) {
	(static_cast<CreatureObject*>(stub))->sendToOwner(doClose);
}

void CreatureObjectAdapter::sendTo(SceneObject* player, bool doClose) {
	(static_cast<CreatureObject*>(stub))->sendTo(player, doClose);
}

void CreatureObjectAdapter::sendSystemMessage(const String& message) {
	(static_cast<CreatureObject*>(stub))->sendSystemMessage(message);
}

void CreatureObjectAdapter::playMusicMessage(const String& file) {
	(static_cast<CreatureObject*>(stub))->playMusicMessage(file);
}

void CreatureObjectAdapter::sendNewbieTutorialRequest(const String& request) {
	(static_cast<CreatureObject*>(stub))->sendNewbieTutorialRequest(request);
}

void CreatureObjectAdapter::sendNewbieTutorialEnableHudElement(const String& ui, bool enable) {
	(static_cast<CreatureObject*>(stub))->sendNewbieTutorialEnableHudElement(ui, enable);
}

void CreatureObjectAdapter::sendOpenHolocronToPageMessage() {
	(static_cast<CreatureObject*>(stub))->sendOpenHolocronToPageMessage();
}

void CreatureObjectAdapter::sendSystemMessage(UnicodeString& message) {
	(static_cast<CreatureObject*>(stub))->sendSystemMessage(message);
}

void CreatureObjectAdapter::sendSlottedObjectsTo(SceneObject* player) {
	(static_cast<CreatureObject*>(stub))->sendSlottedObjectsTo(player);
}

void CreatureObjectAdapter::setCombatState() {
	(static_cast<CreatureObject*>(stub))->setCombatState();
}

void CreatureObjectAdapter::clearCombatState(bool clearDefenders) {
	(static_cast<CreatureObject*>(stub))->clearCombatState(clearDefenders);
}

void CreatureObjectAdapter::setPosture(int newPosture, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setPosture(newPosture, notifyClient);
}

float CreatureObjectAdapter::calculateSpeed() {
	return (static_cast<CreatureObject*>(stub))->calculateSpeed();
}

void CreatureObjectAdapter::updateLocomotion() {
	(static_cast<CreatureObject*>(stub))->updateLocomotion();
}

void CreatureObjectAdapter::setHeight(float heigh, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setHeight(heigh, notifyClient);
}

void CreatureObjectAdapter::setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setAccelerationMultiplierBase(newMultiplierBase, notifyClient);
}

void CreatureObjectAdapter::setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setAccelerationMultiplierMod(newMultiplierMod, notifyClient);
}

void CreatureObjectAdapter::setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setSpeedMultiplierBase(newMultiplierBase, notifyClient);
}

void CreatureObjectAdapter::setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setSpeedMultiplierMod(newMultiplierMod, notifyClient);
}

void CreatureObjectAdapter::setTurnScale(float newMultiplierMod, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setTurnScale(newMultiplierMod, notifyClient);
}

void CreatureObjectAdapter::setRunSpeed(float newSpeed, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setRunSpeed(newSpeed, notifyClient);
}

void CreatureObjectAdapter::setCurrentSpeed(float newSpeed) {
	(static_cast<CreatureObject*>(stub))->setCurrentSpeed(newSpeed);
}

void CreatureObjectAdapter::setHAM(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setHAM(type, value, notifyClient);
}

int CreatureObjectAdapter::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient) {
	return (static_cast<CreatureObject*>(stub))->inflictDamage(attacker, damageType, damage, destroy, notifyClient);
}

int CreatureObjectAdapter::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient) {
	return (static_cast<CreatureObject*>(stub))->inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient);
}

bool CreatureObjectAdapter::hasDamage(int attribute) {
	return (static_cast<CreatureObject*>(stub))->hasDamage(attribute);
}

int CreatureObjectAdapter::healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers) {
	return (static_cast<CreatureObject*>(stub))->healDamage(healer, damageType, damage, notifyClient, notifyObservers);
}

int CreatureObjectAdapter::healWound(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers) {
	return (static_cast<CreatureObject*>(stub))->healWound(healer, damageType, damage, notifyClient, notifyObservers);
}

void CreatureObjectAdapter::setBaseHAM(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setBaseHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::setWounds(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setWounds(type, value, notifyClient);
}

int CreatureObjectAdapter::addWounds(int type, int value, bool notifyClient) {
	return (static_cast<CreatureObject*>(stub))->addWounds(type, value, notifyClient);
}

void CreatureObjectAdapter::setMaxHAM(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setMaxHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::addMaxHAM(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addMaxHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::setEncumbrance(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setEncumbrance(type, value, notifyClient);
}

void CreatureObjectAdapter::addEncumbrance(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addEncumbrance(type, value, notifyClient);
}

void CreatureObjectAdapter::setWeapon(WeaponObject* weao, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setWeapon(weao, notifyClient);
}

int CreatureObjectAdapter::notifyObjectInserted(SceneObject* object) {
	return (static_cast<CreatureObject*>(stub))->notifyObjectInserted(object);
}

int CreatureObjectAdapter::notifyObjectRemoved(SceneObject* object) {
	return (static_cast<CreatureObject*>(stub))->notifyObjectRemoved(object);
}

void CreatureObjectAdapter::setInstrumentID(int instrumentid, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setInstrumentID(instrumentid, notifyClient);
}

void CreatureObjectAdapter::setListenToID(unsigned long long id, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setListenToID(id, notifyClient);
}

void CreatureObjectAdapter::setPerformanceCounter(int counter, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setPerformanceCounter(counter, notifyClient);
}

void CreatureObjectAdapter::setPerformanceAnimation(const String& animation, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setPerformanceAnimation(animation, notifyClient);
}

void CreatureObjectAdapter::setShockWounds(int newShock, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setShockWounds(newShock, notifyClient);
}

void CreatureObjectAdapter::addShockWounds(int shockToAdd, bool notiyClient) {
	(static_cast<CreatureObject*>(stub))->addShockWounds(shockToAdd, notiyClient);
}

void CreatureObjectAdapter::setTargetID(unsigned long long targetID, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setTargetID(targetID, notifyClient);
}

void CreatureObjectAdapter::setBankCredits(int credits, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setBankCredits(credits, notifyClient);
}

void CreatureObjectAdapter::addBuff(Buff* buff) {
	(static_cast<CreatureObject*>(stub))->addBuff(buff);
}

bool CreatureObjectAdapter::removeBuff(unsigned int buffcrc) {
	return (static_cast<CreatureObject*>(stub))->removeBuff(buffcrc);
}

void CreatureObjectAdapter::removeBuff(Buff* buff) {
	(static_cast<CreatureObject*>(stub))->removeBuff(buff);
}

bool CreatureObjectAdapter::removeStateBuff(unsigned long long state) {
	return (static_cast<CreatureObject*>(stub))->removeStateBuff(state);
}

void CreatureObjectAdapter::clearBuffs(bool updateclient) {
	(static_cast<CreatureObject*>(stub))->clearBuffs(updateclient);
}

void CreatureObjectAdapter::addWearableObject(TangibleObject* object, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addWearableObject(object, notifyClient);
}

void CreatureObjectAdapter::removeWearableObject(TangibleObject* object, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->removeWearableObject(object, notifyClient);
}

void CreatureObjectAdapter::sendBuffsTo(CreatureObject* creature) {
	(static_cast<CreatureObject*>(stub))->sendBuffsTo(creature);
}

Buff* CreatureObjectAdapter::getBuff(unsigned int buffcrc) {
	return (static_cast<CreatureObject*>(stub))->getBuff(buffcrc);
}

long long CreatureObjectAdapter::getSkillModFromBuffs(const String& skillMod) {
	return (static_cast<CreatureObject*>(stub))->getSkillModFromBuffs(skillMod);
}

int CreatureObjectAdapter::addDotState(unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense) {
	return (static_cast<CreatureObject*>(stub))->addDotState(dotType, objectID, strength, type, duration, potency, defense);
}

bool CreatureObjectAdapter::healDot(unsigned long long dotType, int reduction) {
	return (static_cast<CreatureObject*>(stub))->healDot(dotType, reduction);
}

void CreatureObjectAdapter::clearDots() {
	(static_cast<CreatureObject*>(stub))->clearDots();
}

bool CreatureObjectAdapter::hasBuff(unsigned int buffcrc) {
	return (static_cast<CreatureObject*>(stub))->hasBuff(buffcrc);
}

void CreatureObjectAdapter::notifySelfPositionUpdate() {
	(static_cast<CreatureObject*>(stub))->notifySelfPositionUpdate();
}

void CreatureObjectAdapter::notifyPostureChange(int newPosture) {
	(static_cast<CreatureObject*>(stub))->notifyPostureChange(newPosture);
}

void CreatureObjectAdapter::setLevel(int level) {
	(static_cast<CreatureObject*>(stub))->setLevel(level);
}

void CreatureObjectAdapter::updateToDatabaseAllObjects(bool startTask) {
	(static_cast<CreatureObject*>(stub))->updateToDatabaseAllObjects(startTask);
}

bool CreatureObjectAdapter::isResuscitable() {
	return (static_cast<CreatureObject*>(stub))->isResuscitable();
}

void CreatureObjectAdapter::addBankCredits(int credits, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addBankCredits(credits, notifyClient);
}

void CreatureObjectAdapter::addCashCredits(int credits, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addCashCredits(credits, notifyClient);
}

void CreatureObjectAdapter::subtractBankCredits(int credits) {
	(static_cast<CreatureObject*>(stub))->subtractBankCredits(credits);
}

void CreatureObjectAdapter::subtractCashCredits(int credits) {
	(static_cast<CreatureObject*>(stub))->subtractCashCredits(credits);
}

bool CreatureObjectAdapter::verifyCashCredits(int credits) {
	return (static_cast<CreatureObject*>(stub))->verifyCashCredits(credits);
}

bool CreatureObjectAdapter::verifyBankCredits(int credits) {
	return (static_cast<CreatureObject*>(stub))->verifyBankCredits(credits);
}

bool CreatureObjectAdapter::isDancing() {
	return (static_cast<CreatureObject*>(stub))->isDancing();
}

bool CreatureObjectAdapter::isPlayingMusic() {
	return (static_cast<CreatureObject*>(stub))->isPlayingMusic();
}

void CreatureObjectAdapter::stopEntertaining() {
	(static_cast<CreatureObject*>(stub))->stopEntertaining();
}

bool CreatureObjectAdapter::isEntertaining() {
	return (static_cast<CreatureObject*>(stub))->isEntertaining();
}

void CreatureObjectAdapter::setCashCredits(int credits, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setCashCredits(credits, notifyClient);
}

void CreatureObjectAdapter::setTerrainNegotiation(float value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setTerrainNegotiation(value, notifyClient);
}

void CreatureObjectAdapter::addSkill(const String& skill, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addSkill(skill, notifyClient);
}

void CreatureObjectAdapter::removeSkill(const String& skill, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->removeSkill(skill, notifyClient);
}

void CreatureObjectAdapter::addSkillMod(const int modType, const String& skillMod, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addSkillMod(modType, skillMod, value, notifyClient);
}

void CreatureObjectAdapter::removeSkillMod(const int modType, const String& skillMod, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->removeSkillMod(modType, skillMod, value, notifyClient);
}

void CreatureObjectAdapter::removeAllSkillModsOfType(const int modType, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->removeAllSkillModsOfType(modType, notifyClient);
}

void CreatureObjectAdapter::updateGroupInviterID(unsigned long long id, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->updateGroupInviterID(id, notifyClient);
}

void CreatureObjectAdapter::updateGroup(GroupObject* group, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->updateGroup(group, notifyClient);
}

void CreatureObjectAdapter::enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority) {
	(static_cast<CreatureObject*>(stub))->enqueueCommand(actionCRC, actionCount, targetID, arguments, priority);
}

void CreatureObjectAdapter::setMood(byte moodID, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setMood(moodID, notifyClient);
}

void CreatureObjectAdapter::setMoodString(const String& animation, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setMoodString(animation, notifyClient);
}

void CreatureObjectAdapter::deleteQueueAction(unsigned int actionCount) {
	(static_cast<CreatureObject*>(stub))->deleteQueueAction(actionCount);
}

bool CreatureObjectAdapter::setState(unsigned long long state, bool notifyClient) {
	return (static_cast<CreatureObject*>(stub))->setState(state, notifyClient);
}

bool CreatureObjectAdapter::clearState(unsigned long long state, bool notifyClient) {
	return (static_cast<CreatureObject*>(stub))->clearState(state, notifyClient);
}

void CreatureObjectAdapter::setControlDevice(ControlDevice* device) {
	(static_cast<CreatureObject*>(stub))->setControlDevice(device);
}

void CreatureObjectAdapter::setCreatureLink(CreatureObject* object, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setCreatureLink(object, notifyClient);
}

void CreatureObjectAdapter::executeObjectControllerAction(unsigned int actionCRC) {
	(static_cast<CreatureObject*>(stub))->executeObjectControllerAction(actionCRC);
}

void CreatureObjectAdapter::executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args) {
	(static_cast<CreatureObject*>(stub))->executeObjectControllerAction(actionCRC, targetID, args);
}

bool CreatureObjectAdapter::isAttackableBy(CreatureObject* object) {
	return (static_cast<CreatureObject*>(stub))->isAttackableBy(object);
}

bool CreatureObjectAdapter::isAttackableBy(TangibleObject* attacker) {
	return (static_cast<CreatureObject*>(stub))->isAttackableBy(attacker);
}

bool CreatureObjectAdapter::isHealableBy(CreatureObject* object) {
	return (static_cast<CreatureObject*>(stub))->isHealableBy(object);
}

bool CreatureObjectAdapter::isInBountyMission(CreatureObject* bountyHunter, CreatureObject* target) {
	return (static_cast<CreatureObject*>(stub))->isInBountyMission(bountyHunter, target);
}

void CreatureObjectAdapter::sendConversationStartTo(SceneObject* player) {
	(static_cast<CreatureObject*>(stub))->sendConversationStartTo(player);
}

void CreatureObjectAdapter::selectConversationOption(int option, SceneObject* obj) {
	(static_cast<CreatureObject*>(stub))->selectConversationOption(option, obj);
}

void CreatureObjectAdapter::sendMessage(BasePacket* msg) {
	(static_cast<CreatureObject*>(stub))->sendMessage(msg);
}

void CreatureObjectAdapter::sendExecuteConsoleCommand(const String& command) {
	(static_cast<CreatureObject*>(stub))->sendExecuteConsoleCommand(command);
}

bool CreatureObjectAdapter::isAggressiveTo(CreatureObject* object) {
	return (static_cast<CreatureObject*>(stub))->isAggressiveTo(object);
}

int CreatureObjectAdapter::notifyObjectDestructionObservers(TangibleObject* attacker, int condition) {
	return (static_cast<CreatureObject*>(stub))->notifyObjectDestructionObservers(attacker, condition);
}

int CreatureObjectAdapter::notifyObjectKillObservers(TangibleObject* killer) {
	return (static_cast<CreatureObject*>(stub))->notifyObjectKillObservers(killer);
}

void CreatureObjectAdapter::notifyLoadFromDatabase() {
	(static_cast<CreatureObject*>(stub))->notifyLoadFromDatabase();
}

void CreatureObjectAdapter::setFactionRank(int rank, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setFactionRank(rank, notifyClient);
}

String CreatureObjectAdapter::getFirstName() {
	return (static_cast<CreatureObject*>(stub))->getFirstName();
}

String CreatureObjectAdapter::getLastName() {
	return (static_cast<CreatureObject*>(stub))->getLastName();
}

bool CreatureObjectAdapter::isOnline() {
	return (static_cast<CreatureObject*>(stub))->isOnline();
}

bool CreatureObjectAdapter::canTreatInjuries() {
	return (static_cast<CreatureObject*>(stub))->canTreatInjuries();
}

bool CreatureObjectAdapter::canTreatStates() {
	return (static_cast<CreatureObject*>(stub))->canTreatStates();
}

bool CreatureObjectAdapter::canTreatWounds() {
	return (static_cast<CreatureObject*>(stub))->canTreatWounds();
}

bool CreatureObjectAdapter::canTreatConditions() {
	return (static_cast<CreatureObject*>(stub))->canTreatConditions();
}

PlayerObject* CreatureObjectAdapter::getPlayerObject() {
	return (static_cast<CreatureObject*>(stub))->getPlayerObject();
}

AiActor* CreatureObjectAdapter::getActorObject() {
	return (static_cast<CreatureObject*>(stub))->getActorObject();
}

bool CreatureObjectAdapter::isListening() {
	return (static_cast<CreatureObject*>(stub))->isListening();
}

bool CreatureObjectAdapter::isWatching() {
	return (static_cast<CreatureObject*>(stub))->isWatching();
}

void CreatureObjectAdapter::setClient(ZoneClientSession* cli) {
	(static_cast<CreatureObject*>(stub))->setClient(cli);
}

void CreatureObjectAdapter::dismount() {
	(static_cast<CreatureObject*>(stub))->dismount();
}

float CreatureObjectAdapter::calculateBFRatio() {
	return (static_cast<CreatureObject*>(stub))->calculateBFRatio();
}

void CreatureObjectAdapter::setDizziedState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setDizziedState(durationSeconds);
}

void CreatureObjectAdapter::setRalliedState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setRalliedState(durationSeconds);
}

void CreatureObjectAdapter::setAimingState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setAimingState(durationSeconds);
}

void CreatureObjectAdapter::setCoverState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setCoverState(durationSeconds);
}

void CreatureObjectAdapter::setBerserkedState(unsigned int duration) {
	(static_cast<CreatureObject*>(stub))->setBerserkedState(duration);
}

void CreatureObjectAdapter::setStunnedState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setStunnedState(durationSeconds);
}

void CreatureObjectAdapter::setBlindedState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setBlindedState(durationSeconds);
}

void CreatureObjectAdapter::setIntimidatedState(unsigned int mod, int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setIntimidatedState(mod, durationSeconds);
}

void CreatureObjectAdapter::setSnaredState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setSnaredState(durationSeconds);
}

void CreatureObjectAdapter::setRootedState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setRootedState(durationSeconds);
}

bool CreatureObjectAdapter::setNextAttackDelay(unsigned int mod, int del) {
	return (static_cast<CreatureObject*>(stub))->setNextAttackDelay(mod, del);
}

void CreatureObjectAdapter::setMeditateState() {
	(static_cast<CreatureObject*>(stub))->setMeditateState();
}

void CreatureObjectAdapter::activateHAMRegeneration() {
	(static_cast<CreatureObject*>(stub))->activateHAMRegeneration();
}

void CreatureObjectAdapter::activatePassiveWoundRegeneration() {
	(static_cast<CreatureObject*>(stub))->activatePassiveWoundRegeneration();
}

void CreatureObjectAdapter::activateStateRecovery() {
	(static_cast<CreatureObject*>(stub))->activateStateRecovery();
}

void CreatureObjectAdapter::updateTimeOfDeath() {
	(static_cast<CreatureObject*>(stub))->updateTimeOfDeath();
}

bool CreatureObjectAdapter::hasAttackDelay() {
	return (static_cast<CreatureObject*>(stub))->hasAttackDelay();
}

void CreatureObjectAdapter::removeAttackDelay() {
	(static_cast<CreatureObject*>(stub))->removeAttackDelay();
}

bool CreatureObjectAdapter::hasSpice() {
	return (static_cast<CreatureObject*>(stub))->hasSpice();
}

void CreatureObjectAdapter::updateLastSuccessfulCombatAction() {
	(static_cast<CreatureObject*>(stub))->updateLastSuccessfulCombatAction();
}

void CreatureObjectAdapter::updateKnockdownRecovery() {
	(static_cast<CreatureObject*>(stub))->updateKnockdownRecovery();
}

void CreatureObjectAdapter::queueDizzyFallEvent() {
	(static_cast<CreatureObject*>(stub))->queueDizzyFallEvent();
}

void CreatureObjectAdapter::updateLastKnockdown() {
	(static_cast<CreatureObject*>(stub))->updateLastKnockdown();
}

bool CreatureObjectAdapter::checkKnockdownRecovery() {
	return (static_cast<CreatureObject*>(stub))->checkKnockdownRecovery();
}

bool CreatureObjectAdapter::checkLastKnockdown() {
	return (static_cast<CreatureObject*>(stub))->checkLastKnockdown();
}

void CreatureObjectAdapter::updatePostureDownRecovery() {
	(static_cast<CreatureObject*>(stub))->updatePostureDownRecovery();
}

void CreatureObjectAdapter::updatePostureUpRecovery() {
	(static_cast<CreatureObject*>(stub))->updatePostureUpRecovery();
}

bool CreatureObjectAdapter::checkPostureDownRecovery() {
	return (static_cast<CreatureObject*>(stub))->checkPostureDownRecovery();
}

unsigned long long CreatureObjectAdapter::getScreenPlayState(const String& screenPlay) {
	return (static_cast<CreatureObject*>(stub))->getScreenPlayState(screenPlay);
}

void CreatureObjectAdapter::setScreenPlayState(const String& screenPlay, unsigned long long state) {
	(static_cast<CreatureObject*>(stub))->setScreenPlayState(screenPlay, state);
}

bool CreatureObjectAdapter::checkPostureUpRecovery() {
	return (static_cast<CreatureObject*>(stub))->checkPostureUpRecovery();
}

void CreatureObjectAdapter::updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd) {
	(static_cast<CreatureObject*>(stub))->updateCooldownTimer(coooldownTimer, miliSecondsToAdd);
}

bool CreatureObjectAdapter::checkCooldownRecovery(const String& cooldown) {
	return (static_cast<CreatureObject*>(stub))->checkCooldownRecovery(cooldown);
}

void CreatureObjectAdapter::addCooldown(const String& name, unsigned int miliseconds) {
	(static_cast<CreatureObject*>(stub))->addCooldown(name, miliseconds);
}

void CreatureObjectAdapter::doAnimation(const String& animation) {
	(static_cast<CreatureObject*>(stub))->doAnimation(animation);
}

void CreatureObjectAdapter::doCombatAnimation(CreatureObject* defender, unsigned int animationCRC, byte hit, byte trails) {
	(static_cast<CreatureObject*>(stub))->doCombatAnimation(defender, animationCRC, hit, trails);
}

void CreatureObjectAdapter::playEffect(const String& file, const String& aux) {
	(static_cast<CreatureObject*>(stub))->playEffect(file, aux);
}

void CreatureObjectAdapter::playEffect(const String& file) {
	(static_cast<CreatureObject*>(stub))->playEffect(file);
}

void CreatureObjectAdapter::activateQueueAction() {
	(static_cast<CreatureObject*>(stub))->activateQueueAction();
}

void CreatureObjectAdapter::activateImmediateAction() {
	(static_cast<CreatureObject*>(stub))->activateImmediateAction();
}

UnicodeString CreatureObjectAdapter::getCreatureName() {
	return (static_cast<CreatureObject*>(stub))->getCreatureName();
}

bool CreatureObjectAdapter::isGrouped() {
	return (static_cast<CreatureObject*>(stub))->isGrouped();
}

int CreatureObjectAdapter::getBankCredits() {
	return (static_cast<CreatureObject*>(stub))->getBankCredits();
}

int CreatureObjectAdapter::getCashCredits() {
	return (static_cast<CreatureObject*>(stub))->getCashCredits();
}

int CreatureObjectAdapter::getBaseHAM(int idx) {
	return (static_cast<CreatureObject*>(stub))->getBaseHAM(idx);
}

int CreatureObjectAdapter::getWounds(int idx) {
	return (static_cast<CreatureObject*>(stub))->getWounds(idx);
}

int CreatureObjectAdapter::getHAM(int idx) {
	return (static_cast<CreatureObject*>(stub))->getHAM(idx);
}

int CreatureObjectAdapter::getMaxHAM(int idx) {
	return (static_cast<CreatureObject*>(stub))->getMaxHAM(idx);
}

int CreatureObjectAdapter::getEncumbrance(int idx) {
	return (static_cast<CreatureObject*>(stub))->getEncumbrance(idx);
}

byte CreatureObjectAdapter::getPosture() {
	return (static_cast<CreatureObject*>(stub))->getPosture();
}

byte CreatureObjectAdapter::getLocomotion() {
	return (static_cast<CreatureObject*>(stub))->getLocomotion();
}

byte CreatureObjectAdapter::getFactionRank() {
	return (static_cast<CreatureObject*>(stub))->getFactionRank();
}

ManagedWeakReference<CreatureObject* > CreatureObjectAdapter::getLinkedCreature() {
	return (static_cast<CreatureObject*>(stub))->getLinkedCreature();
}

unsigned long long CreatureObjectAdapter::getCreatureLinkID() {
	return (static_cast<CreatureObject*>(stub))->getCreatureLinkID();
}

float CreatureObjectAdapter::getShockWounds() {
	return (static_cast<CreatureObject*>(stub))->getShockWounds();
}

unsigned long long CreatureObjectAdapter::getWatchToID() {
	return (static_cast<CreatureObject*>(stub))->getWatchToID();
}

unsigned long long CreatureObjectAdapter::getStateBitmask() {
	return (static_cast<CreatureObject*>(stub))->getStateBitmask();
}

bool CreatureObjectAdapter::hasState(unsigned long long state) {
	return (static_cast<CreatureObject*>(stub))->hasState(state);
}

bool CreatureObjectAdapter::hasStates() {
	return (static_cast<CreatureObject*>(stub))->hasStates();
}

unsigned long long CreatureObjectAdapter::getListenID() {
	return (static_cast<CreatureObject*>(stub))->getListenID();
}

float CreatureObjectAdapter::getAccelerationMultiplierBase() {
	return (static_cast<CreatureObject*>(stub))->getAccelerationMultiplierBase();
}

float CreatureObjectAdapter::getAccelerationMultiplierMod() {
	return (static_cast<CreatureObject*>(stub))->getAccelerationMultiplierMod();
}

float CreatureObjectAdapter::getSpeedMultiplierBase() {
	return (static_cast<CreatureObject*>(stub))->getSpeedMultiplierBase();
}

float CreatureObjectAdapter::getSpeedMultiplierMod() {
	return (static_cast<CreatureObject*>(stub))->getSpeedMultiplierMod();
}

float CreatureObjectAdapter::getCurrentSpeed() {
	return (static_cast<CreatureObject*>(stub))->getCurrentSpeed();
}

float CreatureObjectAdapter::getRunSpeed() {
	return (static_cast<CreatureObject*>(stub))->getRunSpeed();
}

float CreatureObjectAdapter::getWalkSpeed() {
	return (static_cast<CreatureObject*>(stub))->getWalkSpeed();
}

float CreatureObjectAdapter::getTurnScale() {
	return (static_cast<CreatureObject*>(stub))->getTurnScale();
}

float CreatureObjectAdapter::getTerrainNegotiation() {
	return (static_cast<CreatureObject*>(stub))->getTerrainNegotiation();
}

float CreatureObjectAdapter::getRunAcceleration() {
	return (static_cast<CreatureObject*>(stub))->getRunAcceleration();
}

float CreatureObjectAdapter::getWalkAcceleration() {
	return (static_cast<CreatureObject*>(stub))->getWalkAcceleration();
}

String CreatureObjectAdapter::getPerformanceAnimation() {
	return (static_cast<CreatureObject*>(stub))->getPerformanceAnimation();
}

String CreatureObjectAdapter::getMoodString() {
	return (static_cast<CreatureObject*>(stub))->getMoodString();
}

unsigned long long CreatureObjectAdapter::getWeaponID() {
	return (static_cast<CreatureObject*>(stub))->getWeaponID();
}

WeaponObject* CreatureObjectAdapter::getWeapon() {
	return (static_cast<CreatureObject*>(stub))->getWeapon();
}

GuildObject* CreatureObjectAdapter::getGuildObject() {
	return (static_cast<CreatureObject*>(stub))->getGuildObject();
}

int CreatureObjectAdapter::getGuildID() {
	return (static_cast<CreatureObject*>(stub))->getGuildID();
}

bool CreatureObjectAdapter::isInGuild() {
	return (static_cast<CreatureObject*>(stub))->isInGuild();
}

void CreatureObjectAdapter::setGuildObject(GuildObject* guildobj) {
	(static_cast<CreatureObject*>(stub))->setGuildObject(guildobj);
}

unsigned long long CreatureObjectAdapter::getGroupID() {
	return (static_cast<CreatureObject*>(stub))->getGroupID();
}

unsigned long long CreatureObjectAdapter::getGroupInviterID() {
	return (static_cast<CreatureObject*>(stub))->getGroupInviterID();
}

GroupObject* CreatureObjectAdapter::getGroup() {
	return (static_cast<CreatureObject*>(stub))->getGroup();
}

unsigned long long CreatureObjectAdapter::getGroupInviteCounter() {
	return (static_cast<CreatureObject*>(stub))->getGroupInviteCounter();
}

unsigned long long CreatureObjectAdapter::getTargetID() {
	return (static_cast<CreatureObject*>(stub))->getTargetID();
}

byte CreatureObjectAdapter::getMoodID() {
	return (static_cast<CreatureObject*>(stub))->getMoodID();
}

float CreatureObjectAdapter::getSlopeModPercent() {
	return (static_cast<CreatureObject*>(stub))->getSlopeModPercent();
}

int CreatureObjectAdapter::getPerformanceCounter() {
	return (static_cast<CreatureObject*>(stub))->getPerformanceCounter();
}

int CreatureObjectAdapter::getInstrumentID() {
	return (static_cast<CreatureObject*>(stub))->getInstrumentID();
}

byte CreatureObjectAdapter::getFrozen() {
	return (static_cast<CreatureObject*>(stub))->getFrozen();
}

float CreatureObjectAdapter::getHeight() {
	return (static_cast<CreatureObject*>(stub))->getHeight();
}

int CreatureObjectAdapter::getSpecies() {
	return (static_cast<CreatureObject*>(stub))->getSpecies();
}

String CreatureObjectAdapter::getSpeciesName() {
	return (static_cast<CreatureObject*>(stub))->getSpeciesName();
}

int CreatureObjectAdapter::getGender() {
	return (static_cast<CreatureObject*>(stub))->getGender();
}

int CreatureObjectAdapter::getSkillMod(const String& skillmod) {
	return (static_cast<CreatureObject*>(stub))->getSkillMod(skillmod);
}

bool CreatureObjectAdapter::hasSkill(const String& skill) {
	return (static_cast<CreatureObject*>(stub))->hasSkill(skill);
}

void CreatureObjectAdapter::setWatchToID(unsigned long long id) {
	(static_cast<CreatureObject*>(stub))->setWatchToID(id);
}

bool CreatureObjectAdapter::isCreatureObject() {
	return (static_cast<CreatureObject*>(stub))->isCreatureObject();
}

bool CreatureObjectAdapter::isNextActionPast() {
	return (static_cast<CreatureObject*>(stub))->isNextActionPast();
}

bool CreatureObjectAdapter::isTrainerCreature() {
	return (static_cast<CreatureObject*>(stub))->isTrainerCreature();
}

bool CreatureObjectAdapter::isSwimming() {
	return (static_cast<CreatureObject*>(stub))->isSwimming();
}

ZoneClientSession* CreatureObjectAdapter::getClient() {
	return (static_cast<CreatureObject*>(stub))->getClient();
}

bool CreatureObjectAdapter::isRidingMount() {
	return (static_cast<CreatureObject*>(stub))->isRidingMount();
}

ManagedWeakReference<ControlDevice* > CreatureObjectAdapter::getControlDevice() {
	return (static_cast<CreatureObject*>(stub))->getControlDevice();
}

float CreatureObjectAdapter::getSwimHeight() {
	return (static_cast<CreatureObject*>(stub))->getSwimHeight();
}

bool CreatureObjectAdapter::isIncapacitated() {
	return (static_cast<CreatureObject*>(stub))->isIncapacitated();
}

bool CreatureObjectAdapter::isDead() {
	return (static_cast<CreatureObject*>(stub))->isDead();
}

bool CreatureObjectAdapter::isKnockedDown() {
	return (static_cast<CreatureObject*>(stub))->isKnockedDown();
}

bool CreatureObjectAdapter::isKneeling() {
	return (static_cast<CreatureObject*>(stub))->isKneeling();
}

bool CreatureObjectAdapter::isProne() {
	return (static_cast<CreatureObject*>(stub))->isProne();
}

bool CreatureObjectAdapter::isStanding() {
	return (static_cast<CreatureObject*>(stub))->isStanding();
}

bool CreatureObjectAdapter::isSitting() {
	return (static_cast<CreatureObject*>(stub))->isSitting();
}

bool CreatureObjectAdapter::isSkillAnimating() {
	return (static_cast<CreatureObject*>(stub))->isSkillAnimating();
}

bool CreatureObjectAdapter::isRallied() {
	return (static_cast<CreatureObject*>(stub))->isRallied();
}

bool CreatureObjectAdapter::isInCombat() {
	return (static_cast<CreatureObject*>(stub))->isInCombat();
}

bool CreatureObjectAdapter::isDizzied() {
	return (static_cast<CreatureObject*>(stub))->isDizzied();
}

bool CreatureObjectAdapter::isBerserked() {
	return (static_cast<CreatureObject*>(stub))->isBerserked();
}

bool CreatureObjectAdapter::isStunned() {
	return (static_cast<CreatureObject*>(stub))->isStunned();
}

bool CreatureObjectAdapter::isBlinded() {
	return (static_cast<CreatureObject*>(stub))->isBlinded();
}

bool CreatureObjectAdapter::isIntimidated() {
	return (static_cast<CreatureObject*>(stub))->isIntimidated();
}

bool CreatureObjectAdapter::isSnared() {
	return (static_cast<CreatureObject*>(stub))->isSnared();
}

bool CreatureObjectAdapter::isImmobilized() {
	return (static_cast<CreatureObject*>(stub))->isImmobilized();
}

bool CreatureObjectAdapter::isRooted() {
	return (static_cast<CreatureObject*>(stub))->isRooted();
}

bool CreatureObjectAdapter::isFrozen() {
	return (static_cast<CreatureObject*>(stub))->isFrozen();
}

bool CreatureObjectAdapter::isDiseased() {
	return (static_cast<CreatureObject*>(stub))->isDiseased();
}

bool CreatureObjectAdapter::isPoisoned() {
	return (static_cast<CreatureObject*>(stub))->isPoisoned();
}

bool CreatureObjectAdapter::isBleeding() {
	return (static_cast<CreatureObject*>(stub))->isBleeding();
}

bool CreatureObjectAdapter::isOnFire() {
	return (static_cast<CreatureObject*>(stub))->isOnFire();
}

bool CreatureObjectAdapter::isMounted() {
	return (static_cast<CreatureObject*>(stub))->isMounted();
}

bool CreatureObjectAdapter::isRidingCreature() {
	return (static_cast<CreatureObject*>(stub))->isRidingCreature();
}

bool CreatureObjectAdapter::isPeaced() {
	return (static_cast<CreatureObject*>(stub))->isPeaced();
}

bool CreatureObjectAdapter::isMeditating() {
	return (static_cast<CreatureObject*>(stub))->isMeditating();
}

bool CreatureObjectAdapter::isAiming() {
	return (static_cast<CreatureObject*>(stub))->isAiming();
}

bool CreatureObjectAdapter::isInCover() {
	return (static_cast<CreatureObject*>(stub))->isInCover();
}

bool CreatureObjectAdapter::isRunning() {
	return (static_cast<CreatureObject*>(stub))->isRunning();
}

bool CreatureObjectAdapter::isNonPlayerCreatureObject() {
	return (static_cast<CreatureObject*>(stub))->isNonPlayerCreatureObject();
}

bool CreatureObjectAdapter::isCreature() {
	return (static_cast<CreatureObject*>(stub))->isCreature();
}

bool CreatureObjectAdapter::isPlayerCreature() {
	return (static_cast<CreatureObject*>(stub))->isPlayerCreature();
}

bool CreatureObjectAdapter::isAiActor() {
	return (static_cast<CreatureObject*>(stub))->isAiActor();
}

bool CreatureObjectAdapter::isInformantCreature() {
	return (static_cast<CreatureObject*>(stub))->isInformantCreature();
}

CampSiteActiveArea* CreatureObjectAdapter::getCurrentCamp() {
	return (static_cast<CreatureObject*>(stub))->getCurrentCamp();
}

byte CreatureObjectAdapter::getCurrentWeather() {
	return (static_cast<CreatureObject*>(stub))->getCurrentWeather();
}

void CreatureObjectAdapter::setCurrentWeather(byte value) {
	(static_cast<CreatureObject*>(stub))->setCurrentWeather(value);
}

byte CreatureObjectAdapter::getCurrentWind() {
	return (static_cast<CreatureObject*>(stub))->getCurrentWind();
}

void CreatureObjectAdapter::setCurrentWind(byte value) {
	(static_cast<CreatureObject*>(stub))->setCurrentWind(value);
}

int CreatureObjectAdapter::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	return (static_cast<CreatureObject*>(stub))->handleObjectMenuSelect(player, selectedID);
}

void CreatureObjectAdapter::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	(static_cast<CreatureObject*>(stub))->fillAttributeList(msg, object);
}

void CreatureObjectAdapter::destroyObjectFromWorld(bool sendSelfDestroy) {
	(static_cast<CreatureObject*>(stub))->destroyObjectFromWorld(sendSelfDestroy);
}

bool CreatureObjectAdapter::isInvisible() {
	return (static_cast<CreatureObject*>(stub))->isInvisible();
}

void CreatureObjectAdapter::setInvisible(bool invis) {
	(static_cast<CreatureObject*>(stub))->setInvisible(invis);
}

float CreatureObjectAdapter::calculateCostAdjustment(byte stat, float baseCost) {
	return (static_cast<CreatureObject*>(stub))->calculateCostAdjustment(stat, baseCost);
}

/*
 *	CreatureObjectHelper
 */

CreatureObjectHelper* CreatureObjectHelper::staticInitializer = CreatureObjectHelper::instance();

CreatureObjectHelper::CreatureObjectHelper() {
	className = "CreatureObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void CreatureObjectHelper::finalizeHelper() {
	CreatureObjectHelper::finalize();
}

DistributedObject* CreatureObjectHelper::instantiateObject() {
	return new CreatureObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* CreatureObjectHelper::instantiateServant() {
	return new CreatureObjectImplementation();
}

DistributedObjectAdapter* CreatureObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new CreatureObjectAdapter(static_cast<CreatureObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

