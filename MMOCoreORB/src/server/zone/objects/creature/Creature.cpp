/*
 *	server/zone/objects/creature/Creature.cpp generated by engine3 IDL compiler 0.60
 */

#include "Creature.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/group/GroupObject.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

#include "server/zone/templates/mobile/CreatureTemplate.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/Zone.h"

/*
 *	CreatureStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 6,RPC_ISCREATURE__,RPC_GETDNASTATE__,RPC_GETDNASAMPLECOUNT__,RPC_INCDNASAMPLECOUNT__,RPC_ISCAMOUFLAGED__CREATUREOBJECT_,RPC_RUNAWAY__CREATUREOBJECT_,RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_,RPC_FILLATTRIBUTELIST__ATTRIBUTELISTMESSAGE_CREATUREOBJECT_,RPC_SCHEDULEDESPAWN__,RPC_HASORGANICS__,RPC_HASMILK__,RPC_HASDNA__,RPC_CANHARVESTME__CREATUREOBJECT_,RPC_HASSKILLTOHARVESTME__CREATUREOBJECT_,RPC_CANMILKME__CREATUREOBJECT_,RPC_CANCOLLECTDNA__CREATUREOBJECT_,RPC_HASSKILLTOSAMPLEME__CREATUREOBJECT_,RPC_ADDALREADYHARVESTED__CREATUREOBJECT_,RPC_SETMILKSTATE__SHORT_,RPC_SETDNASTATE__SHORT_,RPC_NOTIFYDESPAWN__ZONE_,RPC_ISBABY__,RPC_GETTAME__,RPC_GETMEATTYPE__,RPC_GETBONETYPE__,RPC_GETHIDETYPE__,RPC_GETMILKTYPE__,RPC_GETMILK__,RPC_GETHIDEMAX__,RPC_GETBONEMAX__,RPC_GETMEATMAX__};

Creature::Creature() : AiAgent(DummyConstructorParameter::instance()) {
	CreatureImplementation* _implementation = new CreatureImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("Creature");
}

Creature::Creature(DummyConstructorParameter* param) : AiAgent(param) {
	_setClassName("Creature");
}

Creature::~Creature() {
}



void Creature::initializeTransientMembers() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeTransientMembers();
}

bool Creature::isCreature() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCreature();
}

short Creature::getDnaState() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDNASTATE__);

		return method.executeWithSignedShortReturn();
	} else
		return _implementation->getDnaState();
}

short Creature::getDnaSampleCount() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDNASAMPLECOUNT__);

		return method.executeWithSignedShortReturn();
	} else
		return _implementation->getDnaSampleCount();
}

void Creature::incDnaSampleCount() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCDNASAMPLECOUNT__);

		method.executeWithVoidReturn();
	} else
		_implementation->incDnaSampleCount();
}

bool Creature::isCamouflaged(CreatureObject* target) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCAMOUFLAGED__CREATUREOBJECT_);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCamouflaged(target);
}

void Creature::runAway(CreatureObject* target) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RUNAWAY__CREATUREOBJECT_);
		method.addObjectParameter(target);

		method.executeWithVoidReturn();
	} else
		_implementation->runAway(target);
}

void Creature::fillObjectMenuResponse(ObjectMenuResponse* menuResponse, CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->fillObjectMenuResponse(menuResponse, player);
}

int Creature::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->handleObjectMenuSelect(player, selectedID);
}

void Creature::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_FILLATTRIBUTELIST__ATTRIBUTELISTMESSAGE_CREATUREOBJECT_);
		method.addObjectParameter(msg);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else
		_implementation->fillAttributeList(msg, object);
}

void Creature::scheduleDespawn() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEDESPAWN__);

		method.executeWithVoidReturn();
	} else
		_implementation->scheduleDespawn();
}

bool Creature::hasOrganics() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASORGANICS__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasOrganics();
}

bool Creature::hasMilk() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASMILK__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasMilk();
}

bool Creature::hasDNA() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASDNA__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasDNA();
}

bool Creature::canHarvestMe(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANHARVESTME__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canHarvestMe(player);
}

bool Creature::hasSkillToHarvestMe(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSKILLTOHARVESTME__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSkillToHarvestMe(player);
}

bool Creature::canMilkMe(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANMILKME__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canMilkMe(player);
}

bool Creature::canCollectDna(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANCOLLECTDNA__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canCollectDna(player);
}

bool Creature::hasSkillToSampleMe(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSKILLTOSAMPLEME__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSkillToSampleMe(player);
}

void Creature::addAlreadyHarvested(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDALREADYHARVESTED__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->addAlreadyHarvested(player);
}

void Creature::setMilkState(short milkState) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMILKSTATE__SHORT_);
		method.addSignedShortParameter(milkState);

		method.executeWithVoidReturn();
	} else
		_implementation->setMilkState(milkState);
}

void Creature::setDnaState(short dnaState) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDNASTATE__SHORT_);
		method.addSignedShortParameter(dnaState);

		method.executeWithVoidReturn();
	} else
		_implementation->setDnaState(dnaState);
}

void Creature::notifyDespawn(Zone* zone) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYDESPAWN__ZONE_);
		method.addObjectParameter(zone);

		method.executeWithVoidReturn();
	} else
		_implementation->notifyDespawn(zone);
}

bool Creature::isBaby() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBABY__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isBaby();
}

float Creature::getTame() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTAME__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getTame();
}

String Creature::getMeatType() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMEATTYPE__);

		String _return_getMeatType;
		method.executeWithAsciiReturn(_return_getMeatType);
		return _return_getMeatType;
	} else
		return _implementation->getMeatType();
}

String Creature::getBoneType() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBONETYPE__);

		String _return_getBoneType;
		method.executeWithAsciiReturn(_return_getBoneType);
		return _return_getBoneType;
	} else
		return _implementation->getBoneType();
}

String Creature::getHideType() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHIDETYPE__);

		String _return_getHideType;
		method.executeWithAsciiReturn(_return_getHideType);
		return _return_getHideType;
	} else
		return _implementation->getHideType();
}

String Creature::getMilkType() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMILKTYPE__);

		String _return_getMilkType;
		method.executeWithAsciiReturn(_return_getMilkType);
		return _return_getMilkType;
	} else
		return _implementation->getMilkType();
}

float Creature::getMilk() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMILK__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getMilk();
}

float Creature::getHideMax() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHIDEMAX__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getHideMax();
}

float Creature::getBoneMax() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBONEMAX__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getBoneMax();
}

float Creature::getMeatMax() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMEATMAX__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getMeatMax();
}

DistributedObjectServant* Creature::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* Creature::_getImplementationForRead() {
	return _impl;
}

void Creature::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	CreatureImplementation
 */

CreatureImplementation::CreatureImplementation(DummyConstructorParameter* param) : AiAgentImplementation(param) {
	_initializeImplementation();
}


CreatureImplementation::~CreatureImplementation() {
}


void CreatureImplementation::finalize() {
}

void CreatureImplementation::_initializeImplementation() {
	_setClassHelper(CreatureHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void CreatureImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<Creature*>(stub);
	AiAgentImplementation::_setStub(stub);
}

DistributedObjectStub* CreatureImplementation::_getStub() {
	return _this.get();
}

CreatureImplementation::operator const Creature*() {
	return _this.get();
}

void CreatureImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void CreatureImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void CreatureImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void CreatureImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void CreatureImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void CreatureImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void CreatureImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void CreatureImplementation::_serializationHelperMethod() {
	AiAgentImplementation::_serializationHelperMethod();

	_setClassName("Creature");

}

void CreatureImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(CreatureImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool CreatureImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (AiAgentImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xd784ea84: //Creature.milkState
		TypeInfo<short >::parseFromBinaryStream(&milkState, stream);
		return true;

	case 0x74d712e: //Creature.dnaState
		TypeInfo<short >::parseFromBinaryStream(&dnaState, stream);
		return true;

	case 0x55bbec19: //Creature.dnaSampleCount
		TypeInfo<short >::parseFromBinaryStream(&dnaSampleCount, stream);
		return true;

	}

	return false;
}

void CreatureImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = CreatureImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int CreatureImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = AiAgentImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xd784ea84; //Creature.milkState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<short >::toBinaryStream(&milkState, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x74d712e; //Creature.dnaState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<short >::toBinaryStream(&dnaState, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x55bbec19; //Creature.dnaSampleCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<short >::toBinaryStream(&dnaSampleCount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 3;
}

CreatureImplementation::CreatureImplementation() {
	_initializeImplementation();
	// server/zone/objects/creature/Creature.idl():  		Logger.setLoggingName("Creature");
	Logger::setLoggingName("Creature");
	// server/zone/objects/creature/Creature.idl():  		Logger.setLogging(false);
	Logger::setLogging(false);
	// server/zone/objects/creature/Creature.idl():  		Logger.setGlobalLogging(true);
	Logger::setGlobalLogging(true);
}

bool CreatureImplementation::isCreature() {
	// server/zone/objects/creature/Creature.idl():  		return true;
	return true;
}

short CreatureImplementation::getDnaState() {
	// server/zone/objects/creature/Creature.idl():  		return dnaState;
	return dnaState;
}

short CreatureImplementation::getDnaSampleCount() {
	// server/zone/objects/creature/Creature.idl():  		return dnaSampleCount;
	return dnaSampleCount;
}

void CreatureImplementation::incDnaSampleCount() {
	// server/zone/objects/creature/Creature.idl():  		dnaSampleCount++;
	dnaSampleCount ++;
}

bool CreatureImplementation::isCamouflaged(CreatureObject* target) {
	// server/zone/objects/creature/Creature.idl():  		return isScentMasked(target) || isConcealed(target);
	return isScentMasked(target) || isConcealed(target);
}

bool CreatureImplementation::isBaby() {
	// server/zone/objects/creature/Creature.idl():  		return super.baby;
	return AiAgentImplementation::baby;
}

float CreatureImplementation::getTame() {
	// server/zone/objects/creature/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/Creature.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/Creature.idl():  		return super.npcTemplate.getTame();
	return AiAgentImplementation::npcTemplate->getTame();
}

String CreatureImplementation::getMeatType() {
	// server/zone/objects/creature/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/Creature.idl():  			return "";
	return "";
	// server/zone/objects/creature/Creature.idl():  		return super.npcTemplate.getMeatType();
	return AiAgentImplementation::npcTemplate->getMeatType();
}

String CreatureImplementation::getBoneType() {
	// server/zone/objects/creature/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/Creature.idl():  			return "";
	return "";
	// server/zone/objects/creature/Creature.idl():  		return super.npcTemplate.getBoneType();
	return AiAgentImplementation::npcTemplate->getBoneType();
}

String CreatureImplementation::getHideType() {
	// server/zone/objects/creature/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/Creature.idl():  			return "";
	return "";
	// server/zone/objects/creature/Creature.idl():  		return super.npcTemplate.getHideType();
	return AiAgentImplementation::npcTemplate->getHideType();
}

String CreatureImplementation::getMilkType() {
	// server/zone/objects/creature/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/Creature.idl():  			return "";
	return "";
	// server/zone/objects/creature/Creature.idl():  		return super.npcTemplate.getMilkType();
	return AiAgentImplementation::npcTemplate->getMilkType();
}

float CreatureImplementation::getMilk() {
	// server/zone/objects/creature/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/Creature.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/Creature.idl():  		return super.npcTemplate.getMilk();
	return AiAgentImplementation::npcTemplate->getMilk();
}

float CreatureImplementation::getHideMax() {
	// server/zone/objects/creature/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/Creature.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/Creature.idl():  		return super.npcTemplate.getHideMax();
	return AiAgentImplementation::npcTemplate->getHideMax();
}

float CreatureImplementation::getBoneMax() {
	// server/zone/objects/creature/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/Creature.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/Creature.idl():  		return super.npcTemplate.getBoneMax();
	return AiAgentImplementation::npcTemplate->getBoneMax();
}

float CreatureImplementation::getMeatMax() {
	// server/zone/objects/creature/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/Creature.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/Creature.idl():  		return super.npcTemplate.getMeatMax();
	return AiAgentImplementation::npcTemplate->getMeatMax();
}

/*
 *	CreatureAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


CreatureAdapter::CreatureAdapter(Creature* obj) : AiAgentAdapter(obj) {
}

void CreatureAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			initializeTransientMembers();
		}
		break;
	case RPC_ISCREATURE__:
		{
			resp->insertBoolean(isCreature());
		}
		break;
	case RPC_GETDNASTATE__:
		{
			resp->insertSignedShort(getDnaState());
		}
		break;
	case RPC_GETDNASAMPLECOUNT__:
		{
			resp->insertSignedShort(getDnaSampleCount());
		}
		break;
	case RPC_INCDNASAMPLECOUNT__:
		{
			incDnaSampleCount();
		}
		break;
	case RPC_ISCAMOUFLAGED__CREATUREOBJECT_:
		{
			resp->insertBoolean(isCamouflaged(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_RUNAWAY__CREATUREOBJECT_:
		{
			runAway(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_:
		{
			resp->insertSignedInt(handleObjectMenuSelect(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getByteParameter()));
		}
		break;
	case RPC_FILLATTRIBUTELIST__ATTRIBUTELISTMESSAGE_CREATUREOBJECT_:
		{
			fillAttributeList(static_cast<AttributeListMessage*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SCHEDULEDESPAWN__:
		{
			scheduleDespawn();
		}
		break;
	case RPC_HASORGANICS__:
		{
			resp->insertBoolean(hasOrganics());
		}
		break;
	case RPC_HASMILK__:
		{
			resp->insertBoolean(hasMilk());
		}
		break;
	case RPC_HASDNA__:
		{
			resp->insertBoolean(hasDNA());
		}
		break;
	case RPC_CANHARVESTME__CREATUREOBJECT_:
		{
			resp->insertBoolean(canHarvestMe(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_HASSKILLTOHARVESTME__CREATUREOBJECT_:
		{
			resp->insertBoolean(hasSkillToHarvestMe(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_CANMILKME__CREATUREOBJECT_:
		{
			resp->insertBoolean(canMilkMe(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_CANCOLLECTDNA__CREATUREOBJECT_:
		{
			resp->insertBoolean(canCollectDna(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_HASSKILLTOSAMPLEME__CREATUREOBJECT_:
		{
			resp->insertBoolean(hasSkillToSampleMe(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ADDALREADYHARVESTED__CREATUREOBJECT_:
		{
			addAlreadyHarvested(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SETMILKSTATE__SHORT_:
		{
			setMilkState(inv->getSignedShortParameter());
		}
		break;
	case RPC_SETDNASTATE__SHORT_:
		{
			setDnaState(inv->getSignedShortParameter());
		}
		break;
	case RPC_NOTIFYDESPAWN__ZONE_:
		{
			notifyDespawn(static_cast<Zone*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ISBABY__:
		{
			resp->insertBoolean(isBaby());
		}
		break;
	case RPC_GETTAME__:
		{
			resp->insertFloat(getTame());
		}
		break;
	case RPC_GETMEATTYPE__:
		{
			resp->insertAscii(getMeatType());
		}
		break;
	case RPC_GETBONETYPE__:
		{
			resp->insertAscii(getBoneType());
		}
		break;
	case RPC_GETHIDETYPE__:
		{
			resp->insertAscii(getHideType());
		}
		break;
	case RPC_GETMILKTYPE__:
		{
			resp->insertAscii(getMilkType());
		}
		break;
	case RPC_GETMILK__:
		{
			resp->insertFloat(getMilk());
		}
		break;
	case RPC_GETHIDEMAX__:
		{
			resp->insertFloat(getHideMax());
		}
		break;
	case RPC_GETBONEMAX__:
		{
			resp->insertFloat(getBoneMax());
		}
		break;
	case RPC_GETMEATMAX__:
		{
			resp->insertFloat(getMeatMax());
		}
		break;
	default:
		throw Exception("Method does not exists");
	}
}

void CreatureAdapter::initializeTransientMembers() {
	(static_cast<Creature*>(stub))->initializeTransientMembers();
}

bool CreatureAdapter::isCreature() {
	return (static_cast<Creature*>(stub))->isCreature();
}

short CreatureAdapter::getDnaState() {
	return (static_cast<Creature*>(stub))->getDnaState();
}

short CreatureAdapter::getDnaSampleCount() {
	return (static_cast<Creature*>(stub))->getDnaSampleCount();
}

void CreatureAdapter::incDnaSampleCount() {
	(static_cast<Creature*>(stub))->incDnaSampleCount();
}

bool CreatureAdapter::isCamouflaged(CreatureObject* target) {
	return (static_cast<Creature*>(stub))->isCamouflaged(target);
}

void CreatureAdapter::runAway(CreatureObject* target) {
	(static_cast<Creature*>(stub))->runAway(target);
}

int CreatureAdapter::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	return (static_cast<Creature*>(stub))->handleObjectMenuSelect(player, selectedID);
}

void CreatureAdapter::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	(static_cast<Creature*>(stub))->fillAttributeList(msg, object);
}

void CreatureAdapter::scheduleDespawn() {
	(static_cast<Creature*>(stub))->scheduleDespawn();
}

bool CreatureAdapter::hasOrganics() {
	return (static_cast<Creature*>(stub))->hasOrganics();
}

bool CreatureAdapter::hasMilk() {
	return (static_cast<Creature*>(stub))->hasMilk();
}

bool CreatureAdapter::hasDNA() {
	return (static_cast<Creature*>(stub))->hasDNA();
}

bool CreatureAdapter::canHarvestMe(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->canHarvestMe(player);
}

bool CreatureAdapter::hasSkillToHarvestMe(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->hasSkillToHarvestMe(player);
}

bool CreatureAdapter::canMilkMe(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->canMilkMe(player);
}

bool CreatureAdapter::canCollectDna(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->canCollectDna(player);
}

bool CreatureAdapter::hasSkillToSampleMe(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->hasSkillToSampleMe(player);
}

void CreatureAdapter::addAlreadyHarvested(CreatureObject* player) {
	(static_cast<Creature*>(stub))->addAlreadyHarvested(player);
}

void CreatureAdapter::setMilkState(short milkState) {
	(static_cast<Creature*>(stub))->setMilkState(milkState);
}

void CreatureAdapter::setDnaState(short dnaState) {
	(static_cast<Creature*>(stub))->setDnaState(dnaState);
}

void CreatureAdapter::notifyDespawn(Zone* zone) {
	(static_cast<Creature*>(stub))->notifyDespawn(zone);
}

bool CreatureAdapter::isBaby() {
	return (static_cast<Creature*>(stub))->isBaby();
}

float CreatureAdapter::getTame() {
	return (static_cast<Creature*>(stub))->getTame();
}

String CreatureAdapter::getMeatType() {
	return (static_cast<Creature*>(stub))->getMeatType();
}

String CreatureAdapter::getBoneType() {
	return (static_cast<Creature*>(stub))->getBoneType();
}

String CreatureAdapter::getHideType() {
	return (static_cast<Creature*>(stub))->getHideType();
}

String CreatureAdapter::getMilkType() {
	return (static_cast<Creature*>(stub))->getMilkType();
}

float CreatureAdapter::getMilk() {
	return (static_cast<Creature*>(stub))->getMilk();
}

float CreatureAdapter::getHideMax() {
	return (static_cast<Creature*>(stub))->getHideMax();
}

float CreatureAdapter::getBoneMax() {
	return (static_cast<Creature*>(stub))->getBoneMax();
}

float CreatureAdapter::getMeatMax() {
	return (static_cast<Creature*>(stub))->getMeatMax();
}

/*
 *	CreatureHelper
 */

CreatureHelper* CreatureHelper::staticInitializer = CreatureHelper::instance();

CreatureHelper::CreatureHelper() {
	className = "Creature";

	Core::getObjectBroker()->registerClass(className, this);
}

void CreatureHelper::finalizeHelper() {
	CreatureHelper::finalize();
}

DistributedObject* CreatureHelper::instantiateObject() {
	return new Creature(DummyConstructorParameter::instance());
}

DistributedObjectServant* CreatureHelper::instantiateServant() {
	return new CreatureImplementation();
}

DistributedObjectAdapter* CreatureHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new CreatureAdapter(static_cast<Creature*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

