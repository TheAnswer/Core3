/*
 *	server/zone/objects/player/sessions/EntertainingSession.cpp generated by engine3 IDL compiler 0.60
 */

#include "EntertainingSession.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "server/zone/objects/tangible/Instrument.h"

#include "server/zone/objects/player/events/EntertainingSessionTask.h"

#include "server/zone/objects/player/EntertainingObserver.h"

#include "server/zone/objects/tangible/Instrument.h"

/*
 *	EntertainingSessionStub
 */

enum {RPC_DOENTERTAINERPATRONEFFECTS__ = 6,RPC_DOPERFORMANCEACTION__,RPC_ADDENTERTAINERFLOURISHBUFF__,RPC_STARTDANCING__STRING_STRING_,RPC_STARTPLAYINGMUSIC__STRING_STRING_INT_,RPC_STARTENTERTAINING__,RPC_FINALIZE__,RPC_HEALWOUNDS__CREATUREOBJECT_FLOAT_FLOAT_,RPC_ISINENTERTAININGBUILDING__CREATUREOBJECT_,RPC_DOFLOURISH__INT_,RPC_CANHEALBATTLEFATIGUE__,RPC_CANGIVEENTERTAINBUFF__,RPC_ADDFLOURISHXP__INT_,RPC_ADDHEALINGXP__INT_,RPC_ADDHEALINGXPGROUP__INT_,RPC_INITIALIZESESSION__,RPC_CANCELSESSION__,RPC_CLEARSESSION__,RPC_STOPPLAYINGMUSIC__,RPC_STOPDANCING__,RPC_ACTIVATEACTION__,RPC_STARTTICKTASK__,RPC_GETENTERTAINERBUFFSTRENGTH__CREATUREOBJECT_INT_,RPC_GETENTERTAINERBUFFDURATION__CREATUREOBJECT_INT_,RPC_GETENTERTAINERBUFFSTARTTIME__CREATUREOBJECT_INT_,RPC_SENDENTERTAININGUPDATE__CREATUREOBJECT_FLOAT_STRING_INT_INT_,RPC_SENDENTERTAINMENTUPDATE__CREATUREOBJECT_LONG_STRING_BOOL_,RPC_ACTIVATEENTERTAINERBUFF__CREATUREOBJECT_INT_,RPC_GETINSTRUMENT__CREATUREOBJECT_,RPC_GETPERFORMANCENAME__,RPC_ADDWATCHER__CREATUREOBJECT_,RPC_ADDLISTENER__CREATUREOBJECT_,RPC_ISDANCING__,RPC_ISPLAYINGMUSIC__,RPC_ISACCEPTINGBANDFLOURISHES__,RPC_SETACCEPTINGBANDFLOURISHES__BOOL_,RPC_REMOVEWATCHER__CREATUREOBJECT_,RPC_REMOVELISTENER__CREATUREOBJECT_,RPC_SETPERFORMANCENAME__STRING_,RPC_SETDANCING__BOOL_,RPC_SETTARGETINSTRUMENT__BOOL_,RPC_UPDATEENTERTAINERMISSIONSTATUS__BOOL_INT_,RPC_ISINDENYSERVICELIST__CREATUREOBJECT_,RPC_ADDTODENYSERVICELIST__CREATUREOBJECT_,RPC_REMOVEFROMDENYSERVICELIST__CREATUREOBJECT_,RPC_INCREASEENTERTAINERBUFF__CREATUREOBJECT_,RPC_AWARDENTERTAINEREXPERIENCE__};

EntertainingSession::EntertainingSession(CreatureObject* ent) : Facade(DummyConstructorParameter::instance()) {
	EntertainingSessionImplementation* _implementation = new EntertainingSessionImplementation(ent);
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("EntertainingSession");
}

EntertainingSession::EntertainingSession(DummyConstructorParameter* param) : Facade(param) {
	_setClassName("EntertainingSession");
}

EntertainingSession::~EntertainingSession() {
}



void EntertainingSession::doEntertainerPatronEffects() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOENTERTAINERPATRONEFFECTS__);

		method.executeWithVoidReturn();
	} else
		_implementation->doEntertainerPatronEffects();
}

void EntertainingSession::doPerformanceAction() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOPERFORMANCEACTION__);

		method.executeWithVoidReturn();
	} else
		_implementation->doPerformanceAction();
}

void EntertainingSession::addEntertainerFlourishBuff() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDENTERTAINERFLOURISHBUFF__);

		method.executeWithVoidReturn();
	} else
		_implementation->addEntertainerFlourishBuff();
}

void EntertainingSession::startDancing(const String& dance, const String& animation) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTDANCING__STRING_STRING_);
		method.addAsciiParameter(dance);
		method.addAsciiParameter(animation);

		method.executeWithVoidReturn();
	} else
		_implementation->startDancing(dance, animation);
}

void EntertainingSession::startPlayingMusic(const String& song, const String& instrumentAnimation, int instrid) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTPLAYINGMUSIC__STRING_STRING_INT_);
		method.addAsciiParameter(song);
		method.addAsciiParameter(instrumentAnimation);
		method.addSignedIntParameter(instrid);

		method.executeWithVoidReturn();
	} else
		_implementation->startPlayingMusic(song, instrumentAnimation, instrid);
}

void EntertainingSession::startEntertaining() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTENTERTAINING__);

		method.executeWithVoidReturn();
	} else
		_implementation->startEntertaining();
}

void EntertainingSession::healWounds(CreatureObject* creature, float woundHeal, float shockHeal) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALWOUNDS__CREATUREOBJECT_FLOAT_FLOAT_);
		method.addObjectParameter(creature);
		method.addFloatParameter(woundHeal);
		method.addFloatParameter(shockHeal);

		method.executeWithVoidReturn();
	} else
		_implementation->healWounds(creature, woundHeal, shockHeal);
}

bool EntertainingSession::isInEntertainingBuilding(CreatureObject* creature) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINENTERTAININGBUILDING__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInEntertainingBuilding(creature);
}

void EntertainingSession::doFlourish(int flourishNumber) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOFLOURISH__INT_);
		method.addSignedIntParameter(flourishNumber);

		method.executeWithVoidReturn();
	} else
		_implementation->doFlourish(flourishNumber);
}

bool EntertainingSession::canHealBattleFatigue() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANHEALBATTLEFATIGUE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canHealBattleFatigue();
}

bool EntertainingSession::canGiveEntertainBuff() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANGIVEENTERTAINBUFF__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canGiveEntertainBuff();
}

void EntertainingSession::addFlourishXp(int xp) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDFLOURISHXP__INT_);
		method.addSignedIntParameter(xp);

		method.executeWithVoidReturn();
	} else
		_implementation->addFlourishXp(xp);
}

void EntertainingSession::addHealingXp(int xp) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDHEALINGXP__INT_);
		method.addSignedIntParameter(xp);

		method.executeWithVoidReturn();
	} else
		_implementation->addHealingXp(xp);
}

void EntertainingSession::addHealingXpGroup(int xp) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDHEALINGXPGROUP__INT_);
		method.addSignedIntParameter(xp);

		method.executeWithVoidReturn();
	} else
		_implementation->addHealingXpGroup(xp);
}

int EntertainingSession::initializeSession() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZESESSION__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->initializeSession();
}

int EntertainingSession::cancelSession() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANCELSESSION__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->cancelSession();
}

int EntertainingSession::clearSession() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARSESSION__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->clearSession();
}

void EntertainingSession::stopPlayingMusic() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPPLAYINGMUSIC__);

		method.executeWithVoidReturn();
	} else
		_implementation->stopPlayingMusic();
}

void EntertainingSession::stopDancing() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPDANCING__);

		method.executeWithVoidReturn();
	} else
		_implementation->stopDancing();
}

void EntertainingSession::activateAction() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEACTION__);

		method.executeWithVoidReturn();
	} else
		_implementation->activateAction();
}

void EntertainingSession::startTickTask() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTTICKTASK__);

		method.executeWithVoidReturn();
	} else
		_implementation->startTickTask();
}

void EntertainingSession::addEntertainerBuffDuration(CreatureObject* creature, int performanceType, float duration) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->addEntertainerBuffDuration(creature, performanceType, duration);
}

void EntertainingSession::addEntertainerBuffStrength(CreatureObject* creature, int performanceType, float strength) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->addEntertainerBuffStrength(creature, performanceType, strength);
}

void EntertainingSession::setEntertainerBuffDuration(CreatureObject* creature, int performanceType, float duration) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->setEntertainerBuffDuration(creature, performanceType, duration);
}

void EntertainingSession::setEntertainerBuffStrength(CreatureObject* creature, int performanceType, float strength) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->setEntertainerBuffStrength(creature, performanceType, strength);
}

int EntertainingSession::getEntertainerBuffStrength(CreatureObject* creature, int performanceType) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENTERTAINERBUFFSTRENGTH__CREATUREOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(performanceType);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getEntertainerBuffStrength(creature, performanceType);
}

int EntertainingSession::getEntertainerBuffDuration(CreatureObject* creature, int performanceType) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENTERTAINERBUFFDURATION__CREATUREOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(performanceType);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getEntertainerBuffDuration(creature, performanceType);
}

int EntertainingSession::getEntertainerBuffStartTime(CreatureObject* creature, int performanceType) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENTERTAINERBUFFSTARTTIME__CREATUREOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(performanceType);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getEntertainerBuffStartTime(creature, performanceType);
}

void EntertainingSession::sendEntertainingUpdate(CreatureObject* creature, float entval, const String& performance, unsigned int perfcntr, int instrid) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDENTERTAININGUPDATE__CREATUREOBJECT_FLOAT_STRING_INT_INT_);
		method.addObjectParameter(creature);
		method.addFloatParameter(entval);
		method.addAsciiParameter(performance);
		method.addUnsignedIntParameter(perfcntr);
		method.addSignedIntParameter(instrid);

		method.executeWithVoidReturn();
	} else
		_implementation->sendEntertainingUpdate(creature, entval, performance, perfcntr, instrid);
}

void EntertainingSession::sendEntertainmentUpdate(CreatureObject* creature, unsigned long long entid, const String& mood, bool updateEntValue) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDENTERTAINMENTUPDATE__CREATUREOBJECT_LONG_STRING_BOOL_);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(entid);
		method.addAsciiParameter(mood);
		method.addBooleanParameter(updateEntValue);

		method.executeWithVoidReturn();
	} else
		_implementation->sendEntertainmentUpdate(creature, entid, mood, updateEntValue);
}

void EntertainingSession::activateEntertainerBuff(CreatureObject* creature, int performanceType) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEENTERTAINERBUFF__CREATUREOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(performanceType);

		method.executeWithVoidReturn();
	} else
		_implementation->activateEntertainerBuff(creature, performanceType);
}

Instrument* EntertainingSession::getInstrument(CreatureObject* creature) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINSTRUMENT__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		return static_cast<Instrument*>(method.executeWithObjectReturn());
	} else
		return _implementation->getInstrument(creature);
}

String EntertainingSession::getPerformanceName() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERFORMANCENAME__);

		String _return_getPerformanceName;
		method.executeWithAsciiReturn(_return_getPerformanceName);
		return _return_getPerformanceName;
	} else
		return _implementation->getPerformanceName();
}

void EntertainingSession::addWatcher(CreatureObject* creature) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDWATCHER__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		_implementation->addWatcher(creature);
}

void EntertainingSession::addListener(CreatureObject* listener) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDLISTENER__CREATUREOBJECT_);
		method.addObjectParameter(listener);

		method.executeWithVoidReturn();
	} else
		_implementation->addListener(listener);
}

bool EntertainingSession::isDancing() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDANCING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDancing();
}

bool EntertainingSession::isPlayingMusic() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLAYINGMUSIC__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPlayingMusic();
}

bool EntertainingSession::isAcceptingBandFlourishes() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISACCEPTINGBANDFLOURISHES__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isAcceptingBandFlourishes();
}

void EntertainingSession::setAcceptingBandFlourishes(bool val) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCEPTINGBANDFLOURISHES__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else
		_implementation->setAcceptingBandFlourishes(val);
}

void EntertainingSession::removeWatcher(CreatureObject* creature) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEWATCHER__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		_implementation->removeWatcher(creature);
}

void EntertainingSession::removeListener(CreatureObject* creature) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVELISTENER__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		_implementation->removeListener(creature);
}

void EntertainingSession::setPerformanceName(const String& name) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPERFORMANCENAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		_implementation->setPerformanceName(name);
}

void EntertainingSession::setDancing(bool val) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDANCING__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else
		_implementation->setDancing(val);
}

void EntertainingSession::setTargetInstrument(bool var) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTARGETINSTRUMENT__BOOL_);
		method.addBooleanParameter(var);

		method.executeWithVoidReturn();
	} else
		_implementation->setTargetInstrument(var);
}

void EntertainingSession::updateEntertainerMissionStatus(bool entertaining, const int missionType) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEENTERTAINERMISSIONSTATUS__BOOL_INT_);
		method.addBooleanParameter(entertaining);
		method.addSignedIntParameter(missionType);

		method.executeWithVoidReturn();
	} else
		_implementation->updateEntertainerMissionStatus(entertaining, missionType);
}

bool EntertainingSession::isInDenyServiceList(CreatureObject* target) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINDENYSERVICELIST__CREATUREOBJECT_);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInDenyServiceList(target);
}

void EntertainingSession::addToDenyServiceList(CreatureObject* target) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTODENYSERVICELIST__CREATUREOBJECT_);
		method.addObjectParameter(target);

		method.executeWithVoidReturn();
	} else
		_implementation->addToDenyServiceList(target);
}

void EntertainingSession::removeFromDenyServiceList(CreatureObject* target) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFROMDENYSERVICELIST__CREATUREOBJECT_);
		method.addObjectParameter(target);

		method.executeWithVoidReturn();
	} else
		_implementation->removeFromDenyServiceList(target);
}

void EntertainingSession::increaseEntertainerBuff(CreatureObject* patron) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREASEENTERTAINERBUFF__CREATUREOBJECT_);
		method.addObjectParameter(patron);

		method.executeWithVoidReturn();
	} else
		_implementation->increaseEntertainerBuff(patron);
}

void EntertainingSession::awardEntertainerExperience() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_AWARDENTERTAINEREXPERIENCE__);

		method.executeWithVoidReturn();
	} else
		_implementation->awardEntertainerExperience();
}

DistributedObjectServant* EntertainingSession::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* EntertainingSession::_getImplementationForRead() {
	return _impl;
}

void EntertainingSession::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	EntertainingSessionImplementation
 */

EntertainingSessionImplementation::EntertainingSessionImplementation(DummyConstructorParameter* param) : FacadeImplementation(param) {
	_initializeImplementation();
}


EntertainingSessionImplementation::~EntertainingSessionImplementation() {
	EntertainingSessionImplementation::finalize();
}


void EntertainingSessionImplementation::_initializeImplementation() {
	_setClassHelper(EntertainingSessionHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void EntertainingSessionImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<EntertainingSession*>(stub);
	FacadeImplementation::_setStub(stub);
}

DistributedObjectStub* EntertainingSessionImplementation::_getStub() {
	return _this.get();
}

EntertainingSessionImplementation::operator const EntertainingSession*() {
	return _this.get();
}

void EntertainingSessionImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void EntertainingSessionImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void EntertainingSessionImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void EntertainingSessionImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void EntertainingSessionImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void EntertainingSessionImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void EntertainingSessionImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void EntertainingSessionImplementation::_serializationHelperMethod() {
	FacadeImplementation::_serializationHelperMethod();

	_setClassName("EntertainingSession");

}

void EntertainingSessionImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(EntertainingSessionImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool EntertainingSessionImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (FacadeImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x98639124: //EntertainingSession.entertainer
		TypeInfo<ManagedWeakReference<CreatureObject* > >::parseFromBinaryStream(&entertainer, stream);
		return true;

	case 0x561d7ab2: //EntertainingSession.observer
		TypeInfo<ManagedReference<EntertainingObserver* > >::parseFromBinaryStream(&observer, stream);
		return true;

	case 0x83de8ed2: //EntertainingSession.watchers
		TypeInfo<EntertainingDataMap >::parseFromBinaryStream(&watchers, stream);
		return true;

	case 0xd2632343: //EntertainingSession.listeners
		TypeInfo<EntertainingDataMap >::parseFromBinaryStream(&listeners, stream);
		return true;

	case 0x9eb87f03: //EntertainingSession.denyServiceList
		TypeInfo<SortedVector<ManagedReference<CreatureObject* > > >::parseFromBinaryStream(&denyServiceList, stream);
		return true;

	case 0x6c72eb58: //EntertainingSession.nextTick
		TypeInfo<Time >::parseFromBinaryStream(&nextTick, stream);
		return true;

	case 0x6ee400c6: //EntertainingSession.performanceName
		TypeInfo<String >::parseFromBinaryStream(&performanceName, stream);
		return true;

	case 0x766a2aac: //EntertainingSession.dancing
		TypeInfo<bool >::parseFromBinaryStream(&dancing, stream);
		return true;

	case 0x6f4a346a: //EntertainingSession.playingMusic
		TypeInfo<bool >::parseFromBinaryStream(&playingMusic, stream);
		return true;

	case 0xa0634a3f: //EntertainingSession.flourishXp
		TypeInfo<int >::parseFromBinaryStream(&flourishXp, stream);
		return true;

	case 0xdbc38993: //EntertainingSession.healingXp
		TypeInfo<int >::parseFromBinaryStream(&healingXp, stream);
		return true;

	case 0x84fb2b6: //EntertainingSession.flourishCount
		TypeInfo<int >::parseFromBinaryStream(&flourishCount, stream);
		return true;

	case 0xe2f4031e: //EntertainingSession.acceptingBandFlourishes
		TypeInfo<bool >::parseFromBinaryStream(&acceptingBandFlourishes, stream);
		return true;

	case 0xe152ab5b: //EntertainingSession.targetInstrument
		TypeInfo<bool >::parseFromBinaryStream(&targetInstrument, stream);
		return true;

	case 0xb6ab890a: //EntertainingSession.externalInstrument
		TypeInfo<ManagedReference<Instrument* > >::parseFromBinaryStream(&externalInstrument, stream);
		return true;

	}

	return false;
}

void EntertainingSessionImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = EntertainingSessionImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int EntertainingSessionImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = FacadeImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x98639124; //EntertainingSession.entertainer
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<CreatureObject* > >::toBinaryStream(&entertainer, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x561d7ab2; //EntertainingSession.observer
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<EntertainingObserver* > >::toBinaryStream(&observer, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x83de8ed2; //EntertainingSession.watchers
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<EntertainingDataMap >::toBinaryStream(&watchers, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd2632343; //EntertainingSession.listeners
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<EntertainingDataMap >::toBinaryStream(&listeners, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x9eb87f03; //EntertainingSession.denyServiceList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<ManagedReference<CreatureObject* > > >::toBinaryStream(&denyServiceList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x6c72eb58; //EntertainingSession.nextTick
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&nextTick, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x6ee400c6; //EntertainingSession.performanceName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&performanceName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x766a2aac; //EntertainingSession.dancing
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&dancing, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x6f4a346a; //EntertainingSession.playingMusic
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&playingMusic, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xa0634a3f; //EntertainingSession.flourishXp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&flourishXp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xdbc38993; //EntertainingSession.healingXp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&healingXp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x84fb2b6; //EntertainingSession.flourishCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&flourishCount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe2f4031e; //EntertainingSession.acceptingBandFlourishes
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&acceptingBandFlourishes, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe152ab5b; //EntertainingSession.targetInstrument
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&targetInstrument, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xb6ab890a; //EntertainingSession.externalInstrument
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<Instrument* > >::toBinaryStream(&externalInstrument, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 15;
}

EntertainingSessionImplementation::EntertainingSessionImplementation(CreatureObject* ent) {
	_initializeImplementation();
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		entertainer = ent;
	entertainer = ent;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		flourishXp = 0;
	flourishXp = 0;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		healingXp = 0;
	healingXp = 0;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		flourishCount = 0;
	flourishCount = 0;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		observer = null;
	observer = NULL;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		dancing = false;
	dancing = false;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		playingMusic = false;
	playingMusic = false;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		acceptingBandFlourishes = true;
	acceptingBandFlourishes = true;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		targetInstrument = false;
	targetInstrument = false;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		watchers.setNoDuplicateInsertPlan();
	(&watchers)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		listeners.setNoDuplicateInsertPlan();
	(&listeners)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		Logger.setLoggingName("EntertainingSession");
	Logger::setLoggingName("EntertainingSession");
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		Logger.setLogging(false);
	Logger::setLogging(false);
}

void EntertainingSessionImplementation::finalize() {
}

void EntertainingSessionImplementation::addFlourishXp(int xp) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		flourishXp = flourishXp + xp;
	flourishXp = flourishXp + xp;
}

void EntertainingSessionImplementation::addHealingXp(int xp) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		healingXp = healingXp + xp;
	healingXp = healingXp + xp;
}

int EntertainingSessionImplementation::initializeSession() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return 0;
	return 0;
}

int EntertainingSessionImplementation::cancelSession() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		stopPlayingMusic();
	stopPlayingMusic();
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		stopDancing();
	stopDancing();
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return 0;
	return 0;
}

int EntertainingSessionImplementation::clearSession() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return 0;
	return 0;
}

String EntertainingSessionImplementation::getPerformanceName() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return performanceName;
	return performanceName;
}

bool EntertainingSessionImplementation::isDancing() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return dancing;
	return dancing;
}

bool EntertainingSessionImplementation::isPlayingMusic() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return playingMusic;
	return playingMusic;
}

bool EntertainingSessionImplementation::isAcceptingBandFlourishes() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return acceptingBandFlourishes;
	return acceptingBandFlourishes;
}

void EntertainingSessionImplementation::setAcceptingBandFlourishes(bool val) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		acceptingBandFlourishes = val;
	acceptingBandFlourishes = val;
}

void EntertainingSessionImplementation::removeWatcher(CreatureObject* creature) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		watchers.drop(creature);
	(&watchers)->drop(creature);
}

void EntertainingSessionImplementation::removeListener(CreatureObject* creature) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		listeners.drop(creature);
	(&listeners)->drop(creature);
}

void EntertainingSessionImplementation::setPerformanceName(const String& name) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		performanceName = name;
	performanceName = name;
}

void EntertainingSessionImplementation::setDancing(bool val) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		dancing = val;
	dancing = val;
}

void EntertainingSessionImplementation::setTargetInstrument(bool var) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		targetInstrument = var;
	targetInstrument = var;
}

bool EntertainingSessionImplementation::isInDenyServiceList(CreatureObject* target) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return denyServiceList.contains(target);
	return (&denyServiceList)->contains(target);
}

void EntertainingSessionImplementation::addToDenyServiceList(CreatureObject* target) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		denyServiceList.put(target);
	(&denyServiceList)->put(target);
}

void EntertainingSessionImplementation::removeFromDenyServiceList(CreatureObject* target) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		denyServiceList.drop(target);
	(&denyServiceList)->drop(target);
}

/*
 *	EntertainingSessionAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


EntertainingSessionAdapter::EntertainingSessionAdapter(EntertainingSession* obj) : FacadeAdapter(obj) {
}

void EntertainingSessionAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_DOENTERTAINERPATRONEFFECTS__:
		{
			doEntertainerPatronEffects();
		}
		break;
	case RPC_DOPERFORMANCEACTION__:
		{
			doPerformanceAction();
		}
		break;
	case RPC_ADDENTERTAINERFLOURISHBUFF__:
		{
			addEntertainerFlourishBuff();
		}
		break;
	case RPC_STARTDANCING__STRING_STRING_:
		{
			String dance; String animation; 
			startDancing(inv->getAsciiParameter(dance), inv->getAsciiParameter(animation));
		}
		break;
	case RPC_STARTPLAYINGMUSIC__STRING_STRING_INT_:
		{
			String song; String instrumentAnimation; 
			startPlayingMusic(inv->getAsciiParameter(song), inv->getAsciiParameter(instrumentAnimation), inv->getSignedIntParameter());
		}
		break;
	case RPC_STARTENTERTAINING__:
		{
			startEntertaining();
		}
		break;
	case RPC_FINALIZE__:
		{
			finalize();
		}
		break;
	case RPC_HEALWOUNDS__CREATUREOBJECT_FLOAT_FLOAT_:
		{
			healWounds(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getFloatParameter(), inv->getFloatParameter());
		}
		break;
	case RPC_ISINENTERTAININGBUILDING__CREATUREOBJECT_:
		{
			resp->insertBoolean(isInEntertainingBuilding(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_DOFLOURISH__INT_:
		{
			doFlourish(inv->getSignedIntParameter());
		}
		break;
	case RPC_CANHEALBATTLEFATIGUE__:
		{
			resp->insertBoolean(canHealBattleFatigue());
		}
		break;
	case RPC_CANGIVEENTERTAINBUFF__:
		{
			resp->insertBoolean(canGiveEntertainBuff());
		}
		break;
	case RPC_ADDFLOURISHXP__INT_:
		{
			addFlourishXp(inv->getSignedIntParameter());
		}
		break;
	case RPC_ADDHEALINGXP__INT_:
		{
			addHealingXp(inv->getSignedIntParameter());
		}
		break;
	case RPC_ADDHEALINGXPGROUP__INT_:
		{
			addHealingXpGroup(inv->getSignedIntParameter());
		}
		break;
	case RPC_INITIALIZESESSION__:
		{
			resp->insertSignedInt(initializeSession());
		}
		break;
	case RPC_CANCELSESSION__:
		{
			resp->insertSignedInt(cancelSession());
		}
		break;
	case RPC_CLEARSESSION__:
		{
			resp->insertSignedInt(clearSession());
		}
		break;
	case RPC_STOPPLAYINGMUSIC__:
		{
			stopPlayingMusic();
		}
		break;
	case RPC_STOPDANCING__:
		{
			stopDancing();
		}
		break;
	case RPC_ACTIVATEACTION__:
		{
			activateAction();
		}
		break;
	case RPC_STARTTICKTASK__:
		{
			startTickTask();
		}
		break;
	case RPC_GETENTERTAINERBUFFSTRENGTH__CREATUREOBJECT_INT_:
		{
			resp->insertSignedInt(getEntertainerBuffStrength(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getSignedIntParameter()));
		}
		break;
	case RPC_GETENTERTAINERBUFFDURATION__CREATUREOBJECT_INT_:
		{
			resp->insertSignedInt(getEntertainerBuffDuration(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getSignedIntParameter()));
		}
		break;
	case RPC_GETENTERTAINERBUFFSTARTTIME__CREATUREOBJECT_INT_:
		{
			resp->insertSignedInt(getEntertainerBuffStartTime(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getSignedIntParameter()));
		}
		break;
	case RPC_SENDENTERTAININGUPDATE__CREATUREOBJECT_FLOAT_STRING_INT_INT_:
		{
			String performance; 
			sendEntertainingUpdate(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getFloatParameter(), inv->getAsciiParameter(performance), inv->getUnsignedIntParameter(), inv->getSignedIntParameter());
		}
		break;
	case RPC_SENDENTERTAINMENTUPDATE__CREATUREOBJECT_LONG_STRING_BOOL_:
		{
			String mood; 
			sendEntertainmentUpdate(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getUnsignedLongParameter(), inv->getAsciiParameter(mood), inv->getBooleanParameter());
		}
		break;
	case RPC_ACTIVATEENTERTAINERBUFF__CREATUREOBJECT_INT_:
		{
			activateEntertainerBuff(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getSignedIntParameter());
		}
		break;
	case RPC_GETINSTRUMENT__CREATUREOBJECT_:
		{
			resp->insertLong(getInstrument(static_cast<CreatureObject*>(inv->getObjectParameter()))->_getObjectID());
		}
		break;
	case RPC_GETPERFORMANCENAME__:
		{
			resp->insertAscii(getPerformanceName());
		}
		break;
	case RPC_ADDWATCHER__CREATUREOBJECT_:
		{
			addWatcher(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ADDLISTENER__CREATUREOBJECT_:
		{
			addListener(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ISDANCING__:
		{
			resp->insertBoolean(isDancing());
		}
		break;
	case RPC_ISPLAYINGMUSIC__:
		{
			resp->insertBoolean(isPlayingMusic());
		}
		break;
	case RPC_ISACCEPTINGBANDFLOURISHES__:
		{
			resp->insertBoolean(isAcceptingBandFlourishes());
		}
		break;
	case RPC_SETACCEPTINGBANDFLOURISHES__BOOL_:
		{
			setAcceptingBandFlourishes(inv->getBooleanParameter());
		}
		break;
	case RPC_REMOVEWATCHER__CREATUREOBJECT_:
		{
			removeWatcher(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_REMOVELISTENER__CREATUREOBJECT_:
		{
			removeListener(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SETPERFORMANCENAME__STRING_:
		{
			String name; 
			setPerformanceName(inv->getAsciiParameter(name));
		}
		break;
	case RPC_SETDANCING__BOOL_:
		{
			setDancing(inv->getBooleanParameter());
		}
		break;
	case RPC_SETTARGETINSTRUMENT__BOOL_:
		{
			setTargetInstrument(inv->getBooleanParameter());
		}
		break;
	case RPC_UPDATEENTERTAINERMISSIONSTATUS__BOOL_INT_:
		{
			updateEntertainerMissionStatus(inv->getBooleanParameter(), inv->getSignedIntParameter());
		}
		break;
	case RPC_ISINDENYSERVICELIST__CREATUREOBJECT_:
		{
			resp->insertBoolean(isInDenyServiceList(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ADDTODENYSERVICELIST__CREATUREOBJECT_:
		{
			addToDenyServiceList(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_REMOVEFROMDENYSERVICELIST__CREATUREOBJECT_:
		{
			removeFromDenyServiceList(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_INCREASEENTERTAINERBUFF__CREATUREOBJECT_:
		{
			increaseEntertainerBuff(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_AWARDENTERTAINEREXPERIENCE__:
		{
			awardEntertainerExperience();
		}
		break;
	default:
		throw Exception("Method does not exists");
	}
}

void EntertainingSessionAdapter::doEntertainerPatronEffects() {
	(static_cast<EntertainingSession*>(stub))->doEntertainerPatronEffects();
}

void EntertainingSessionAdapter::doPerformanceAction() {
	(static_cast<EntertainingSession*>(stub))->doPerformanceAction();
}

void EntertainingSessionAdapter::addEntertainerFlourishBuff() {
	(static_cast<EntertainingSession*>(stub))->addEntertainerFlourishBuff();
}

void EntertainingSessionAdapter::startDancing(const String& dance, const String& animation) {
	(static_cast<EntertainingSession*>(stub))->startDancing(dance, animation);
}

void EntertainingSessionAdapter::startPlayingMusic(const String& song, const String& instrumentAnimation, int instrid) {
	(static_cast<EntertainingSession*>(stub))->startPlayingMusic(song, instrumentAnimation, instrid);
}

void EntertainingSessionAdapter::startEntertaining() {
	(static_cast<EntertainingSession*>(stub))->startEntertaining();
}

void EntertainingSessionAdapter::finalize() {
	(static_cast<EntertainingSession*>(stub))->finalize();
}

void EntertainingSessionAdapter::healWounds(CreatureObject* creature, float woundHeal, float shockHeal) {
	(static_cast<EntertainingSession*>(stub))->healWounds(creature, woundHeal, shockHeal);
}

bool EntertainingSessionAdapter::isInEntertainingBuilding(CreatureObject* creature) {
	return (static_cast<EntertainingSession*>(stub))->isInEntertainingBuilding(creature);
}

void EntertainingSessionAdapter::doFlourish(int flourishNumber) {
	(static_cast<EntertainingSession*>(stub))->doFlourish(flourishNumber);
}

bool EntertainingSessionAdapter::canHealBattleFatigue() {
	return (static_cast<EntertainingSession*>(stub))->canHealBattleFatigue();
}

bool EntertainingSessionAdapter::canGiveEntertainBuff() {
	return (static_cast<EntertainingSession*>(stub))->canGiveEntertainBuff();
}

void EntertainingSessionAdapter::addFlourishXp(int xp) {
	(static_cast<EntertainingSession*>(stub))->addFlourishXp(xp);
}

void EntertainingSessionAdapter::addHealingXp(int xp) {
	(static_cast<EntertainingSession*>(stub))->addHealingXp(xp);
}

void EntertainingSessionAdapter::addHealingXpGroup(int xp) {
	(static_cast<EntertainingSession*>(stub))->addHealingXpGroup(xp);
}

int EntertainingSessionAdapter::initializeSession() {
	return (static_cast<EntertainingSession*>(stub))->initializeSession();
}

int EntertainingSessionAdapter::cancelSession() {
	return (static_cast<EntertainingSession*>(stub))->cancelSession();
}

int EntertainingSessionAdapter::clearSession() {
	return (static_cast<EntertainingSession*>(stub))->clearSession();
}

void EntertainingSessionAdapter::stopPlayingMusic() {
	(static_cast<EntertainingSession*>(stub))->stopPlayingMusic();
}

void EntertainingSessionAdapter::stopDancing() {
	(static_cast<EntertainingSession*>(stub))->stopDancing();
}

void EntertainingSessionAdapter::activateAction() {
	(static_cast<EntertainingSession*>(stub))->activateAction();
}

void EntertainingSessionAdapter::startTickTask() {
	(static_cast<EntertainingSession*>(stub))->startTickTask();
}

int EntertainingSessionAdapter::getEntertainerBuffStrength(CreatureObject* creature, int performanceType) {
	return (static_cast<EntertainingSession*>(stub))->getEntertainerBuffStrength(creature, performanceType);
}

int EntertainingSessionAdapter::getEntertainerBuffDuration(CreatureObject* creature, int performanceType) {
	return (static_cast<EntertainingSession*>(stub))->getEntertainerBuffDuration(creature, performanceType);
}

int EntertainingSessionAdapter::getEntertainerBuffStartTime(CreatureObject* creature, int performanceType) {
	return (static_cast<EntertainingSession*>(stub))->getEntertainerBuffStartTime(creature, performanceType);
}

void EntertainingSessionAdapter::sendEntertainingUpdate(CreatureObject* creature, float entval, const String& performance, unsigned int perfcntr, int instrid) {
	(static_cast<EntertainingSession*>(stub))->sendEntertainingUpdate(creature, entval, performance, perfcntr, instrid);
}

void EntertainingSessionAdapter::sendEntertainmentUpdate(CreatureObject* creature, unsigned long long entid, const String& mood, bool updateEntValue) {
	(static_cast<EntertainingSession*>(stub))->sendEntertainmentUpdate(creature, entid, mood, updateEntValue);
}

void EntertainingSessionAdapter::activateEntertainerBuff(CreatureObject* creature, int performanceType) {
	(static_cast<EntertainingSession*>(stub))->activateEntertainerBuff(creature, performanceType);
}

Instrument* EntertainingSessionAdapter::getInstrument(CreatureObject* creature) {
	return (static_cast<EntertainingSession*>(stub))->getInstrument(creature);
}

String EntertainingSessionAdapter::getPerformanceName() {
	return (static_cast<EntertainingSession*>(stub))->getPerformanceName();
}

void EntertainingSessionAdapter::addWatcher(CreatureObject* creature) {
	(static_cast<EntertainingSession*>(stub))->addWatcher(creature);
}

void EntertainingSessionAdapter::addListener(CreatureObject* listener) {
	(static_cast<EntertainingSession*>(stub))->addListener(listener);
}

bool EntertainingSessionAdapter::isDancing() {
	return (static_cast<EntertainingSession*>(stub))->isDancing();
}

bool EntertainingSessionAdapter::isPlayingMusic() {
	return (static_cast<EntertainingSession*>(stub))->isPlayingMusic();
}

bool EntertainingSessionAdapter::isAcceptingBandFlourishes() {
	return (static_cast<EntertainingSession*>(stub))->isAcceptingBandFlourishes();
}

void EntertainingSessionAdapter::setAcceptingBandFlourishes(bool val) {
	(static_cast<EntertainingSession*>(stub))->setAcceptingBandFlourishes(val);
}

void EntertainingSessionAdapter::removeWatcher(CreatureObject* creature) {
	(static_cast<EntertainingSession*>(stub))->removeWatcher(creature);
}

void EntertainingSessionAdapter::removeListener(CreatureObject* creature) {
	(static_cast<EntertainingSession*>(stub))->removeListener(creature);
}

void EntertainingSessionAdapter::setPerformanceName(const String& name) {
	(static_cast<EntertainingSession*>(stub))->setPerformanceName(name);
}

void EntertainingSessionAdapter::setDancing(bool val) {
	(static_cast<EntertainingSession*>(stub))->setDancing(val);
}

void EntertainingSessionAdapter::setTargetInstrument(bool var) {
	(static_cast<EntertainingSession*>(stub))->setTargetInstrument(var);
}

void EntertainingSessionAdapter::updateEntertainerMissionStatus(bool entertaining, const int missionType) {
	(static_cast<EntertainingSession*>(stub))->updateEntertainerMissionStatus(entertaining, missionType);
}

bool EntertainingSessionAdapter::isInDenyServiceList(CreatureObject* target) {
	return (static_cast<EntertainingSession*>(stub))->isInDenyServiceList(target);
}

void EntertainingSessionAdapter::addToDenyServiceList(CreatureObject* target) {
	(static_cast<EntertainingSession*>(stub))->addToDenyServiceList(target);
}

void EntertainingSessionAdapter::removeFromDenyServiceList(CreatureObject* target) {
	(static_cast<EntertainingSession*>(stub))->removeFromDenyServiceList(target);
}

void EntertainingSessionAdapter::increaseEntertainerBuff(CreatureObject* patron) {
	(static_cast<EntertainingSession*>(stub))->increaseEntertainerBuff(patron);
}

void EntertainingSessionAdapter::awardEntertainerExperience() {
	(static_cast<EntertainingSession*>(stub))->awardEntertainerExperience();
}

/*
 *	EntertainingSessionHelper
 */

EntertainingSessionHelper* EntertainingSessionHelper::staticInitializer = EntertainingSessionHelper::instance();

EntertainingSessionHelper::EntertainingSessionHelper() {
	className = "EntertainingSession";

	Core::getObjectBroker()->registerClass(className, this);
}

void EntertainingSessionHelper::finalizeHelper() {
	EntertainingSessionHelper::finalize();
}

DistributedObject* EntertainingSessionHelper::instantiateObject() {
	return new EntertainingSession(DummyConstructorParameter::instance());
}

DistributedObjectServant* EntertainingSessionHelper::instantiateServant() {
	return new EntertainingSessionImplementation(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* EntertainingSessionHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new EntertainingSessionAdapter(static_cast<EntertainingSession*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

