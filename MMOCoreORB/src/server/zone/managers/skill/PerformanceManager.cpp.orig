/*
 				Copyright <SWGEmu>
		See file COPYING for copying conditions. */

#include "PerformanceManager.h"
#include "templates/datatables/DataTableIff.h"
#include "templates/datatables/DataTableRow.h"
#include "server/zone/objects/tangible/Instrument.h"
#include "server/zone/objects/player/sui/listbox/SuiListBox.h"
#include "server/zone/managers/skill/SkillManager.h"
#include "server/zone/objects/player/PlayerObject.h"

PerformanceManager::PerformanceManager() :
	Logger("PerformanceManager") {
	loadPerformances();

	danceMap.put("basic", "dance_1");
	danceMap.put("basic2", "dance_2");
	danceMap.put("rhythmic", "dance_3");
	danceMap.put("rhythmic2", "dance_4");
	danceMap.put("exotic", "dance_5");
	danceMap.put("exotic2", "dance_6");
	danceMap.put("exotic3", "dance_7");
	danceMap.put("exotic4", "dance_8");
	danceMap.put("popular", "dance_9");
	danceMap.put("popular2", "dance_10");
	danceMap.put("lyrical", "dance_11");
	danceMap.put("lyrical2", "dance_12");
	danceMap.put("poplock", "dance_13");
	danceMap.put("poplock2", "dance_14");
	danceMap.put("footloose", "dance_15");
	danceMap.put("footloose2", "dance_16");
	danceMap.put("formal", "dance_17");
	danceMap.put("formal2", "dance_18");
	danceMap.put("theatrical", "dance_21");
	danceMap.put("theatrical2", "dance_22");
	danceMap.put("breakdance", "dance_29");
	danceMap.put("breakdance2", "dance_30");
	danceMap.put("tumble", "dance_31");
	danceMap.put("tumble2", "dance_32");

	instrumentIdMap.put("starwars1", 1);
	instrumentIdMap.put("rock", 11);
	instrumentIdMap.put("starwars2", 21);
	instrumentIdMap.put("folk", 31);
	instrumentIdMap.put("starwars3", 41);
	instrumentIdMap.put("ceremonial", 51);
	instrumentIdMap.put("ballad", 61);
	instrumentIdMap.put("waltz", 71);
	instrumentIdMap.put("jazz", 81);
	instrumentIdMap.put("virtuoso", 91);
	instrumentIdMap.put("western", 101);
	instrumentIdMap.put("starwars4", 111);
	instrumentIdMap.put("funk", 121);

}

String PerformanceManager::getInstrumentAnimation(int instrumentType) {
	String instrumentAnimation = "";

	switch (instrumentType) {
	case Instrument::SLITHERHORN:
		instrumentAnimation = "music_3";
		break;
	case Instrument::FIZZ:
		instrumentAnimation = "music_3";
		break;
	case Instrument::FANFAR:
		instrumentAnimation = "music_3";
		break;
	case Instrument::KLOOHORN:
		instrumentAnimation = "music_3";
		break;
	case Instrument::MANDOVIOL:
		instrumentAnimation = "music_5";
		break;
	case Instrument::TRAZ:
		instrumentAnimation = "music_3";
		break;
	case Instrument::BANDFILL:
		instrumentAnimation = "music_1";
		break;
	case Instrument::FLUTEDROOPY:
		instrumentAnimation = "music_3";
		break;
	case Instrument::OMNIBOX:
		instrumentAnimation = "music_4";
		break;
	case Instrument::NALARGON:
		instrumentAnimation = "music_2";
		break;
	default:
		break;
	}

	return instrumentAnimation;
}

String PerformanceManager::getInstrument(int instrumentType) {
	String instrument;

	switch (instrumentType) {
	case Instrument::SLITHERHORN: //SLITHERHORN: yeah!
		instrument = "slitherhorn";
		break;
	case Instrument::FIZZ: // yeah
		instrument = "fizz";
		break;
	case Instrument::FANFAR: //FANFAR yeah
		instrument = "fanfar";
		break;
	case Instrument::KLOOHORN: // yeah
		instrument = "kloohorn";
		break;
	case Instrument::MANDOVIOL: //MANDOVIOL
		instrument = "mandoviol";
		break;
	case Instrument::TRAZ: //TRAZ yeah
		instrument = "traz";
		break;
	case Instrument::BANDFILL: // yeah
		instrument = "bandfill";
		break;
	case Instrument::FLUTEDROOPY: //
		instrument = "flutedroopy";
		break;
	case Instrument::OMNIBOX: //OMNIBOX:
		instrument = "omnibox";
		break;
	case Instrument::NALARGON: //NALARGON:
		instrument = "nalargon";
		break;
	default:
		//sendSystemMessage("Bad instrument type.");
		break;
	}

	return instrument;
}

PerformanceManager::~PerformanceManager() {
	if (performances != nullptr) {
		for (int i = 0; i < performances->size(); ++i)
			delete performances->getUnsafe(i);

		delete performances;

		performances = nullptr;
	}
}

void PerformanceManager::loadPerformances() {
	IffStream* iffStream = TemplateManager::instance()->openIffFile("datatables/performance/performance.iff");

<<<<<<< Updated upstream
	IffStream* iffStream = TemplateManager::instance()->openIffFile(
			"datatables/performance/performance.iff");

=======
>>>>>>> Stashed changes
	if (iffStream == nullptr) {
		error("Could not open performances datatable.");
		return;
	}

	DataTableIff dtable;
	dtable.readObject(iffStream);

	delete iffStream;

	performances = new Vector<Performance*> ();
	for (int i = 0; i < dtable.getTotalRows(); ++i) {
		DataTableRow* row = dtable.getRow(i);

		Performance* performance = new Performance();
		performance->parseDataTableRow(i+1, row);
		performances->add(performance);
	}

	info("Loaded " + String::valueOf(performances->size()) + " performances.", true);
}

Vector<Performance*> PerformanceManager::getPerformanceListFromMod(const String& requiredSkillMod, int playerSkillModValue, int instrument) {
	String instrumentName = "";
	if (instrument != 0)
		instrumentName = getInstrument(instrument);

	Vector<Performance*> performanceList;

	if (performances != nullptr) {

		for (int i = 0; i < performances->size(); ++i) {
			Performance* perform = performances->get(i);
			if (perform->getRequiredSkillMod() == requiredSkillMod && perform->getRequiredSkillModValue() <= playerSkillModValue) {
				if (instrumentName != "") {
					//Should be a music call, look only for performances with that instrument
					if (instrumentName == perform->getRequiredInstrument())
						performanceList.add(perform);
				} else {
					//Should be a dance call
					performanceList.add(perform);
				}
			}
		}

	}

	return performanceList;
}

Performance* PerformanceManager::getDance(const String& name) {
	if (performances != nullptr) {
		for (int i = 0; i < performances->size(); ++i) {
			Performance* ret = performances->get(i);

			if (ret->isDance() && ret->getName() == name)
				return ret;
		}
	}

	return nullptr;
}

Performance* PerformanceManager::getSong(const String& name, int instrumentType) {
	if (performances != nullptr) {
		for (int i = 0; i < performances->size(); ++i) {
			Performance* ret = performances->get(i);

			if (ret->isMusic() && ret->getName() == name
					&& ret->getInstrumentAudioId() == instrumentType)
				return ret;
		}
	}
	return nullptr;
<<<<<<< Updated upstream
=======
}

int PerformanceManager::getPerformanceIndex(int type, const String& name, int instrumentType) {
	if (performances == nullptr)
		return 0;

	for (int i = 0; i < performances->size(); ++i) {
		Performance* perf = performances->get(i);

		if (perf->getType() == type && perf->getName() == name && perf->getInstrumentAudioId() == instrumentType)
			return perf->getPerformanceIndex();
	}

	return 0;
}

Performance* PerformanceManager::getPerformanceFromIndex(int index) {
	if (performances == nullptr)
		return nullptr;

	for (int i = 0; i < performances->size(); ++i) {
		Performance* perf = performances->get(i);

		if (perf->getPerformanceIndex() == index)
			return perf;
	}

	return nullptr;
}

void PerformanceManager::sendAvailableSongs(CreatureObject* player) {
	Reference<PlayerObject*> ghost = player->getPlayerObject();

	if (ghost == nullptr)
		return;

	Reference<Instrument*> instrument = player->getPlayableInstrument();

	if (instrument == nullptr) {
		player->sendSystemMessage("@performance:music_no_instrument"); // You must have an instrument equipped to play music.
		return;
	}

	Reference<SuiListBox*> sui = new SuiListBox(player, SuiWindowType::MUSIC_START);
	sui->setPromptTitle("@performance:available_songs"); // Available Songs
	sui->setPromptText("@performance:select_song"); // Select a song to play.

	AbilityList* list = ghost->getAbilityList();

	for (int i = 0; i < list->size(); ++i) {
		Ability* ability = list->get(i);

		String abilityName = ability->getAbilityName();

		if (abilityName.indexOf("startMusic") != -1) {
			int args = abilityName.indexOf("+");

			if (args != -1) {
				String arg = abilityName.subString(args + 1);

				sui->addMenuItem(arg);
			}
		}
	}

	ghost->addSuiBox(sui);
	player->sendMessage(sui->generateMessage());
}

void PerformanceManager::sendAvailableDances(CreatureObject* player) {
	Reference<PlayerObject*> ghost = player->getPlayerObject();

	if (ghost == nullptr)
		return;

	ManagedReference<SuiListBox*> sui = new SuiListBox(player, SuiWindowType::DANCING_START);
	sui->setPromptTitle("@performance:available_dances");
	sui->setPromptText("@performance:select_dance");

	AbilityList* list = ghost->getAbilityList();

	for (int i = 0; i < list->size(); ++i) {
		Ability* ability = list->get(i);

		String abilityName = ability->getAbilityName();

		if (abilityName.indexOf("startDance") != -1) {
			int args = abilityName.indexOf("+");

			if (args != -1) {
				String arg = abilityName.subString(args + 1);

				sui->addMenuItem(arg);
			}
		}
	}

	ghost->addSuiBox(sui);
	player->sendMessage(sui->generateMessage());

	return;
}

bool PerformanceManager::canPlayInstrument(CreatureObject* player, int instrumentType) {
	Reference<PlayerObject*> ghost = player->getPlayerObject();

	if (ghost == nullptr)
		false;

	String instr = getInstrument(instrumentType);

	return ghost->hasAbility(instr);
}

bool PerformanceManager::canPlaySong(CreatureObject* player, const String& name) {
	Reference<PlayerObject*> ghost = player->getPlayerObject();

	if (ghost == nullptr)
		false;

	String fullString = String("startMusic") + "+" + name;

	return ghost->hasAbility(fullString);
>>>>>>> Stashed changes
}
