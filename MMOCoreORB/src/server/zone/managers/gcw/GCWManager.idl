package server.zone.managers.gcw;

import engine.core.ManagedService;
import engine.core.Task;
import server.zone.Zone;
import engine.log.Logger;


import engine.core.ManagedObject;
import system.util.SortedVector;

import server.zone.objects.tangible.TangibleObject;
import server.zone.objects.structure.StructureObject;
import server.zone.objects.building.BuildingObject;
import server.zone.objects.installation.InstallationObject;
import server.zone.objects.creature.CreatureObject;
import server.zone.objects.player.PlayerObject;
import system.thread.Mutex;
import server.zone.objects.tangible.deed.structure.StructureDeed;
import server.zone.objects.tangible.deed.Deed;

include server.zone.objects.building.components.DestructibleBuildingDataComponent;
include server.zone.objects.installation.components.TurretDataComponent;
include server.zone.objects.tangible.terminal.components.TurretControlTerminalDataComponent;
include server.zone.templates.ChildObject;
include server.chat.StringIdChatParameter;

class GCWManager extends ManagedService implements Logger {

	public final static int IMPERIALHASH = 3679112276;
	public final static int REBELHASH = 370444368;

	public static final int NOTAFACTIONBASE = 0;
	public static final int PLAYERFACTIONBASE = 1;
	public static final int STATICFACTIONBASE = 2;

	private Zone zone;
	
	@dereferenced 
	protected transient SortedVector<BuildingObject > gcwBaseList;
	
	@dereferenced
	protected transient VectorMap<unsigned long, Reference<Task> > gcwStartTasks;
	
	@dereferenced
	protected transient VectorMap<unsigned long, Reference<Task> > gcwEndTasks;

	@dereferenced
	protected transient Vector<string> dnaNucleotides;

	@dereferenced
	protected transient Vector<string> dnaPairs;
	
	@dereferenced
	protected transient VectorMap<unsigned long, Reference<Task> > gcwDestroyTasks;
	
	@dereferenced
	protected transient Mutex baseMutex;

	@dereferenced
	protected transient VectorMap<string, int> baseValue;

	@dereferenced
	protected transient HashTable<int, float> racialPenaltyMap;

	private transient int rebelBases;
	private transient int rebelScore;
	private transient int imperialBases;
	private transient int imperialScore;
	
	public transient int gcwCheckTimer;
	public transient int vulnerabilityDuration; 
	public transient int vulnerabilityFrequency; 
	public transient int resetTimer; 
	public transient int sliceCooldown;
	public transient int totalDNASamples;
	public transient int powerSwitchCount;
	public transient int dnaStrandLength;
	public transient int destructionTimer;
	public transient int maxBases;
	public transient int overtCooldown;
	public transient int reactivationTimer;
	public transient int turretAutoFireTimeout;
	public transient int maxBasesPerPlayer;
	public transient int bonusXP;
	public transient int winnerBonus;
	public transient int loserBonus;
	public transient boolean spawnDefenses;
	public transient int initialVulnerabilityDelay;
	
	public transient boolean racialPenaltyEnabled;

	@dereferenced
	protected transient Vector<string> imperialStrongholds;
	@dereferenced
	protected transient Vector<string> rebelStrongholds;

	public GCWManager(Zone zne){
		imperialBases = 0;
		imperialScore = 0;
		rebelBases = 0;
		rebelScore = 0;

		gcwCheckTimer = 3600;
		vulnerabilityDuration = 7200;
		vulnerabilityFrequency = 172800;
		resetTimer = 604800;
		sliceCooldown = 120;
		totalDNASamples = 10;
		dnaStrandLength = 23;
		destructionTimer = 600;
		maxBases = -1;
		powerSwitchCount = 7;
		overtCooldown = 300;
		reactivationTimer = 300;
		turretAutoFireTimeout = 20;
		maxBasesPerPlayer = 3;
		bonusXP = 15;
		loserBonus = 0;
		winnerBonus = 30;
		racialPenaltyEnabled = true;
		spawnDefenses = true;
		initialVulnerabilityDelay = 0;

		Logger.setLoggingName("GCWManager " + zne.getZoneName());
		Logger.info("instantiated", true);
		gcwBaseList.setNoDuplicateInsertPlan();
		zone = zne;

		gcwStartTasks.setNoDuplicateInsertPlan();
		gcwStartTasks.setNullValue(null);

		gcwEndTasks.setNoDuplicateInsertPlan();
		gcwEndTasks.setNullValue(null);

		gcwDestroyTasks.setNoDuplicateInsertPlan();
		gcwDestroyTasks.setNullValue(null);

		baseValue.setNoDuplicateInsertPlan();
	}

	@dirty
	public Zone getZone() {
		return zone;
	}

	public native void loadLuaConfig();

	public native void initialize();
	
	public native void start();

	public native void registerGCWBase(BuildingObject building, boolean initializeBase);
	
	public native void unregisterGCWBase(BuildingObject building);
	
	public native void performGCWTasks();

	public native void startVulnerability(BuildingObject building);

	public native void endVulnerability(BuildingObject building);
	
	public native boolean isBaseVulnerable(BuildingObject building);
	
	public native boolean isBandIdentified(BuildingObject building);
	
	public native boolean isUplinkJammed(BuildingObject building);
	
	public native boolean isShutdownSequenceStarted(BuildingObject building);
	
	public native boolean isSecurityTermSliced(BuildingObject building);

	public native boolean isPowerOverloaded(BuildingObject building);

	public native boolean isFacilityRebooting(BuildingObject building);
	
	// called to reschedule the vulnerability time of a base
	public native void resetVulnerability(CreatureObject creature, BuildingObject building);

	public native void sendBaseDefenseStatus(CreatureObject creature, BuildingObject building);
	
	public native void doBaseDestruction(StructureObject structure);

	public native void doBaseDestruction(BuildingObject building);
	
	public native void sendJamUplinkMenu(CreatureObject creature, BuildingObject building, TangibleObject uplinkTerminal);
	
	public native void verifyUplinkBand(CreatureObject creature, BuildingObject building, int band, TangibleObject uplinkTerminal);
	
	public native boolean canStartSlice(CreatureObject creature, TangibleObject terminal);
	
	public native void sendDNASampleMenu(CreatureObject creature, BuildingObject building, TangibleObject overrideTerminal);
		
	public native void completeSecuritySlice(CreatureObject creature, TangibleObject securityTerminal);
	
	public native void failSecuritySlice(TangibleObject securityTerminal);
	
	public native boolean isTerminalDamaged(TangibleObject securityTerminal);
	
	public native boolean isDNASampled(BuildingObject building);
	
	public native void repairTerminal(CreatureObject creature, TangibleObject securityTerminal);
	
	public native void abortShutdownSequence(BuildingObject building, CreatureObject creature);

	public native void startAbortSequenceDelay(BuildingObject building, CreatureObject creature, SceneObject hqTerminal);
	
	public native void processDNASample(CreatureObject creature, TangibleObject overrideTerminal, int indx);
	
	public native void handlePowerRegulatorSwitch(CreatureObject creature, TangibleObject powerRegulator, int indx);
	
	public native void sendPowerRegulatorControls(CreatureObject creature, BuildingObject building, TangibleObject powerRegulator);

	protected synchronized boolean hasBase(BuildingObject building){
		return gcwBaseList.contains(building);
	}
	
	protected synchronized boolean dropBase(BuildingObject building){
		return gcwBaseList.drop(building);
	}
	
	protected synchronized void addBase(BuildingObject building){
		gcwBaseList.put(building);
	}
	
	protected synchronized BuildingObject getBase(int indx){
		return gcwBaseList.get(indx);
	}
	protected synchronized boolean hasStartTask(unsigned long id){
		return gcwStartTasks.contains(id);
	}
	
	@local
	protected synchronized boolean addStartTask(unsigned long id, Reference<Task> newTask){
		if(!gcwStartTasks.contains(id)){
			return gcwStartTasks.put(id, newTask);
		}
		return false;
	}
	
	@local
	protected synchronized Reference<Task> getStartTask(unsigned long id){
		return gcwStartTasks.get(id);
	}
	
	protected synchronized boolean dropStartTask(unsigned long id){
		return gcwStartTasks.drop(id);
	}
	
	protected synchronized boolean hasEndTask(unsigned long id){
		return gcwEndTasks.contains(id);
	}
	
	@local
	protected synchronized boolean addEndTask(unsigned long id, Reference<Task> newTask){
		if(!gcwEndTasks.contains(id)){
			return	gcwEndTasks.put(id, newTask);
		}
		return false;
	}
	
	@local
	protected synchronized Reference<Task> getEndTask(unsigned long id){
		return gcwEndTasks.get(id);
	}
	
	protected synchronized boolean dropEndTask(unsigned long id){
		return gcwEndTasks.drop(id);
	}
	
	protected synchronized boolean hasDestroyTask(unsigned long id){
		return gcwDestroyTasks.contains(id);
	}
	
	@local
	protected synchronized boolean addDestroyTask(unsigned long id, Reference<Task> newTask){
		if(!gcwDestroyTasks.contains(id)){
			return gcwDestroyTasks.put(id, newTask);
		}
		return false;
	}
	
	@local
	protected synchronized Reference<Task> getDestroyTask(unsigned long id){
		return gcwDestroyTasks.get(id);
	}
		
	protected synchronized boolean dropDestroyTask(unsigned long id){
		return gcwDestroyTasks.drop(id);
	}

	public synchronized boolean isPlanetCapped() {
		return maxBases <= gcwBaseList.size();
	}

	private native DestructibleBuildingDataComponent getDestructibleBuildingData(BuildingObject building);
	
	public native boolean hasResetTimerPast(BuildingObject building);

	private native void checkVulnerabilityData(BuildingObject building);

	private native void scheduleVulnerabilityStart(BuildingObject building);

	private native void scheduleVulnerabilityEnd(BuildingObject building);

	public native void scheduleBaseDestruction(BuildingObject building, CreatureObject creature);
	
	private native void initializeBaseTimers(BuildingObject building);
	
	private native void renewUplinkBand(BuildingObject building);

	private native void constructDNAStrand(BuildingObject building);

	private native void createPowerRegulatorRules(BuildingObject building);

	private native void randomizePowerRegulatorSwitches(BuildingObject building);

	private native void flipPowerSwitch(BuildingObject building, @dereferenced Vector<boolean> switchStates, int flipSwitch);
	
	private native void refreshExpiredVulnerability(BuildingObject building);
	
	public native void initializeNewVulnerability(BuildingObject building);

	private native void initializeNewVulnerability(DestructibleBuildingDataComponent data);

	public native void notifyInstallationDestruction(InstallationObject installation);

	public native void notifyTurretDestruction(BuildingObject building, InstallationObject turret);

	public native void notifyMinefieldDestruction(BuildingObject building, InstallationObject turret);

	private native void destroyStandaloneTurret(InstallationObject turret);

	public native void sendSelectDeedToDonate(BuildingObject building, CreatureObject creature,int turretIndex);

	public native void sendRemoveDefenseConfirmation(BuildingObject building, CreatureObject creature, unsigned long deedOID);

	public native void performDefenseDonation(BuildingObject building, CreatureObject creature, unsigned long deedOID, int turretIndex);

	private native void performDonateMine(BuildingObject building, CreatureObject creature, SceneObject sceneObject);

	private native void performDonateMinefield(BuildingObject building, CreatureObject creature, Deed deed);

	private native void performDonateTurret(BuildingObject building, CreatureObject creature, Deed deed);

	private native unsigned long addChildInstallationFromDeed(BuildingObject building, ChildObject child, CreatureObject creature, Deed deed);

	public native string getVulnerableStatus(BuildingObject building, CreatureObject creature);

	public native void addMinefield(BuildingObject building, SceneObject minefield);

	public native void addTurret(BuildingObject building, SceneObject turret);

	public native void addScanner(BuildingObject building, SceneObject scanner);

	public native void removeDefense(BuildingObject building, CreatureObject creature, unsigned long deedOID);

	private native void verifyTurrets(BuildingObject building);

	public native boolean canUseTerminals(CreatureObject creature, BuildingObject building, SceneObject terminal);

	public native void sendTurretAttackListTo(CreatureObject creature, SceneObject turretControlTerminal);
	
	private native TurretControlTerminalDataComponent getTurretControlDataComponent(SceneObject terminal);

	private native TurretDataComponent getTurretDataComponent(SceneObject turret);

	private native void generateTurretControlBoxTo(CreatureObject creature, TangibleObject turret, SceneObject terminal);

	private native boolean canUseTurret(TurretDataComponent turretData, TurretControlTerminalDataComponent controlData, CreatureObject creature);

	public native boolean canPlaceMoreBases(CreatureObject creature);

	public native boolean areOpposingFactions(int faction1, int faction2);

	public native boolean hasTooManyBasesNearby(int x, int y);

	public int getImperialBaseCount() {
		return imperialBases;
	}

	public int getRebelBaseCount() {
		return rebelBases;
	}

	@local
	@read
	public int getRebelScore() {
		return rebelScore;
	}

	@local
	@read
	public int getImperialScore() {
		return imperialScore;
	}

	@local 
	public void setRebelScore(int val){
		rebelScore = val;
	}
	
	@local
	public void setImperialScore(int val){
		imperialScore = val;
	}

	@local 
	private void setRebelBaseCount(int val){
		rebelBases = val;
	}

	@local
	private void setImperialBaseCount(int val){
		imperialBases = val;
	}

	@local 
	public unsigned int getWinningFaction() {

		if(getRebelScore() > getImperialScore())
			return REBELHASH;
		else if ( getImperialScore() > getRebelScore() )
			return IMPERIALHASH;
		else
			return 1;
	}

	public native float getGCWDiscount(CreatureObject creature);

	@local
	@read
	public int getGCWXPBonus() {
		return bonusXP;
	}

	@local
	public native void broadcastBuilding(BuildingObject building, @dereferenced StringIdChatParameter params);

	@local
	public int getPointValue(final string templateString){
		synchronized (baseMutex) {
			return baseValue.get(templateString);
		}
	}

	@local
	public void addPointValue(final string templateString, int val){
		baseValue.put(templateString, val);
	}

	@local
	public void addRacialPenalty(int race, float val){
		racialPenaltyMap.put(race, val);
	}

	@local
	public float getRacialPenalty(int race){
		synchronized (baseMutex) {
			return racialPenaltyMap.get(race);
		}
	}

	@local
	@read
	public boolean isRacialPenaltyEnabled() {
		return racialPenaltyEnabled;
	}
 
	@local
	@read
	public boolean shouldSpawnDefenses() {
		return spawnDefenses;
	}

	@local
	@read
	public int getInitialVulnerabilityDelay() {
		return initialVulnerabilityDelay;
	}

	public native void awardSlicingXP(CreatureObject creature, final string xpType, int value);

	@dirty
	public native int isStrongholdCity(string city);

	@read
	public int getTurretAutoFireTimeout() {
		return turretAutoFireTimeout;
	}

	@read
	public int getDestructionTimer() {
		return destructionTimer;
	}

	@read
	public int getOvertCooldown() {
		return overtCooldown;
	}

	@read
	public int getResetTimer() {
		return resetTimer;
	}
}

