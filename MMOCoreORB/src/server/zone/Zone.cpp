/*
 *	server/zone/Zone.cpp generated by engine3 IDL compiler 0.60
 */

#include "Zone.h"

#include "server/zone/ZoneProcessServer.h"

#include "server/zone/objects/area/ActiveArea.h"

#include "server/zone/managers/planet/PlanetManager.h"

#include "server/zone/managers/creature/CreatureManager.h"

#include "server/zone/managers/objectcontroller/ObjectController.h"

#include "server/zone/managers/gcw/GCWManager.h"

#include "server/zone/managers/minigames/FishingManager.h"

#include "server/zone/managers/minigames/GamblingManager.h"

#include "server/zone/managers/minigames/ForageManager.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/region/CityRegion.h"

/*
 *	ZoneStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 6,RPC_FINALIZE__,RPC_GETNEARESTPLANETARYOBJECT__SCENEOBJECT_STRING_,RPC_INITIALIZEPRIVATEDATA__,RPC_CREATECONTAINERCOMPONENT__,RPC_UPDATEACTIVEAREAS__SCENEOBJECT_,RPC_STARTMANAGERS__,RPC_STOPMANAGERS__,RPC_GETHEIGHT__FLOAT_FLOAT_,RPC_ADDSCENEOBJECT__SCENEOBJECT_,RPC_ADDCITYREGIONTOUPDATE__CITYREGION_,RPC_UPDATECITYREGIONS__,RPC_SENDMAPLOCATIONSTO__SCENEOBJECT_,RPC_DROPSCENEOBJECT__SCENEOBJECT_,RPC_GETPLANETMANAGER__,RPC_GETZONESERVER__,RPC_GETCREATUREMANAGER__,RPC_GETGALACTICTIME__,RPC_HASMANAGERSSTARTED__,RPC_GETMINX__,RPC_GETMAXX__,RPC_GETMINY__,RPC_GETMAXY__,RPC_GETBOUNDINGRADIUS__,RPC_REGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_,RPC_UNREGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_,RPC_GETZONENAME__,RPC_GETZONECRC__,RPC_GETGCWMANAGER__,RPC_SETCHATROOM__CHATROOM_,RPC_GETCHATROOM__};

Zone::Zone(ZoneProcessServer* processor, const String& zoneName) : SceneObject(DummyConstructorParameter::instance()) {
	ZoneImplementation* _implementation = new ZoneImplementation(processor, zoneName);
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("Zone");
}

Zone::Zone(DummyConstructorParameter* param) : SceneObject(param) {
	_setClassName("Zone");
}

Zone::~Zone() {
}



void Zone::initializeTransientMembers() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeTransientMembers();
}

SceneObject* Zone::getNearestPlanetaryObject(SceneObject* object, const String& mapObjectLocationType) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNEARESTPLANETARYOBJECT__SCENEOBJECT_STRING_);
		method.addObjectParameter(object);
		method.addAsciiParameter(mapObjectLocationType);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getNearestPlanetaryObject(object, mapObjectLocationType);
}

void Zone::initializePrivateData() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEPRIVATEDATA__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializePrivateData();
}

QuadTree* Zone::getRegionTree() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getRegionTree();
}

int Zone::getInRangeObjects(float x, float y, float range, SortedVector<ManagedReference<QuadTreeEntry* > >* objects, bool readLockZone) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getInRangeObjects(x, y, range, objects, readLockZone);
}

void Zone::createContainerComponent() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATECONTAINERCOMPONENT__);

		method.executeWithVoidReturn();
	} else
		_implementation->createContainerComponent();
}

int Zone::getInRangeActiveAreas(float x, float y, SortedVector<ManagedReference<ActiveArea* > >* objects, bool readLockZone) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getInRangeActiveAreas(x, y, objects, readLockZone);
}

SortedVector<ManagedReference<SceneObject* > > Zone::getPlanetaryObjectList(const String& mapObjectLocationType) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getPlanetaryObjectList(mapObjectLocationType);
}

void Zone::insert(QuadTreeEntry* entry) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->insert(entry);
}

void Zone::remove(QuadTreeEntry* entry) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->remove(entry);
}

void Zone::update(QuadTreeEntry* entry) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->update(entry);
}

void Zone::inRange(QuadTreeEntry* entry, float range) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->inRange(entry, range);
}

void Zone::updateActiveAreas(SceneObject* object) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEACTIVEAREAS__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else
		_implementation->updateActiveAreas(object);
}

void Zone::startManagers() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTMANAGERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->startManagers();
}

void Zone::stopManagers() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPMANAGERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->stopManagers();
}

float Zone::getHeight(float x, float y) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEIGHT__FLOAT_FLOAT_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getHeight(x, y);
}

void Zone::addSceneObject(SceneObject* object) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSCENEOBJECT__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else
		_implementation->addSceneObject(object);
}

void Zone::addCityRegionToUpdate(CityRegion* city) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCITYREGIONTOUPDATE__CITYREGION_);
		method.addObjectParameter(city);

		method.executeWithVoidReturn();
	} else
		_implementation->addCityRegionToUpdate(city);
}

void Zone::updateCityRegions() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATECITYREGIONS__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateCityRegions();
}

void Zone::sendMapLocationsTo(SceneObject* player) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDMAPLOCATIONSTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendMapLocationsTo(player);
}

void Zone::dropSceneObject(SceneObject* object) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DROPSCENEOBJECT__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else
		_implementation->dropSceneObject(object);
}

PlanetManager* Zone::getPlanetManager() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLANETMANAGER__);

		return static_cast<PlanetManager*>(method.executeWithObjectReturn());
	} else
		return _implementation->getPlanetManager();
}

ZoneServer* Zone::getZoneServer() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETZONESERVER__);

		return static_cast<ZoneServer*>(method.executeWithObjectReturn());
	} else
		return _implementation->getZoneServer();
}

CreatureManager* Zone::getCreatureManager() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCREATUREMANAGER__);

		return static_cast<CreatureManager*>(method.executeWithObjectReturn());
	} else
		return _implementation->getCreatureManager();
}

unsigned long long Zone::getGalacticTime() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGALACTICTIME__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getGalacticTime();
}

bool Zone::hasManagersStarted() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASMANAGERSSTARTED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasManagersStarted();
}

float Zone::getMinX() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINX__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getMinX();
}

float Zone::getMaxX() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXX__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getMaxX();
}

float Zone::getMinY() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINY__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getMinY();
}

float Zone::getMaxY() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXY__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getMaxY();
}

bool Zone::isWithinBoundaries(const Vector3& position) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->isWithinBoundaries(position);
}

float Zone::getBoundingRadius() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBOUNDINGRADIUS__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getBoundingRadius();
}

void Zone::registerObjectWithPlanetaryMap(SceneObject* object) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else
		_implementation->registerObjectWithPlanetaryMap(object);
}

void Zone::unregisterObjectWithPlanetaryMap(SceneObject* object) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNREGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else
		_implementation->unregisterObjectWithPlanetaryMap(object);
}

String Zone::getZoneName() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETZONENAME__);

		String _return_getZoneName;
		method.executeWithAsciiReturn(_return_getZoneName);
		return _return_getZoneName;
	} else
		return _implementation->getZoneName();
}

unsigned int Zone::getZoneCRC() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETZONECRC__);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getZoneCRC();
}

GCWManager* Zone::getGCWManager() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGCWMANAGER__);

		return static_cast<GCWManager*>(method.executeWithObjectReturn());
	} else
		return _implementation->getGCWManager();
}

void Zone::setChatRoom(ChatRoom* room) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCHATROOM__CHATROOM_);
		method.addObjectParameter(room);

		method.executeWithVoidReturn();
	} else
		_implementation->setChatRoom(room);
}

ChatRoom* Zone::getChatRoom() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCHATROOM__);

		return static_cast<ChatRoom*>(method.executeWithObjectReturn());
	} else
		return _implementation->getChatRoom();
}

DistributedObjectServant* Zone::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* Zone::_getImplementationForRead() {
	return _impl;
}

void Zone::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ZoneImplementation
 */

ZoneImplementation::ZoneImplementation(DummyConstructorParameter* param) : SceneObjectImplementation(param) {
	_initializeImplementation();
}


ZoneImplementation::~ZoneImplementation() {
	ZoneImplementation::finalize();
}


void ZoneImplementation::_initializeImplementation() {
	_setClassHelper(ZoneHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void ZoneImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<Zone*>(stub);
	SceneObjectImplementation::_setStub(stub);
}

DistributedObjectStub* ZoneImplementation::_getStub() {
	return _this.get();
}

ZoneImplementation::operator const Zone*() {
	return _this.get();
}

void ZoneImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void ZoneImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void ZoneImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void ZoneImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void ZoneImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void ZoneImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void ZoneImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void ZoneImplementation::_serializationHelperMethod() {
	SceneObjectImplementation::_serializationHelperMethod();

	_setClassName("Zone");

}

void ZoneImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ZoneImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ZoneImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SceneObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xa762ac22: //Zone.zoneName
		TypeInfo<String >::parseFromBinaryStream(&zoneName, stream);
		return true;

	case 0xd9ac1ed3: //Zone.zoneCRC
		TypeInfo<unsigned int >::parseFromBinaryStream(&zoneCRC, stream);
		return true;

	case 0xc1522ac5: //Zone.chatRoom
		TypeInfo<ManagedReference<ChatRoom* > >::parseFromBinaryStream(&chatRoom, stream);
		return true;

	case 0x7b0557ae: //Zone.regionTree
		TypeInfo<QuadTreeReference >::parseFromBinaryStream(&regionTree, stream);
		return true;

	case 0x623385b4: //Zone.quadTree
		TypeInfo<QuadTreeReference >::parseFromBinaryStream(&quadTree, stream);
		return true;

	}

	return false;
}

void ZoneImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ZoneImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ZoneImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SceneObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xa762ac22; //Zone.zoneName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&zoneName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd9ac1ed3; //Zone.zoneCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&zoneCRC, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc1522ac5; //Zone.chatRoom
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<ChatRoom* > >::toBinaryStream(&chatRoom, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x7b0557ae; //Zone.regionTree
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<QuadTreeReference >::toBinaryStream(&regionTree, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x623385b4; //Zone.quadTree
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<QuadTreeReference >::toBinaryStream(&quadTree, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 5;
}

QuadTree* ZoneImplementation::getRegionTree() {
	// server/zone/Zone.idl():  		return regionTree.get();
	return (&regionTree)->get();
}

void ZoneImplementation::addCityRegionToUpdate(CityRegion* city) {
	Locker _locker(_this.get());
	// server/zone/Zone.idl():  		cityRegionUpdateVector.put(city);
	(&cityRegionUpdateVector)->put(city);
}

PlanetManager* ZoneImplementation::getPlanetManager() {
	// server/zone/Zone.idl():  		return planetManager;
	return planetManager;
}

ZoneServer* ZoneImplementation::getZoneServer() {
	// server/zone/Zone.idl():  		return server;
	return server;
}

CreatureManager* ZoneImplementation::getCreatureManager() {
	// server/zone/Zone.idl():  		return creatureManager;
	return creatureManager;
}

unsigned long long ZoneImplementation::getGalacticTime() {
	// server/zone/Zone.idl():  		return galacticTime.miliDifference() / 1000;
	return (&galacticTime)->miliDifference() / 1000;
}

bool ZoneImplementation::hasManagersStarted() {
	// server/zone/Zone.idl():  		return managersStarted;
	return managersStarted;
}

String ZoneImplementation::getZoneName() {
	// server/zone/Zone.idl():  		return zoneName;
	return zoneName;
}

unsigned int ZoneImplementation::getZoneCRC() {
	// server/zone/Zone.idl():  		return zoneCRC;
	return zoneCRC;
}

GCWManager* ZoneImplementation::getGCWManager() {
	// server/zone/Zone.idl():  		return gcwManager;
	return gcwManager;
}

void ZoneImplementation::setChatRoom(ChatRoom* room) {
	// server/zone/Zone.idl():  		chatRoom = room;
	chatRoom = room;
}

ChatRoom* ZoneImplementation::getChatRoom() {
	// server/zone/Zone.idl():  		return chatRoom;
	return chatRoom;
}

/*
 *	ZoneAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ZoneAdapter::ZoneAdapter(Zone* obj) : SceneObjectAdapter(obj) {
}

void ZoneAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			initializeTransientMembers();
		}
		break;
	case RPC_FINALIZE__:
		{
			finalize();
		}
		break;
	case RPC_GETNEARESTPLANETARYOBJECT__SCENEOBJECT_STRING_:
		{
			String mapObjectLocationType; 
			resp->insertLong(getNearestPlanetaryObject(static_cast<SceneObject*>(inv->getObjectParameter()), inv->getAsciiParameter(mapObjectLocationType))->_getObjectID());
		}
		break;
	case RPC_INITIALIZEPRIVATEDATA__:
		{
			initializePrivateData();
		}
		break;
	case RPC_CREATECONTAINERCOMPONENT__:
		{
			createContainerComponent();
		}
		break;
	case RPC_UPDATEACTIVEAREAS__SCENEOBJECT_:
		{
			updateActiveAreas(static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_STARTMANAGERS__:
		{
			startManagers();
		}
		break;
	case RPC_STOPMANAGERS__:
		{
			stopManagers();
		}
		break;
	case RPC_GETHEIGHT__FLOAT_FLOAT_:
		{
			resp->insertFloat(getHeight(inv->getFloatParameter(), inv->getFloatParameter()));
		}
		break;
	case RPC_ADDSCENEOBJECT__SCENEOBJECT_:
		{
			addSceneObject(static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ADDCITYREGIONTOUPDATE__CITYREGION_:
		{
			addCityRegionToUpdate(static_cast<CityRegion*>(inv->getObjectParameter()));
		}
		break;
	case RPC_UPDATECITYREGIONS__:
		{
			updateCityRegions();
		}
		break;
	case RPC_SENDMAPLOCATIONSTO__SCENEOBJECT_:
		{
			sendMapLocationsTo(static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_DROPSCENEOBJECT__SCENEOBJECT_:
		{
			dropSceneObject(static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_GETPLANETMANAGER__:
		{
			resp->insertLong(getPlanetManager()->_getObjectID());
		}
		break;
	case RPC_GETZONESERVER__:
		{
			resp->insertLong(getZoneServer()->_getObjectID());
		}
		break;
	case RPC_GETCREATUREMANAGER__:
		{
			resp->insertLong(getCreatureManager()->_getObjectID());
		}
		break;
	case RPC_GETGALACTICTIME__:
		{
			resp->insertLong(getGalacticTime());
		}
		break;
	case RPC_HASMANAGERSSTARTED__:
		{
			resp->insertBoolean(hasManagersStarted());
		}
		break;
	case RPC_GETMINX__:
		{
			resp->insertFloat(getMinX());
		}
		break;
	case RPC_GETMAXX__:
		{
			resp->insertFloat(getMaxX());
		}
		break;
	case RPC_GETMINY__:
		{
			resp->insertFloat(getMinY());
		}
		break;
	case RPC_GETMAXY__:
		{
			resp->insertFloat(getMaxY());
		}
		break;
	case RPC_GETBOUNDINGRADIUS__:
		{
			resp->insertFloat(getBoundingRadius());
		}
		break;
	case RPC_REGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_:
		{
			registerObjectWithPlanetaryMap(static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_UNREGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_:
		{
			unregisterObjectWithPlanetaryMap(static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_GETZONENAME__:
		{
			resp->insertAscii(getZoneName());
		}
		break;
	case RPC_GETZONECRC__:
		{
			resp->insertInt(getZoneCRC());
		}
		break;
	case RPC_GETGCWMANAGER__:
		{
			resp->insertLong(getGCWManager()->_getObjectID());
		}
		break;
	case RPC_SETCHATROOM__CHATROOM_:
		{
			setChatRoom(static_cast<ChatRoom*>(inv->getObjectParameter()));
		}
		break;
	case RPC_GETCHATROOM__:
		{
			resp->insertLong(getChatRoom()->_getObjectID());
		}
		break;
	default:
		throw Exception("Method does not exists");
	}
}

void ZoneAdapter::initializeTransientMembers() {
	(static_cast<Zone*>(stub))->initializeTransientMembers();
}

void ZoneAdapter::finalize() {
	(static_cast<Zone*>(stub))->finalize();
}

SceneObject* ZoneAdapter::getNearestPlanetaryObject(SceneObject* object, const String& mapObjectLocationType) {
	return (static_cast<Zone*>(stub))->getNearestPlanetaryObject(object, mapObjectLocationType);
}

void ZoneAdapter::initializePrivateData() {
	(static_cast<Zone*>(stub))->initializePrivateData();
}

void ZoneAdapter::createContainerComponent() {
	(static_cast<Zone*>(stub))->createContainerComponent();
}

void ZoneAdapter::updateActiveAreas(SceneObject* object) {
	(static_cast<Zone*>(stub))->updateActiveAreas(object);
}

void ZoneAdapter::startManagers() {
	(static_cast<Zone*>(stub))->startManagers();
}

void ZoneAdapter::stopManagers() {
	(static_cast<Zone*>(stub))->stopManagers();
}

float ZoneAdapter::getHeight(float x, float y) {
	return (static_cast<Zone*>(stub))->getHeight(x, y);
}

void ZoneAdapter::addSceneObject(SceneObject* object) {
	(static_cast<Zone*>(stub))->addSceneObject(object);
}

void ZoneAdapter::addCityRegionToUpdate(CityRegion* city) {
	(static_cast<Zone*>(stub))->addCityRegionToUpdate(city);
}

void ZoneAdapter::updateCityRegions() {
	(static_cast<Zone*>(stub))->updateCityRegions();
}

void ZoneAdapter::sendMapLocationsTo(SceneObject* player) {
	(static_cast<Zone*>(stub))->sendMapLocationsTo(player);
}

void ZoneAdapter::dropSceneObject(SceneObject* object) {
	(static_cast<Zone*>(stub))->dropSceneObject(object);
}

PlanetManager* ZoneAdapter::getPlanetManager() {
	return (static_cast<Zone*>(stub))->getPlanetManager();
}

ZoneServer* ZoneAdapter::getZoneServer() {
	return (static_cast<Zone*>(stub))->getZoneServer();
}

CreatureManager* ZoneAdapter::getCreatureManager() {
	return (static_cast<Zone*>(stub))->getCreatureManager();
}

unsigned long long ZoneAdapter::getGalacticTime() {
	return (static_cast<Zone*>(stub))->getGalacticTime();
}

bool ZoneAdapter::hasManagersStarted() {
	return (static_cast<Zone*>(stub))->hasManagersStarted();
}

float ZoneAdapter::getMinX() {
	return (static_cast<Zone*>(stub))->getMinX();
}

float ZoneAdapter::getMaxX() {
	return (static_cast<Zone*>(stub))->getMaxX();
}

float ZoneAdapter::getMinY() {
	return (static_cast<Zone*>(stub))->getMinY();
}

float ZoneAdapter::getMaxY() {
	return (static_cast<Zone*>(stub))->getMaxY();
}

float ZoneAdapter::getBoundingRadius() {
	return (static_cast<Zone*>(stub))->getBoundingRadius();
}

void ZoneAdapter::registerObjectWithPlanetaryMap(SceneObject* object) {
	(static_cast<Zone*>(stub))->registerObjectWithPlanetaryMap(object);
}

void ZoneAdapter::unregisterObjectWithPlanetaryMap(SceneObject* object) {
	(static_cast<Zone*>(stub))->unregisterObjectWithPlanetaryMap(object);
}

String ZoneAdapter::getZoneName() {
	return (static_cast<Zone*>(stub))->getZoneName();
}

unsigned int ZoneAdapter::getZoneCRC() {
	return (static_cast<Zone*>(stub))->getZoneCRC();
}

GCWManager* ZoneAdapter::getGCWManager() {
	return (static_cast<Zone*>(stub))->getGCWManager();
}

void ZoneAdapter::setChatRoom(ChatRoom* room) {
	(static_cast<Zone*>(stub))->setChatRoom(room);
}

ChatRoom* ZoneAdapter::getChatRoom() {
	return (static_cast<Zone*>(stub))->getChatRoom();
}

/*
 *	ZoneHelper
 */

ZoneHelper* ZoneHelper::staticInitializer = ZoneHelper::instance();

ZoneHelper::ZoneHelper() {
	className = "Zone";

	Core::getObjectBroker()->registerClass(className, this);
}

void ZoneHelper::finalizeHelper() {
	ZoneHelper::finalize();
}

DistributedObject* ZoneHelper::instantiateObject() {
	return new Zone(DummyConstructorParameter::instance());
}

DistributedObjectServant* ZoneHelper::instantiateServant() {
	return new ZoneImplementation(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* ZoneHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ZoneAdapter(static_cast<Zone*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

